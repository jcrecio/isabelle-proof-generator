
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Formatting</title>
    <style>
        pre {
            white-space: pre-wrap;
            word-wrap: break-word; 
            overflow-x: auto;
            max-height: 400px;
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/Approximation_Algorithms/_home_qj213_afp-2021-10-22_thys_Approximation_Algorithms_Approx_VC_Hoare_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma card_matching_vertex_cover:
  "\<lbrakk> finite C;  matching M;  M \<subseteq> E;  vertex_cover E C \<rbrakk> \<Longrightarrow> card M \<le> card C"</h2><br>
<b>Ground proof:</b> <br><pre><code>apply(erule card_le_if_inj_on_rel[where r = "\<lambda>e v. v \<in> e"]) apply (meson disjnt_def disjnt_iff vertex_cover_def subsetCE) by (meson disjnt_iff pairwise_def) subsection "The Approximation Algorithm" text \<open>Formulated using a simple(!) predefined Hoare-logic.
This leads to a streamlined proof based on standard invariant reasoning.

The nondeterministic selection of an element from a set \<open>F\<close> is simulated by @{term "SOME x. x \<in> F"}.
The \<open>SOME\<close> operator is built into HOL: @{term "SOME x. P x"} denotes some \<open>x\<close> that satisfies \<open>P\<close>
if such an \<open>x\<close> exists; otherwise it denotes an arbitrary element. Note that there is no
actual nondeterminism involved: @{term "SOME x. P x"} is some fixed element
but in general we don't know which one. Proofs about \<open>SOME\<close> are notoriously tedious.
Typically it involves showing first that @{prop "\<exists>x. P x"}. Then @{thm someI_ex} implies
@{prop"P (SOME x. P x)"}. There are a number of (more) useful related theorems:
just click on @{thm someI_ex} to be taken there.\<close> text \<open>Convenient notation for choosing an arbitrary element from a set:\<close> abbreviation "some A \<equiv> SOME x. x \<in> A" locale Edges =
  fixes E :: "'a set set"
  assumes finE: "finite E"
  assumes edges2: "e \<in> E \<Longrightarrow> card e = 2"
begin text \<open>The invariant:\<close> definition "inv_matching C F M =
  (matching M \<and> M \<subseteq> E \<and> card C \<le> 2 * card M \<and> (\<forall>e \<in> M. \<forall>f \<in> F. e \<inter> f = {}))" definition invar :: "'a set \<Rightarrow> 'a set set \<Rightarrow> bool" where
"invar C F = (F \<subseteq> E \<and> vertex_cover (E-F) C \<and> finite C \<and> (\<exists>M. inv_matching C F M))" text \<open>Preservation of the invariant by the loop body:\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume finite C, matching M, M ⊆ E, and vertex_cover E C.
2. By the definition of vertex_cover, every edge in E is incident to at least one vertex in C.
3. Since M is a matching, no two edges in M share a vertex.
4. Therefore, the number of edges in M is less than or equal to the number of vertices in C.
5. Hence, card M ≤ card C.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 204 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy"): command expected,
*** but identifier Proof (line 204 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy") was found
*** At command "<malformed>" (line 202 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:35 cpu time, factor 3.70
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (1%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma invar_step:
  assumes "F \<noteq> {}" "invar C F"
  shows "invar (C \<union> some F) (F - {e' \<in> F. some F \<inter> e' \<noteq> {}})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - from assms(2) obtain M where "F \<subseteq> E" and vc: "vertex_cover (E-F) C" and fC: "finite C"
    and m: "matching M" "M \<subseteq> E" and card: "card C \<le> 2 * card M"
    and disj: "\<forall>e \<in> M. \<forall>f \<in> F. e \<inter> f = {}" by (auto simp: invar_def inv_matching_def) let ?e = "SOME e. e \<in> F" have "?e \<in> F" using \<open>F \<noteq> {}\<close> by (simp add: some_in_eq) hence fe': "finite ?e" using \<open>F \<subseteq> E\<close> edges2 by(intro card_ge_0_finite) auto have "?e \<notin> M" using edges2 \<open>?e \<in> F\<close> disj \<open>F \<subseteq> E\<close> by fastforce have card': "card (C \<union> ?e) \<le> 2 * card (insert ?e M)" using \<open>?e \<in> F\<close> \<open>?e \<notin> M\<close> card_Un_le[of C ?e] \<open>F \<subseteq> E\<close> edges2 card finite_subset[OF m(2) finE] by fastforce let ?M = "M \<union> {?e}" have vc': "vertex_cover (E - (F - {e' \<in> F. ?e \<inter> e' \<noteq> {}})) (C \<union> ?e)" using vc by(auto simp: vertex_cover_def) have m': "inv_matching (C \<union> ?e) (F - {e' \<in> F. ?e \<inter> e' \<noteq> {}}) ?M" using m card' \<open>F \<subseteq> E\<close> \<open>?e \<in> F\<close> disj by(auto simp: inv_matching_def Int_commute disjnt_def pairwise_insert) show ?thesis using \<open>F \<subseteq> E\<close> vc' fC fe' m' by(auto simp add: invar_def Let_def) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma invar_step:
  assumes "F \<noteq> {}" "invar C F"
  shows "invar (C \<union> some F) (F - {e' \<in> F. some F \<inter> e' \<noteq> {}})"
proof -
  from assms have "F \<noteq> {}" "invar C F"
  then have "C \<union> some F \<subseteq> F"
  moreover have "F - {e' \<in> F. some F \<inter> e' \<noteq> {}} \<subseteq> F"
  ultimately have "invar (C \<union> some F) (F - {e' \<in> F. some F \<inter> e' \<noteq> {}})"
  by (rule invar_step)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 204 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 204 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy") was found
*** At command "<malformed>" (line 202 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:34 cpu time, factor 3.85
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (2%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma approx_vertex_cover:
"VARS C F
  {True}
  C := {};
  F := E;
  WHILE F \<noteq> {}
  INV {invar C F}
  DO C := C \<union> some F;
     F := F - {e' \<in> F. some F \<inter> e' \<noteq> {}}
  OD
  {vertex_cover E C \<and> (\<forall>C'. finite C' \<and> vertex_cover E C' \<longrightarrow> card C \<le> 2 * card C')}"</h2><br>
<b>Ground proof:</b> <br><pre><code></code></pre>
<b>Generated proof:</b><pre><code>```
by (induct C F arbitrary: E rule: while_rule)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 204 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 204 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy") was found
*** At command "<malformed>" (line 202 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:35 cpu time, factor 3.95
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (3%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma invar_step:
  assumes "F \<noteq> {}" "invar C F"
  shows "invar (C \<union> some F) (F - {e' \<in> F. some F \<inter> e' \<noteq> {}})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - from assms(2) obtain M where "F \<subseteq> E" and vc: "vertex_cover (E-F) C" and fC: "finite C"
    and m: "matching M" "M \<subseteq> E" and card: "card C \<le> 2 * card M"
    and disj: "\<forall>e \<in> M. \<forall>f \<in> F. e \<inter> f = {}" by (auto simp: invar_def inv_matching_def) let ?e = "SOME e. e \<in> F" have "?e \<in> F" using \<open>F \<noteq> {}\<close> by (simp add: some_in_eq) hence fe': "finite ?e" using \<open>F \<subseteq> E\<close> edges2 by(intro card_ge_0_finite) auto have "?e \<notin> M" using edges2 \<open>?e \<in> F\<close> disj \<open>F \<subseteq> E\<close> by fastforce have card': "card (C \<union> ?e) \<le> 2 * card (insert ?e M)" using \<open>?e \<in> F\<close> \<open>?e \<notin> M\<close> card_Un_le[of C ?e] \<open>F \<subseteq> E\<close> edges2 card finite_subset[OF m(2) finE] by fastforce let ?M = "M \<union> {?e}" have vc': "vertex_cover (E - (F - {e' \<in> F. ?e \<inter> e' \<noteq> {}})) (C \<union> ?e)" using vc by(auto simp: vertex_cover_def) have m': "inv_matching (C \<union> ?e) (F - {e' \<in> F. ?e \<inter> e' \<noteq> {}}) ?M" using m card' \<open>F \<subseteq> E\<close> \<open>?e \<in> F\<close> disj by(auto simp: inv_matching_def Int_commute disjnt_def pairwise_insert) show ?thesis using \<open>F \<subseteq> E\<close> vc' fC fe' m' by(auto simp add: invar_def Let_def) qed lemma approx_vertex_cover:
"VARS C F
  {True}
  C := {};
  F := E;
  WHILE F \<noteq> {}
  INV {invar C F}
  DO C := C \<union> some F;
     F := F - {e' \<in> F. some F \<inter> e' \<noteq> {}}
  OD
  {vertex_cover E C \<and> (\<forall>C'. finite C' \<and> vertex_cover E C' \<longrightarrow> card C \<le> 2 * card C')}" proof (vcg, goal_cases) case (1 C F) have "inv_matching {} E {}" by (auto simp add: inv_matching_def) with 1 show ?case by (auto simp add: invar_def vertex_cover_def) next case (2 C F) thus ?case using invar_step[of F C] by(auto simp: Let_def) next case (3 C F) then obtain M :: "'a set set" where
    post: "vertex_cover E C" "matching M" "M \<subseteq> E" "card C \<le> 2 * card M" by(auto simp: invar_def inv_matching_def) have opt: "card C \<le> 2 * card C'" if C': "finite C'" "vertex_cover E C'" for C' proof - note post(4) also have "2 * card M \<le> 2 * card C'" using card_matching_vertex_cover[OF C'(1) post(2,3) C'(2)] by simp finally show "card C \<le> 2 * card C'" . qed show ?case using post(1) opt by auto qed end (* locale Graph *) subsection "Version for Hypergraphs" text \<open>Almost the same. We assume that the degree of every edge is bounded.\<close> locale Bounded_Hypergraph =
  fixes E :: "'a set set"
  fixes k :: nat
  assumes finE: "finite E"
  assumes edge_bnd: "e \<in> E \<Longrightarrow> finite e \<and> card e \<le> k"
  assumes E1: "{} \<notin> E"
begin definition "inv_matching C F M =
  (matching M \<and> M \<subseteq> E \<and> card C \<le> k * card M \<and> (\<forall>e \<in> M. \<forall>f \<in> F. e \<inter> f = {}))" definition invar :: "'a set \<Rightarrow> 'a set set \<Rightarrow> bool" where
"invar C F = (F \<subseteq> E \<and> vertex_cover (E-F) C \<and> finite C \<and> (\<exists>M. inv_matching C F M))" lemma invar_step:
  assumes "F \<noteq> {}" "invar C F"
  shows "invar (C \<union> some F) (F - {e' \<in> F. some F \<inter> e' \<noteq> {}})" proof - from assms(2) obtain M where "F \<subseteq> E" and vc: "vertex_cover (E-F) C" and fC: "finite C"
    and m: "matching M" "M \<subseteq> E" and card: "card C \<le> k * card M"
    and disj: "\<forall>e \<in> M. \<forall>f \<in> F. e \<inter> f = {}" by (auto simp: invar_def inv_matching_def) let ?e = "SOME e. e \<in> F" have "?e \<in> F" using \<open>F \<noteq> {}\<close> by (simp add: some_in_eq) hence fe': "finite ?e" using \<open>F \<subseteq> E\<close> assms(2) edge_bnd by blast have "?e \<notin> M" using E1 \<open>?e \<in> F\<close> disj \<open>F \<subseteq> E\<close> by fastforce have card': "card (C \<union> ?e) \<le> k * card (insert ?e M)" using \<open>?e \<in> F\<close> \<open>?e \<notin> M\<close> card_Un_le[of C ?e] \<open>F \<subseteq> E\<close> edge_bnd card finite_subset[OF m(2) finE] by fastforce let ?M = "M \<union> {?e}" have vc': "vertex_cover (E - (F - {e' \<in> F. ?e \<inter> e' \<noteq> {}})) (C \<union> ?e)" using vc by(auto simp: vertex_cover_def) have m': "inv_matching (C \<union> ?e) (F - {e' \<in> F. ?e \<inter> e' \<noteq> {}}) ?M" using m card' \<open>F \<subseteq> E\<close> \<open>?e \<in> F\<close> disj by(auto simp: inv_matching_def Int_commute disjnt_def pairwise_insert) show ?thesis using \<open>F \<subseteq> E\<close> vc' fC fe' m' by(auto simp add: invar_def Let_def) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma invar_step:
  assumes "F \<noteq> {}" "invar C F"
  shows "invar (C \<union> some F) (F - {e' \<in> F. some F \<inter> e' \<noteq> {}})"
proof -
  from assms have "F \<noteq> {}" "invar C F"
  then have "C \<union> some F \<subseteq> F"
  moreover have "F - {e' \<in> F. some F \<inter> e' \<noteq> {}} \<subseteq> F"
  ultimately have "invar (C \<union> some F) (F - {e' \<in> F. some F \<inter> e' \<noteq> {}})"
  by (rule invar_step)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 204 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 204 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy") was found
*** At command "<malformed>" (line 202 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:35 cpu time, factor 3.84
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (4%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma approx_vertex_cover_bnd:
"VARS C F
  {True}
  C := {};
  F := E;
  WHILE F \<noteq> {}
  INV {invar C F}
  DO C := C \<union> some F;
     F := F - {e' \<in> F. some F \<inter> e' \<noteq> {}}
  OD
  {vertex_cover E C \<and> (\<forall>C'. finite C' \<and> vertex_cover E C' \<longrightarrow> card C \<le> k * card C')}"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (vcg, goal_cases) case (1 C F) have "inv_matching {} E {}" by (auto simp add: inv_matching_def) with 1 show ?case by (auto simp add: invar_def vertex_cover_def) next case (2 C F) thus ?case using invar_step[of F C] by(auto simp: Let_def) next case (3 C F) then obtain M :: "'a set set" where
    post: "vertex_cover E C" "matching M" "M \<subseteq> E" "card C \<le> k * card M" by(auto simp: invar_def inv_matching_def) have opt: "card C \<le> k * card C'" if C': "finite C'" "vertex_cover E C'" for C' proof - note post(4) also have "k * card M \<le> k * card C'" using card_matching_vertex_cover[OF C'(1) post(2,3) C'(2)] by simp finally show "card C \<le> k * card C'" . qed show ?case using post(1) opt by auto qed end (* locale Bounded_Hypergraph *) end</code></pre>
<b>Generated proof:</b><pre><code>```
lemma approx_vertex_cover_bnd:
  "VARS C F
    {True}
    C := {};
    F := E;
    WHILE F \<noteq> {}
    INV {invar C F}
    DO C := C \<union> some F;
       F := F - {e' \<in> F. some F \<inter> e' \<noteq> {}}
    OD
    {vertex_cover E C \<and> (\<forall>C'. finite C' \<and> vertex_cover E C' \<longrightarrow> card C \<le> k * card C')}"
  apply (rule_tac[WHILE_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_tac[INV_rule])
  apply (rule_</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Malformed command syntax
*** At command "<malformed>" (line 202 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_VC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:35 cpu time, factor 3.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (5%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/Approximation_Algorithms/_home_qj213_afp-2021-10-22_thys_Approximation_Algorithms_Approx_BP_Hoare_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma wrap_card:
  "card (wrap B) \<le> 1"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wrap_def by auto text \<open>If \<open>M\<close> and \<open>N\<close> are pairwise disjoint with \<open>V\<close> and not yet contained in V,
      then the union of \<open>M\<close> and \<open>N\<close> is also pairwise disjoint with \<open>V\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume card (wrap B) > 1
2. Then, there exists an element x in B such that x is not in wrap B
3. This implies that there exists an element y in B such that y is not in wrap B
4. Therefore, card (wrap B) = 1

QED

Proof:

1. Assume card (wrap B) > 1
2. Then, there exists an element x in B such that x is not in wrap B
3. This implies that there exists an element y in B such that y is not in wrap B
4. Therefore, card (wrap B) = 1

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 672 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but keyword : (line 672 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 671 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:24 cpu time, factor 3.27
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (6%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma pairwise_disjnt_Un:
  assumes "pairwise disjnt ({M} \<union> {N} \<union> V)" "M \<notin> V" "N \<notin> V"
  shows "pairwise disjnt ({M \<union> N} \<union> V)"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding pairwise_def by auto text \<open>A Bin Packing Problem is defined like in the article:\<close> locale BinPacking =
  fixes U :: "'a set" \<comment> \<open>A finite, non-empty set of objects\<close>
    and w :: "'a \<Rightarrow> real" \<comment> \<open>A mapping from objects to their respective weights (positive real numbers)\<close>
    and c :: nat \<comment> \<open>The maximum capacity of a bin (a natural number)\<close>
    and S :: "'a set" \<comment> \<open>The set of \<open>small\<close> objects (weight no larger than \<open>1/2\<close> of \<open>c\<close>)\<close>
    and L :: "'a set" \<comment> \<open>The set of \<open>large\<close> objects (weight larger than \<open>1/2\<close> of \<open>c\<close>)\<close>
  assumes weight: "\<forall>u \<in> U. 0 < w(u) \<and> w(u) \<le> c"
      and U_Finite: "finite U"
      and U_NE: "U \<noteq> {}"
      and S_def: "S = {u \<in> U. w(u) \<le> c / 2}"
      and L_def: "L = U - S"
begin text \<open>In the article, this is defined as \<open>w\<close> as well. However, to avoid ambiguity,
      we will abbreviate the weight of a bin as \<open>W\<close>.\<close> abbreviation W :: "'a set \<Rightarrow> real" where
  "W B \<equiv> (\<Sum>u \<in> B. w(u))" text \<open>\<open>P\<close> constitutes as a correct bin packing if \<open>P\<close> is a partition of \<open>U\<close>
      (as defined in @{thm [source] partition_on_def}) and the weights of
      the bins do not exceed their maximum capacity \<open>c\<close>.\<close> definition bp :: "'a set set \<Rightarrow> bool" where
  "bp P \<longleftrightarrow> partition_on U P \<and> (\<forall>B \<in> P. W(B) \<le> c)"</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume the given conditions:
   pairwise disjnt ({M} \<union> {N} \<union> V)
   M \<notin> V
   N \<notin> V

2. We need to show that pairwise disjnt ({M \<union> N} \<union> V)

3. By the definition of pairwise disjnt, we need to show that for any two distinct sets X and Y in {M \<union> N} \<union> V, X ∩ Y = {}

4. Consider two cases:
   - Case 1: X, Y ∈ {M \<union> N}
     - If X = M and Y = N, then X ∩ Y = {} by the given condition M \<notin> V and N \<notin> V
     - If X = M and Y ≠ N, then X ∩ Y = {} by the given condition pairwise disjnt ({M} \<union> {N} \<union> V)
     - If X ≠ M and Y = N, then X ∩ Y = {} by the given condition pairwise disjnt ({M} \<union> {N} \<union> V)
     - If X ≠ M and Y ≠ N, then X ∩ Y = {} by the given condition pairwise disjnt ({M} \<union> {N} \<union> V)

5. - Case 2: X ∈ {M \<union> N} and Y ∈ V
     - If X = M, then X ∩ Y = {} by the given condition M \<notin> V
     - If X = N, then X ∩ Y = {} by the given condition N \<notin> V
     - If X ≠ M and X ≠ N, then X ∩ Y = {} by the given condition pairwise disjnt ({M} \<union> {N} \<union> V)

6. By the above cases, we have shown that for any two distinct sets X and Y in {M \<union> N} \<union> V, X ∩ Y = {}

7. Therefore, pairwise disjnt ({M \<union> N} \<union> V)

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1121 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): keyword "is" expected,
*** but end-of-input (line 1121 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1121 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:24 cpu time, factor 3.35
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (7%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bpE:
  assumes "bp P"
  shows "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding bp_def partition_on_def by blast+</code></pre>
<b>Generated proof:</b><pre><code>```
lemma bpE:
  assumes "bp P"
  shows "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"
proof -
  have "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c" using assm by (auto simp: bp_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.33
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (8%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bpI:
  assumes "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"
  shows "bp P"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding bp_def partition_on_def by blast text \<open>Although we assume the \<open>S\<close> and \<open>L\<close> sets as given, manually obtaining them from \<open>U\<close> is trivial
      and can be achieved in linear time. Proposed by the article @{cite "BerghammerR03"}.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma bpI:
  assumes "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"
  shows "bp P"
proof -
  have "bp P"
  proof -
    have "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"
    proof -
      assume "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"
      then have "bp P" by (rule bpI)
    qed
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.45
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (9%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma S_L_set_generation:
"VARS S L W u
  {True}
  S := {}; L := {}; W := U;
  WHILE W \<noteq> {}
  INV {W \<subseteq> U \<and> S = {v \<in> U - W. w(v) \<le> c / 2} \<and> L = {v \<in> U - W. w(v) > c / 2}} DO
    u := (SOME u. u \<in> W);
    IF 2 * w(u) \<le> c
    THEN S := S \<union> {u}
    ELSE L := L \<union> {u} FI;
    W := W - {u}
  OD
  {S = {v \<in> U. w(v) \<le> c / 2} \<and> L = {v \<in> U. w(v) > c / 2}}"</h2><br>
<b>Ground proof:</b> <br><pre><code>by vcg (auto simp: some_in_eq) subsection \<open>The Proposed Approximation Algorithm\<close> subsubsection \<open>Functional Correctness\<close> text \<open>According to the article, \<open>inv\<^sub>1\<close> holds if \<open>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}\<close>
      is a correct solution for the bin packing problem @{cite BerghammerR03}. However, various
      assumptions made in the article seem to suggest that more information is demanded from this
      invariant and, indeed, mere correctness (as defined in @{thm [source] bp_def}) does not appear to suffice.
      To amend this, four additional conjuncts have been added to this invariant, whose necessity
      will be explained in the following proofs. It should be noted that there may be other (shorter) ways to amend this invariant.
      This approach, however, makes for rather straight-forward proofs, as these conjuncts can be utilized and proved in relatively few steps.\<close> definition inv\<^sub>1 :: "'a set set \<Rightarrow> 'a set set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<longleftrightarrow> bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) \<comment> \<open>A correct solution to the bin packing problem\<close>
                       \<and> \<Union>(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - V \<comment> \<open>The partial solution does not contain objects that have not yet been assigned\<close>
                       \<and> B\<^sub>1 \<notin> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) \<comment> \<open>\<open>B\<^sub>1\<close> is distinct from all the other bins\<close>
                       \<and> B\<^sub>2 \<notin> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2) \<comment> \<open>\<open>B\<^sub>2\<close> is distinct from all the other bins\<close>
                       \<and> (P\<^sub>1 \<union> wrap B\<^sub>1) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {} \<comment> \<open>The first and second partial solutions are disjoint from each other.\<close>" (*
lemma "partition_on U (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) \<Longrightarrow> u \<in> V \<Longrightarrow>
partition_on U (P\<^sub>1 \<union> wrap (insert u B\<^sub>1) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> (V-{u})})"
  nitpick*)</code></pre>
<b>Generated proof:</b><pre><code>```
by (induct W) (auto simp: S_L_set_generation)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (10%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1E:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
  shows "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})"
    and "\<Union>(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - V"
    and "B\<^sub>1 \<notin> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)"
    and "B\<^sub>2 \<notin> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2)"
    and "(P\<^sub>1 \<union> wrap B\<^sub>1) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>1_def by auto</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, hide_lams) inv_1E.inv_1E inv_1E.inv_2E inv_1E.inv_3E inv_1E.inv_4E inv_1E.inv_5E)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
*** At command "by" (line 107 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.29
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (11%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1I:
  assumes "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})"
    and "\<Union>(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - V"
    and "B\<^sub>1 \<notin> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)"
    and "B\<^sub>2 \<notin> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2)"
    and "(P\<^sub>1 \<union> wrap B\<^sub>1) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}"
  shows "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>1_def by blast</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, hide_lams) assms(1 2 3 4 5))
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (12%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wrap_Un [simp]: "wrap (M \<union> {x}) = {M \<union> {x}}"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wrap_def by simp</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume M is a set.
2. By definition of set union, we have M \<union> {x} = {y | y ∈ M ∨ y = x}.
3. Therefore, wrap (M \<union> {x}) = wrap {y | y ∈ M ∨ y = x}.
4. By definition of wrap, we have wrap {y | y ∈ M ∨ y = x} = {M \<union> {x}}.
5. Hence, wrap (M \<union> {x}) = {M \<union> {x}}.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but identifier Proof (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (13%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wrap_empty [simp]: "wrap {} = {}"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wrap_def by simp</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by (simp add: wrap_empty)
QED

This proof uses the `simp` tactic with the `add` option to include the `wrap_empty` theorem in the simplification process. The `QED` keyword signifies the end of the proof.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but identifier Proof (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (14%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wrap_not_empty [simp]: "M \<noteq> {} \<longleftrightarrow> wrap M = {M}"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wrap_def by simp text \<open>If \<open>inv\<^sub>1\<close> holds for the current partial solution, and the weight of an object \<open>u \<in> V\<close> added to \<open>B\<^sub>1\<close> does
      not exceed its capacity, then \<open>inv\<^sub>1\<close> also holds if \<open>B\<^sub>1\<close> and \<open>{u}\<close> are replaced by \<open>B\<^sub>1 \<union> {u}\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume M \<noteq> {}
2. By definition of wrap, we have wrap M = {M}
3. Therefore, M \<noteq> {} \<longleftrightarrow> wrap M = {M}

QED.

Proof:

1. Assume M \<noteq> {}
2. By definition of wrap, we have wrap M = {M}
3. Therefore, M \<noteq> {} \<longleftrightarrow> wrap M = {M}

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but identifier Proof (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.40
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (15%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1_stepA:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V" "W(B\<^sub>1) + w(u) \<le> c"
  shows "inv\<^sub>1 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>1E[OF assms(1)] and bprules = bpE[OF invrules(1)] text \<open>In the proof for \<open>Theorem 3.2\<close> of the article it is erroneously argued that
        if \<open>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}\<close> is a partition of \<open>U\<close>,
        then the same holds if \<open>B\<^sub>1\<close> is replaced by \<open>B\<^sub>1 \<union> {u}\<close>.
        This is, however, not necessarily the case if \<open>B\<^sub>1\<close> or \<open>{u}\<close> are already contained in the partial solution.
        Suppose \<open>P\<^sub>1\<close> contains the non-empty bin \<open>B\<^sub>1\<close>, then \<open>P\<^sub>1 \<union> wrap B\<^sub>1\<close> would still be pairwise disjoint, provided \<open>P\<^sub>1\<close> was pairwise disjoint before, as the union simply ignores the duplicate \<open>B\<^sub>1\<close>. Now, if the algorithm modifies \<open>B\<^sub>1\<close> by adding an element from \<open>V\<close> such that \<open>B\<^sub>1\<close> becomes some non-empty \<open>B\<^sub>1'\<close> with \<open>B\<^sub>1 \<inter> B\<^sub>1' \<noteq> \<emptyset>\<close> and \<open>B\<^sub>1' \<notin> P\<^sub>1\<close>, one can see that this property would no longer be preserved.
        To avoid such a situation, we will use the first additional conjunct in \<open>inv\<^sub>1\<close> to ensure that \<open>{u}\<close>
        is not yet contained in the partial solution, and the second additional conjunct to ensure that \<open>B\<^sub>1\<close>
        is not yet contained in the partial solution.\<close>

  \<comment> \<open>Rule 1: Pairwise Disjoint\<close> have NOTIN: "\<forall>M \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. u \<notin> M" using invrules(2) assms(2) by blast have "{{v} |v. v \<in> V} = {{u}} \<union> {{v} |v. v \<in> V - {u}}" using assms(2) by blast then have "pairwise disjnt (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> ({{u}} \<union> {{v} |v. v \<in> V - {u}}))" using bprules(1) assms(2) by simp then have "pairwise disjnt (wrap B\<^sub>1 \<union> {{u}} \<union> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}})" by (simp add: Un_commute) then have assm: "pairwise disjnt (wrap B\<^sub>1 \<union> {{u}} \<union> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by (simp add: Un_assoc) have "pairwise disjnt ({B\<^sub>1 \<union> {u}} \<union> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" proof (cases \<open>B\<^sub>1 = {}\<close>) case True with assm show ?thesis by simp next case False with assm have assm: "pairwise disjnt ({B\<^sub>1} \<union> {{u}} \<union> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by simp from NOTIN have "{u} \<notin> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}" by blast from pairwise_disjnt_Un[OF assm _ this] invrules(2,3) show ?thesis using False by auto qed then have 1: "pairwise disjnt (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}})" unfolding wrap_Un by simp

  \<comment> \<open>Rule 2: No empty sets\<close> from bprules(2) have 2: "{} \<notin> P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}" unfolding wrap_def by simp

  \<comment> \<open>Rule 3: Union preserved\<close> from bprules(3) have "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}}) = U" using assms(2) by blast then have 3: "\<Union> (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}) = U" unfolding wrap_def by force

  \<comment> \<open>Rule 4: Weights below capacity\<close> have "0 < w u" using weight assms(2) bprules(3) by blast have "finite B\<^sub>1" using bprules(3) U_Finite by (cases \<open>B\<^sub>1 = {}\<close>) auto then have "W (B\<^sub>1 \<union> {u}) \<le> W B\<^sub>1 + w u" using \<open>0 < w u\<close> by (cases \<open>u \<in> B\<^sub>1\<close>) (auto simp: insert_absorb) also have "... \<le> c" using assms(3) . finally have "W (B\<^sub>1 \<union> {u}) \<le> c" . then have "\<forall>B \<in> wrap (B\<^sub>1 \<union> {u}). W B \<le> c" unfolding wrap_Un by blast moreover have "\<forall>B\<in>P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" using bprules(4) by blast ultimately have 4: "\<forall>B\<in>P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" by blast from bpI[OF 1 2 3 4] have 1: "bp (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}})" .

  \<comment> \<open>Auxiliary information is preserved\<close> have "u \<in> U" using assms(2) bprules(3) by blast then have R: "U - (V - {u}) = U - V \<union> {u}" by blast have L: "\<Union> (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = \<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) \<union> {u}" unfolding wrap_def using NOTIN by auto have 2: "\<Union> (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - (V - {u})" unfolding L R invrules(2) .. have 3: "B\<^sub>1 \<union> {u} \<notin> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2" using NOTIN by auto have 4: "B\<^sub>2 \<notin> P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2" using invrules(4) NOTIN unfolding wrap_def by fastforce have 5: "(P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u})) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}" using invrules(5) NOTIN unfolding wrap_Un by auto from inv\<^sub>1I[OF 1 2 3 4 5] show ?thesis . qed text \<open>If \<open>inv\<^sub>1\<close> holds for the current partial solution, and the weight of an object \<open>u \<in> V\<close> added to \<open>B\<^sub>2\<close> does
      not exceed its capacity, then \<open>inv\<^sub>1\<close> also holds if \<open>B\<^sub>2\<close> and \<open>{u}\<close> are replaced by \<open>B\<^sub>2 \<union> {u}\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma inv_1_stepA:
  assumes "inv_1 P_1 P_2 B_1 B_2 V" "u ∈ V" "W(B_1) + w(u) ≤ c"
  shows "inv_1 P_1 P_2 (B_1 ∪ {u}) B_2 (V - {u})"
proof -
  from assms have "inv_1 P_1 P_2 B_1 B_2 V" by fact
  moreover have "u ∈ V" by fact
  moreover have "W(B_1) + w(u) ≤ c" by fact
  then have "inv_1 P_1 P_2 (B_1 ∪ {u}) B_2 (V - {u})"
    using inv_1_def by (auto simp: inv_1_def)
  finally show "inv_1 P_1 P_2 (B_1 ∪ {u}) B_2 (V - {u})" by blast
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (16%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1_stepB:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V" "W B\<^sub>2 + w u \<le> c"
  shows "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>1E[OF assms(1)] and bprules = bpE[OF invrules(1)] text \<open>The argumentation here is similar to the one in @{thm [source] inv\<^sub>1_stepA} with
      \<open>B\<^sub>1\<close> replaced with \<open>B\<^sub>2\<close> and using the first and third additional conjuncts of \<open>inv\<^sub>1\<close>
      to amend the issue, instead of the first and second.\<close>
  \<comment> \<open>Rule 1: Pairwise Disjoint\<close> have NOTIN: "\<forall>M \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. u \<notin> M" using invrules(2) assms(2) by blast have "{{v} |v. v \<in> V} = {{u}} \<union> {{v} |v. v \<in> V - {u}}" using assms(2) by blast then have "pairwise disjnt (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}})" using bprules(1) assms(2) by simp then have assm: "pairwise disjnt (wrap B\<^sub>2 \<union> {{u}} \<union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by (simp add: Un_assoc Un_commute) have "pairwise disjnt ({B\<^sub>2 \<union> {u}} \<union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" proof (cases \<open>B\<^sub>2 = {}\<close>) case True with assm show ?thesis by simp next case False with assm have assm: "pairwise disjnt ({B\<^sub>2} \<union> {{u}} \<union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by simp from NOTIN have "{u} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}" by blast from pairwise_disjnt_Un[OF assm _ this] invrules(2,4) show ?thesis using False by auto qed then have 1: "pairwise disjnt (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}})" unfolding wrap_Un by simp

  \<comment> \<open>Rule 2: No empty sets\<close> from bprules(2) have 2: "{} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}}" unfolding wrap_def by simp

  \<comment> \<open>Rule 3: Union preserved\<close> from bprules(3) have "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}}) = U" using assms(2) by blast then have 3: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}}) = U" unfolding wrap_def by force

  \<comment> \<open>Rule 4: Weights below capacity\<close> have "0 < w u" using weight assms(2) bprules(3) by blast have "finite B\<^sub>2" using bprules(3) U_Finite by (cases \<open>B\<^sub>2 = {}\<close>) auto then have "W (B\<^sub>2 \<union> {u}) \<le> W B\<^sub>2 + w u" using \<open>0 < w u\<close> by (cases \<open>u \<in> B\<^sub>2\<close>) (auto simp: insert_absorb) also have "... \<le> c" using assms(3) . finally have "W (B\<^sub>2 \<union> {u}) \<le> c" . then have "\<forall>B \<in> wrap (B\<^sub>2 \<union> {u}). W B \<le> c" unfolding wrap_Un by blast moreover have "\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" using bprules(4) by blast ultimately have 4: "\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" by auto from bpI[OF 1 2 3 4] have 1: "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}})" .

  \<comment> \<open>Auxiliary information is preserved\<close> have "u \<in> U" using assms(2) bprules(3) by blast then have R: "U - (V - {u}) = U - V \<union> {u}" by blast have L: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})) = \<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap B\<^sub>2) \<union> {u}" unfolding wrap_def using NOTIN by auto have 2: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})) = U - (V - {u})" unfolding L R using invrules(2) by simp have 3: "{} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})" using bpE(2)[OF 1] by simp have 4: "B\<^sub>2 \<union> {u} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2" using NOTIN by auto have 5: "(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}) \<inter> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})) = {}" using invrules(5) NOTIN unfolding wrap_empty wrap_Un by auto from inv\<^sub>1I[OF 1 2 3 4 5] show ?thesis . qed text \<open>If \<open>inv\<^sub>1\<close> holds for the current partial solution, then \<open>inv\<^sub>1\<close> also holds if \<open>B\<^sub>1\<close> and \<open>B\<^sub>2\<close> are
      added to \<open>P\<^sub>1\<close> and \<open>P\<^sub>2\<close> respectively, \<open>B\<^sub>1\<close> is emptied and \<open>B\<^sub>2\<close> initialized with \<open>u \<in> V\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv<sub>1</sub> P<sub>1</sub> P<sub>2</sub> B<sub>1</sub> B<sub>2</sub> V" "u ∈ V" "W B<sub>2</sub> + w u ≤ c"
  hence "inv<sub>1</sub> (P<sub>1</sub> ∪ wrap B<sub>1</sub>) P<sub>2</sub> {} (B<sub>2</sub> ∪ {u}) (V - {u})"
    using "inv<sub>1</sub> P<sub>1</sub> P<sub>2</sub> B<sub>1</sub> B<sub>2</sub> V" "u ∈ V" "W B<sub>2</sub> + w u ≤ c"
    by (auto simp: inv<sub>1</sub>_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.34
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (17%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1_stepC:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V"
  shows "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>1E[OF assms(1)]
  \<comment> \<open>Rule 1-4: Correct Bin Packing\<close> have "P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u} \<union> {{v} |v. v \<in> V - {u}}
      = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}}" by (metis (no_types, lifting) Un_assoc Un_empty_right insert_not_empty wrap_empty wrap_not_empty) also have "... = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}" using assms(2) by auto finally have EQ: "P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u} \<union> {{v} |v. v \<in> V - {u}}
                  = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}" . from invrules(1) have 1: "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u} \<union> {{v} |v. v \<in> V - {u}})" unfolding EQ .

  \<comment> \<open>Auxiliary information is preserved\<close> have NOTIN: "\<forall>M \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. u \<notin> M" using invrules(2) assms(2) by blast have "u \<in> U" using assms(2) bpE(3)[OF invrules(1)] by blast then have R: "U - (V - {u}) = U - V \<union> {u}" by blast have L: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u}) = \<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" unfolding wrap_def using NOTIN by auto have 2: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u}) = U - (V - {u})" unfolding L R using invrules(2) by auto have 3: "{} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u}" using bpE(2)[OF 1] by simp have 4: "{u} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2)" using NOTIN by auto have 5: "(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}) = {}" using invrules(5) NOTIN unfolding wrap_def by force from inv\<^sub>1I[OF 1 2 3 4 5] show ?thesis . qed text \<open>A simplified version of the bin packing algorithm proposed in the article.
      It serves as an introduction into the approach taken, and, while it does not provide the desired
      approximation factor, it does ensure that \<open>P\<close> is a correct solution of the bin packing problem.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv<sub>1</sub> P<sub>1</sub> P<sub>2</sub> B<sub>1</sub> B<sub>2</sub> V" "u ∈ V"
  then have "inv<sub>1</sub> (P<sub>1</sub> ∪ wrap B<sub>1</sub>) (P<sub>2</sub> ∪ wrap B<sub>2</sub>) {} {u} (V - {u})"
    using "inv<sub>1</sub> P<sub>1</sub> P<sub>2</sub> B<sub>1</sub> B<sub>2</sub> V" "u ∈ V"
    by (auto simp: inv<sub>1</sub>_stepC)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.45
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (18%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma simple_bp_correct:
"VARS P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u
  {True}
  P\<^sub>1 := {}; P\<^sub>2 := {}; B\<^sub>1 := {}; B\<^sub>2 := {}; V := U;
  WHILE V \<inter> S \<noteq> {} INV {inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V} DO
    u := (SOME u. u \<in> V); V := V - {u};
    IF W(B\<^sub>1) + w(u) \<le> c
    THEN B\<^sub>1 := B\<^sub>1 \<union> {u}
    ELSE IF W(B\<^sub>2) + w(u) \<le> c
         THEN B\<^sub>2 := B\<^sub>2 \<union> {u}
         ELSE P\<^sub>2 := P\<^sub>2 \<union> wrap B\<^sub>2; B\<^sub>2 := {u} FI;
         P\<^sub>1 := P\<^sub>1 \<union> wrap B\<^sub>1; B\<^sub>1 := {} FI
  OD;
  P := P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} | v. v \<in> V}
  {bp P}"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (vcg, goal_cases) case (1 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u) show ?case unfolding bp_def partition_on_def pairwise_def wrap_def inv\<^sub>1_def using weight by auto next case (2 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u) then have INV: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" .. from 2 have "V \<noteq> {}" by blast then have IN: "(SOME u. u \<in> V) \<in> V" by (simp add: some_in_eq) from inv\<^sub>1_stepA[OF INV IN] inv\<^sub>1_stepB[OF INV IN] inv\<^sub>1_stepC[OF INV IN] show ?case by blast next case (3 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u) then show ?case unfolding inv\<^sub>1_def by blast qed subsubsection \<open>Lower Bounds for the Bin Packing Problem\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (induct_tac "simple_bp_correct")
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.34
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (19%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bp_bins_finite [simp]:
  assumes "bp P"
  shows "\<forall>B \<in> P. finite B"</h2><br>
<b>Ground proof:</b> <br><pre><code>using bpE(3)[OF assms] U_Finite by (meson Sup_upper finite_subset)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis bp_finite)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.45
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (20%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bp_sol_finite [simp]:
  assumes "bp P"
  shows "finite P"</h2><br>
<b>Ground proof:</b> <br><pre><code>using bpE(3)[OF assms] U_Finite by (simp add: finite_UnionD) text \<open>If \<open>P\<close> is a solution of the bin packing problem, then no bin in \<open>P\<close> may contain more than
      one large object.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (rule finite_subset)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.54
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (21%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma only_one_L_per_bin:
  assumes "bp P" "B \<in> P"
  shows "\<forall>x \<in> B. \<forall>y \<in> B. x \<noteq> y \<longrightarrow> x \<notin> L \<or> y \<notin> L"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (rule ccontr, simp) assume "\<exists>x\<in>B. \<exists>y\<in>B. x \<noteq> y \<and> x \<in> L \<and> y \<in> L" then obtain x y where *: "x \<in> B" "y \<in> B" "x \<noteq> y" "x \<in> L" "y \<in> L" by blast then have "c < w x + w y" using L_def S_def by force have "finite B" using assms by simp have "y \<in> B - {x}" using *(2,3) by blast have "W B = W (B - {x}) + w x" using *(1) \<open>finite B\<close> by (simp add: sum.remove) also have "... = W (B - {x} - {y}) + w x + w y" using \<open>y \<in> B - {x}\<close> \<open>finite B\<close> by (simp add: sum.remove) finally have *: "W B = W (B - {x} - {y}) + w x + w y" . have "\<forall>u \<in> B. 0 < w u" using bpE(3)[OF assms(1)] assms(2) weight by blast then have "0 \<le> W (B - {x} - {y})" by (smt DiffD1 sum_nonneg) with * have "c < W B" using \<open>c < w x + w y\<close> by simp then show False using bpE(4)[OF assms(1)] assms(2) by fastforce qed text \<open>If \<open>P\<close> is a solution of the bin packing problem, then the amount of large objects
      is a lower bound for the amount of bins in P.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma only_one_L_per_bin:
  assumes "bp P" "B \<in> P"
  shows "\<forall>x \<in> B. \<forall>y \<in> B. x \<noteq> y \<longrightarrow> x \<notin> L \<or> y \<notin> L"
proof -
  fix x y :: 'a
  assume "x \<in> B" "y \<in> B" "x \<noteq> y"
  have "x \<notin> L \<or> y \<notin> L"
  using assms by (metis (no_types, hide_lams) bp_def)
  thus "\<forall>x \<in> B. \<forall>y \<in> B. x \<noteq> y \<longrightarrow> x \<notin> L \<or> y \<notin> L" by blast
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.40
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (22%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma L_lower_bound_card:
  assumes "bp P"
  shows "card L \<le> card P"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "\<forall>x \<in> L. \<exists>B \<in> P. x \<in> B" using bpE(3)[OF assms] L_def by blast then obtain f where f_def: "\<forall>u \<in> L. u \<in> f u \<and> f u \<in> P" by metis then have "inj_on f L" unfolding inj_on_def using only_one_L_per_bin[OF assms] by blast then have card_eq: "card L = card (f ` L)" by (simp add: card_image) have "f ` L \<subseteq> P" using f_def by blast moreover have "finite P" using assms by simp ultimately have "card (f ` L) \<le> card P" by (simp add: card_mono) then show ?thesis unfolding card_eq . qed text \<open>If \<open>P\<close> is a solution of the bin packing problem, then the amount of bins of a subset of P
      in which every bin contains a large object is a lower bound on the amount of large objects.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma L_lower_bound_card:
  assumes "bp P"
  shows "card L \<le> card P"
proof -
  from assms have "card L \<le> card P" by (rule bp)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.34
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (23%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma subset_bp_card:
  assumes "bp P" "M \<subseteq> P" "\<forall>B \<in> M. B \<inter> L \<noteq> {}"
  shows "card M \<le> card L"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "\<forall>B \<in> M. \<exists>u \<in> L. u \<in> B" using assms(3) by fast then have "\<exists>f. \<forall>B \<in> M. f B \<in> L \<and> f B \<in> B" by metis then obtain f where f_def: "\<forall>B \<in> M. f B \<in> L \<and> f B \<in> B" .. have "inj_on f M" proof (rule ccontr) assume "\<not> inj_on f M" then have "\<exists>x \<in> M. \<exists>y \<in> M. x \<noteq> y \<and> f x = f y" unfolding inj_on_def by blast then obtain x y where *: "x \<in> M" "y \<in> M" "x \<noteq> y" "f x = f y" by blast then have "\<exists>u. u \<in> x \<and> u \<in> y" using f_def by metis then have "x \<inter> y \<noteq> {}" by blast moreover have "pairwise disjnt M" using pairwise_subset[OF bpE(1)[OF assms(1)] assms(2)] . ultimately show False using * unfolding pairwise_def disjnt_def by simp qed moreover have "finite L" using L_def U_Finite by blast moreover have "f ` M \<subseteq> L" using f_def by blast ultimately show ?thesis using card_inj_on_le by blast qed text \<open>If \<open>P\<close> is a correct solution of the bin packing problem, \<open>inv\<^sub>1\<close> holds for the partial solution,
      and every bin in \<open>P\<^sub>1 \<union> wrap B\<^sub>1\<close> contains a large object, then the amount of bins in
      \<open>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}\<close> is a lower bound for the amount of bins in \<open>P\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma subset_bp_card:
  assumes "bp P" "M \<subseteq> P" "\<forall>B \<in> M. B \<inter> L \<noteq> {}"
  shows "card M \<le> card L"
proof -
  have "card M \<le> card (M \<inter> L)" by (rule subset_card)
  moreover have "card (M \<inter> L) \<le> card L" by (rule inter_card)
  ultimately show "card M \<le> card L" by (rule trans_le)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.29
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (24%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma L_bins_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "\<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}) \<le> card P"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>1E[OF assms(2)] have "\<forall>B \<in> {{v} |v. v \<in> V \<inter> L}. B \<inter> L \<noteq> {}" by blast with assms(3) have
    "P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L} \<subseteq> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}"
    "\<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}. B \<inter> L \<noteq> {}" by blast+ from subset_bp_card[OF invrules(1) this] show ?thesis using L_lower_bound_card[OF assms(1)] by linarith qed text \<open>If \<open>P\<close> is a correct solution of the bin packing problem, then the sum of the weights of the
      objects is equal to the sum of the weights of the bins in \<open>P\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma L_bins_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "\<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}) \<le> card P"
proof -
  have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}) \<le> card (P\<^sub>1 \<union> wrap B\<^sub>1)"
    using assms by (rule L_bins_lower_bound_card)
  moreover have "card (P\<^sub>1 \<union> wrap B\<^sub>1) \<le> card P"
    using assms by (rule L_bins_lower_bound_card)
  ultimately show "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}) \<le> card P"
    by (transitivity)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.35
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (25%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sum_Un_eq_sum_sum:
  assumes "bp P"
  shows "(\<Sum>u \<in> U. w u) = (\<Sum>B \<in> P. W B)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have FINITE: "\<forall>B \<in> P. finite B" using assms by simp have DISJNT: "\<forall>A \<in> P. \<forall>B \<in> P. A \<noteq> B \<longrightarrow> A \<inter> B = {}" using bpE(1)[OF assms] unfolding pairwise_def disjnt_def . have "(\<Sum>u \<in> (\<Union>P). w u) = (\<Sum>B \<in> P. W B)" using sum.Union_disjoint[OF FINITE DISJNT] by auto then show ?thesis unfolding bpE(3)[OF assms] . qed text \<open>If \<open>P\<close> is a correct solution of the bin packing problem, then the sum of the weights of the items
      is a lower bound of amount of bins in \<open>P\<close> multiplied by their maximum capacity.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma sum_Un_eq_sum_sum:
  assumes "bp P"
  shows "(\<Sum>u \<in> U. w u) = (\<Sum>B \<in> P. W B)"

proof -
  have "(\<Sum>u \<in> U. w u) = (\<Sum>B \<in> P. W B)" by (rule sum.cong)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (26%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sum_lower_bound_card:
  assumes "bp P"
  shows "(\<Sum>u \<in> U. w u) \<le> c * card P"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have *: "\<forall>B \<in> P. 0 < W B \<and> W B \<le> c" using bpE(2-4)[OF assms] weight by (metis UnionI assms bp_bins_finite sum_pos) have "(\<Sum>u \<in> U. w u) = (\<Sum>B \<in> P. W B)" using sum_Un_eq_sum_sum[OF assms] . also have "... \<le> (\<Sum>B \<in> P. c)" using sum_mono * by fastforce also have "... = c * card P" by simp finally show ?thesis . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma sum_lower_bound_card:
  assumes "bp P"
  shows "(\<Sum>u \<in> U. w u) \<le> c * card P"
proof -
  have "(\<Sum>u \<in> U. w u) = (\<Sum>u \<in> U. w u) + 0" by simp
  also have "(\<Sum>u \<in> U. w u) + 0 \<le> (\<Sum>u \<in> U. w u) + (\<Sum>u \<in> U. c)" by simp
  also have "(\<Sum>u \<in> U. w u) + (\<Sum>u \<in> U. c) \<le> (\<Sum>u \<in> U. w u + c)" by simp
  also have "(\<Sum>u \<in> U. w u + c) \<le> (\<Sum>u \<in> U. c * card P)" by simp
  finally show "(\<Sum>u \<in> U. w u) \<le> c * card P" by simp
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.45
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (27%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bp_NE:
  assumes "bp P"
  shows "P \<noteq> {}"</h2><br>
<b>Ground proof:</b> <br><pre><code>using U_NE bpE(3)[OF assms] by blast</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule bp_def)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.46
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (28%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sum_Un_ge:
  fixes f :: "_ \<Rightarrow> real"
  assumes "finite M" "finite N" "\<forall>B \<in> M \<union> N. 0 < f B"
  shows "sum f M \<le> sum f (M \<union> N)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "0 \<le> sum f N - sum f (M \<inter> N)" using assms by (smt DiffD1 inf.cobounded2 UnCI sum_mono2) then have "sum f M \<le> sum f M + sum f N - sum f (M \<inter> N)" by simp also have "... = sum f (M \<union> N)" using sum_Un[OF assms(1,2), symmetric] . finally show ?thesis . qed text \<open>If \<open>bij_exists\<close> holds, one can obtain a function which is bijective between the bins in \<open>P\<close>
and the objects in \<open>V\<close> such that an object returned by the function would cause the bin to
exceed its capacity.\<close> definition bij_exists :: "'a set set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "bij_exists P V = (\<exists>f. bij_betw f P V \<and> (\<forall>B \<in> P. W B + w (f B) > c))" text \<open>If \<open>P\<close> is a functionally correct solution of the bin packing problem, \<open>inv\<^sub>1\<close> holds for the
partial solution, and such a bijective function exists between the bins in \<open>P\<^sub>1\<close> and the objects in
@{term "P\<^sub>2 \<union> wrap B\<^sub>2"}, the following strict lower bound can be shown:\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "finite M" "finite N" "\<forall>B \<in> M \<union> N. 0 < f B"
  have "M \<union> N = M \<cup> N" by simp
  have "sum f (M \<union> N) = sum f (M \<cup> N)" by simp
  have "sum f (M \<cup> N) = sum f M + sum f N" by (simp add: sum.union)
  have "sum f M \<le> sum f (M \<cup> N)" by (simp add: sum.mono)
  thus "sum f M \<le> sum f (M \<union> N)" by simp
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (29%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma P\<^sub>1_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
  shows "card P\<^sub>1 + 1 \<le> card P"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (cases \<open>P\<^sub>1 = {}\<close>) case True have "finite P" using assms(1) by simp then have "1 \<le> card P" using bp_NE[OF assms(1)] by (metis Nat.add_0_right Suc_diff_1 Suc_le_mono card_gt_0_iff le0 mult_Suc_right nat_mult_1) then show ?thesis unfolding True by simp next note invrules = inv\<^sub>1E[OF assms(2)] case False obtain f where f_def: "bij_betw f P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))" "\<forall>B \<in> P\<^sub>1. W B + w (f B) > c" using assms(3) unfolding bij_exists_def by blast have FINITE: "finite P\<^sub>1" "finite (P\<^sub>2 \<union> wrap B\<^sub>2)" "finite (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)" "finite (wrap B\<^sub>1 \<union> {{v} |v. v \<in> V})" using inv\<^sub>1E(1)[OF assms(2)] bp_sol_finite by blast+ have F: "\<forall>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. finite B" using invrules(1) by simp have D: "\<forall>A \<in> P\<^sub>2 \<union> wrap B\<^sub>2. \<forall>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. A \<noteq> B \<longrightarrow> A \<inter> B = {}" using bpE(1)[OF invrules(1)] unfolding pairwise_def disjnt_def by auto have sum_eq: "W (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) = (\<Sum>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. W B)" using sum.Union_disjoint[OF F D] by auto have "\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}. 0 < W B" using bpE(2,3)[OF invrules(1)] weight by (metis (no_types, lifting) UnionI bp_bins_finite invrules(1) sum_pos) then have "(\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2. W B) \<le> (\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> (wrap B\<^sub>1 \<union> {{v} |v. v \<in> V}). W B)" using sum_Un_ge[OF FINITE(3,4), of W] by blast also have "... = (\<Sum>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}. W B)" by (smt Un_assoc Un_commute) also have "... = W U" using sum_Un_eq_sum_sum[OF invrules(1), symmetric] . finally have *: "(\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2. W B) \<le> W U" .

  \<comment> \<open>This follows from the fourth and final additional conjunct of \<open>inv\<^sub>1\<close> and is necessary to combine the sums of the bins
      of the two partial solutions. This does not inherently follow from the union being a correct solution,
      as this need not be the case if \<open>P\<^sub>1\<close> and \<open>P\<^sub>2 \<union> wrap B\<^sub>2\<close> happened to be equal.\<close> have DISJNT: "P\<^sub>1 \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}" using invrules(5) by blast

  \<comment> \<open>This part of the proof is based on the proof on page 72 of the article @{cite BerghammerR03}.\<close> have "c * card P\<^sub>1 = (\<Sum>B \<in> P\<^sub>1. c)" by simp also have "... < (\<Sum>B \<in> P\<^sub>1. W B + w (f B))" using f_def(2) sum_strict_mono[OF FINITE(1) False] by fastforce also have "... = (\<Sum>B \<in> P\<^sub>1. W B) + (\<Sum>B \<in> P\<^sub>1. w (f B))" by (simp add: Groups_Big.comm_monoid_add_class.sum.distrib) also have "... = (\<Sum>B \<in> P\<^sub>1. W B) + W (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" unfolding sum.reindex_bij_betw[OF f_def(1), of w] .. also have "... = (\<Sum>B \<in> P\<^sub>1. W B) + (\<Sum>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. W B)" unfolding sum_eq .. also have "... = (\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2. W B)" using sum.union_disjoint[OF FINITE(1,2) DISJNT, of W] by (simp add: Un_assoc) also have "... \<le> (\<Sum>u \<in> U. w u)" using * . also have "... \<le> c * card P" using sum_lower_bound_card[OF assms(1)] . finally show ?thesis by (meson discrete nat_mult_less_cancel_disj of_nat_less_imp_less) qed text \<open>As @{thm wrap_card} holds, it follows that the amount of bins in \<open>P\<^sub>1 \<union> wrap B\<^sub>1\<close>
      are a lower bound for the amount of bins in \<open>P\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "bp P" "inv1 P1 P2 B1 B2 V" "bij_exists P1 (Union>(P2 union wrap B2))"
  then have "card P1 + 1 <= card P"
  using card_mono [OF card_P1_le_card_P]
  by auto
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.54
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (30%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma P\<^sub>1_B\<^sub>1_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1) \<le> card P"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "card (P\<^sub>1 \<union> wrap B\<^sub>1) \<le> card P\<^sub>1 + card (wrap B\<^sub>1)" using card_Un_le by blast also have "... \<le> card P\<^sub>1 + 1" using wrap_card by simp also have "... \<le> card P" using P\<^sub>1_lower_bound_card[OF assms] . finally show ?thesis . qed text \<open>If \<open>inv\<^sub>1\<close> holds, there are at most half as many bins in \<open>P\<^sub>2\<close> as there are objects in \<open>P\<^sub>2\<close>, and we can again
      obtain a bijective function between the bins in \<open>P\<^sub>1\<close> and the objects of the second partial solution,
      then the amount of bins in the second partial solution are a strict lower bound for half the bins of
      the first partial solution.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma P1_B1_lower_bound_card:
  assumes "bp P" "inv1 P1 P2 B1 B2 V" "bij_exists P1 (Union>(P2 union wrap B2))"
  shows "card (P1 union wrap B1) <= card P"
proof -
  have "card (P1 union wrap B1) <= card (P1 union wrap B2)" by (rule card_mono)
  also have "card (P1 union wrap B2) <= card (P1 union wrap (B2 union B1))" by (rule card_mono)
  also have "card (P1 union wrap (B2 union B1)) = card (P1 union wrap B1)" by (rule card_cong)
  finally show "card (P1 union wrap B1) <= card P" by (rule card_mono)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.35
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (31%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma P\<^sub>2_B\<^sub>2_lower_bound_P\<^sub>1:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)" "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
  shows "2 * card (P\<^sub>2 \<union> wrap B\<^sub>2) \<le> card P\<^sub>1 + 1"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>1E[OF assms(1)] and bprules = bpE[OF invrules(1)] have "pairwise disjnt (P\<^sub>2 \<union> wrap B\<^sub>2)" using bprules(1) pairwise_subset by blast moreover have "B\<^sub>2 \<notin> P\<^sub>2" using invrules(4) by simp ultimately have DISJNT: "\<Union>P\<^sub>2 \<inter> B\<^sub>2 = {}" by (auto, metis (no_types, hide_lams) sup_bot.right_neutral Un_insert_right disjnt_iff mk_disjoint_insert pairwise_insert wrap_Un) have "finite (\<Union>P\<^sub>2)" using U_Finite bprules(3) by auto have "finite B\<^sub>2" using bp_bins_finite[OF invrules(1)] wrap_not_empty by blast have "finite P\<^sub>2" "finite (wrap B\<^sub>2)" using bp_sol_finite[OF invrules(1)] by blast+ have DISJNT2: "P\<^sub>2 \<inter> wrap B\<^sub>2 = {}" unfolding wrap_def using \<open>B\<^sub>2 \<notin> P\<^sub>2\<close> by auto have "card (wrap B\<^sub>2) \<le> card B\<^sub>2" proof (cases \<open>B\<^sub>2 = {}\<close>) case False then have "1 \<le> card B\<^sub>2" by (simp add: leI \<open>finite B\<^sub>2\<close>) then show ?thesis using wrap_card[of B\<^sub>2] by linarith qed simp

  \<comment> \<open>This part of the proof is based on the proof on page 73 of the article @{cite BerghammerR03}.\<close> from assms(2) have "2 * card P\<^sub>2 + 2 * card (wrap B\<^sub>2) \<le> card (\<Union>P\<^sub>2) + card (wrap B\<^sub>2) + 1" using wrap_card[of B\<^sub>2] by linarith then have "2 * (card P\<^sub>2 + card (wrap B\<^sub>2)) \<le> card (\<Union>P\<^sub>2) + card B\<^sub>2 + 1" using \<open>card (wrap B\<^sub>2) \<le> card B\<^sub>2\<close> by simp then have "2 * (card (P\<^sub>2 \<union> wrap B\<^sub>2)) \<le> card (\<Union>P\<^sub>2 \<union> B\<^sub>2) + 1" using card_Un_disjoint[OF \<open>finite (\<Union>P\<^sub>2)\<close> \<open>finite B\<^sub>2\<close> DISJNT]
      and card_Un_disjoint[OF \<open>finite P\<^sub>2\<close> \<open>finite (wrap B\<^sub>2)\<close> DISJNT2] by argo then have "2 * (card (P\<^sub>2 \<union> wrap B\<^sub>2)) \<le> card (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2)) + 1" by (cases \<open>B\<^sub>2 = {}\<close>) (auto simp: Un_commute) then show "2 * (card (P\<^sub>2 \<union> wrap B\<^sub>2)) \<le> card P\<^sub>1 + 1" using assms(3) bij_betw_same_card unfolding bij_exists_def by metis qed subsubsection \<open>Proving the Approximation Factor\<close> text \<open>We define \<open>inv\<^sub>2\<close> as it is defined in the article.
      These conjuncts allow us to prove the desired approximation factor.\<close> definition inv\<^sub>2 :: "'a set set \<Rightarrow> 'a set set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<longleftrightarrow> inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<comment> \<open>\<open>inv\<^sub>1\<close> holds for the partial solution\<close>
                       \<and> (V \<inter> L \<noteq> {} \<longrightarrow> (\<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {})) \<comment> \<open>If there are still large objects left, then every bin of the first partial solution must contain a large object\<close>
                       \<and> bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2)) \<comment> \<open>There exists a bijective function between the bins of the first partial solution and the objects of the second one\<close>
                       \<and> (2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)) \<comment> \<open>There are at most twice as many bins in \<open>P\<^sub>2\<close> as there are objects in \<open>P\<^sub>2\<close>\<close>"</code></pre>
<b>Generated proof:</b><pre><code>```
lemma P2_B2_lower_bound_P1:
  assumes "inv1 P1 P2 B1 B2 V" "2 * card P2 <= card (Union P2)" "bij_exists P1 (Union(P2 union wrap B2))"
  shows "2 * card (P2 union wrap B2) <= card P1 + 1"
proof -
  have "card (P2 union wrap B2) <= card P1 + 1"
  proof -
    have "card (P2 union wrap B2) <= card P1 + card (wrap B2)"
    proof -
      have "card (wrap B2) <= card B2"
      proof -
        have "card (wrap B2) = card B2"
        proof -
          have "bij_exists P1 (Union(P2 union wrap B2))"
          proof -
            have "bij_exists P1 (Union(P2 union wrap B2))"
          qed
        qed
      qed
    qed
    hence "card (P2 union wrap B2) <= card P1 + card (wrap B2)"
    qed
  qed
  hence "2 * card (P2 union wrap B2) <= 2 * card P1 + 2 * card (wrap B2)"
  proof -
    have "2 * card (P2 union wrap B2) <= 2 * card P1 + 2 * card (wrap B2)"
    proof -
      have "2 * card (P2 union wrap B2) <= 2 * card P1 + 2 * card (wrap B2)"
    qed
  qed
  hence "2 * card (P2 union wrap B2) <= card P1 + 1"
  proof -
    have "2 * card (P2 union wrap B2) <= card P1 + 1"
    proof -
      have "2 * card (P2 union wrap B2) <= card P1 + 1"
    qed
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.38
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (32%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>2E:
  assumes "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
  shows "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
    and "V \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}"
    and "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
    and "2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>2_def by blast+</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, hide_lams) bij_surj_def bij_surj_exists bij_surj_image card_image_eq card_image_le card_le_mono card_mono card_mono_le card_mono_le_mono card_mono_mono card_mono_mono_le card_mono_mono_mono card_mono_mono_mono_le card_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_le card_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_mono_</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (33%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>2I:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
    and "V \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}"
    and "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
    and "2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)"
  shows "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>2_def by blast text \<open>If \<open>P\<close> is a correct solution of the bin packing problem, \<open>inv\<^sub>2\<close> holds for the partial solution,
      and there are no more small objects left to be distributed, then the amount of bins of the partial solution
      is no larger than \<open>3 / 2\<close> of the amount of bins in \<open>P\<close>. This proof strongly follows the proof in
      \<open>Theorem 4.1\<close> of the article @{cite BerghammerR03}.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume the given conditions:
   - inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V
   - V \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}
   - bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))
   - 2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)

2. Use the first assumption to establish the existence of an inverse function for P\<^sub>1 and P\<^sub>2.

3. Use the second assumption to show that the intersection of V and L is non-empty.

4. Use the third assumption to show that there exists a bijection between P\<^sub>1 and the union of P\<^sub>2 and wrap B\<^sub>2.

5. Use the fourth assumption to show that the cardinality of P\<^sub>2 is at most half of the cardinality of the union of P\<^sub>2.

6. Combine the results from steps 2-5 to conclude that inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V holds.

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but identifier Proof (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.42
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (34%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bin_packing_lower_bound_card:
  assumes "V \<inter> S = {}" "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "bp P"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) \<le> 3 / 2 * card P"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (cases \<open>V = {}\<close>) note invrules = inv\<^sub>2E[OF assms(2)] case True then have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})
           = card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)" by simp also have "... \<le> card (P\<^sub>1 \<union> wrap B\<^sub>1) + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using card_Un_le[of \<open>P\<^sub>1 \<union> wrap B\<^sub>1\<close>] by (simp add: Un_assoc) also have "... \<le> card P + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using P\<^sub>1_B\<^sub>1_lower_bound_card[OF assms(3) invrules(1,3)] by simp also have "... \<le> card P + card P / 2" using P\<^sub>2_B\<^sub>2_lower_bound_P\<^sub>1[OF invrules(1,4,3)]
      and P\<^sub>1_lower_bound_card[OF assms(3) invrules(1,3)] by linarith finally show ?thesis by linarith next note invrules = inv\<^sub>2E[OF assms(2)] case False have "U = S \<union> L" using S_def L_def by blast then have *: "V = V \<inter> L" using bpE(3)[OF inv\<^sub>1E(1)[OF invrules(1)]]
      and assms(1) by blast with False have NE: "V \<inter> L \<noteq> {}" by simp have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})
      = card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L} \<union> P\<^sub>2 \<union> wrap B\<^sub>2)" using * by (simp add: Un_commute Un_assoc) also have "... \<le> card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}) + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using card_Un_le[of \<open>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}\<close>] by (simp add: Un_assoc) also have "... \<le> card P + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using L_bins_lower_bound_card[OF assms(3) invrules(1) invrules(2)[OF NE]] by linarith also have "... \<le> card P + card P / 2" using P\<^sub>2_B\<^sub>2_lower_bound_P\<^sub>1[OF invrules(1,4,3)]
      and P\<^sub>1_lower_bound_card[OF assms(3) invrules(1,3)] by linarith finally show ?thesis by linarith qed text \<open>We define \<open>inv\<^sub>3\<close> as it is defined in the article.
      This final conjunct allows us to prove that the invariant will be maintained by the algorithm.\<close> definition inv\<^sub>3 :: "'a set set \<Rightarrow> 'a set set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<longleftrightarrow> inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<and> B\<^sub>2 \<subseteq> S"</code></pre>
<b>Generated proof:</b><pre><code>```
lemma bin_packing_lower_bound_card:
  assumes "V \<inter> S = {}" "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "bp P"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) \<le> 3 / 2 * card P"
proof -
  have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) = card (P\<^sub>1 \<union> P\<^sub>2) + card (wrap B\<^sub>1 \<union> wrap B\<^sub>2) + card {{v} |v. v \<in> V}"
    by (simp add: card_union)
  also have "card (wrap B\<^sub>1 \<union> wrap B\<^sub>2) = card B\<^sub>1 + card B\<^sub>2"
    by (simp add: card_wrap)
  moreover have "card {{v} |v. v \<in> V} = card V"
    by (simp add: card_set)
  ultimately have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) = card (P\<^sub>1 \<union> P\<^sub>2) + card B\<^sub>1 + card B\<^sub>2 + card V"
    by (simp add: card_union)
  hence "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) \<le> 3 / 2 * card P"
    by (simp add: card_P)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.36
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (35%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>3E:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
  shows "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" and "B\<^sub>2 \<subseteq> S"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>3_def by blast+</code></pre>
<b>Generated proof:</b><pre><code>```
lemma inv_3E:
  assumes "inv_3 P_1 P_2 B_1 B_2 V"
  shows "inv_2 P_1 P_2 B_1 B_2 V" and "B_2 ⊆ S"
proof -
  have "inv_2 P_1 P_2 B_1 B_2 V" and "B_2 ⊆ S" using assm by (auto simp: inv_3_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (36%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>3I:
  assumes "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" and "B\<^sub>2 \<subseteq> S"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>3_def by blast</code></pre>
<b>Generated proof:</b><pre><code>```
lemma inv_3I:
  assumes "inv_2 P_1 P_2 B_1 B_2 V" and "B_2 ⊆ S"
  shows "inv_3 P_1 P_2 B_1 B_2 V"
proof -
  from assms have "inv_2 P_1 P_2 B_1 B_2 V" and "B_2 ⊆ S" by auto
  moreover have "B_2 ⊆ S" by auto
  then have "inv_3 P_1 P_2 B_1 B_2 V" by auto
  thus "inv_3 P_1 P_2 B_1 B_2 V" by auto
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.49
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (37%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_init:
  "inv\<^sub>3 {} {} {} {} U"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have *: "inv\<^sub>1 {} {} {} {} U" unfolding bp_def partition_on_def pairwise_def wrap_def inv\<^sub>1_def using weight by auto have "bij_exists {} (\<Union> ({} \<union> wrap {}))" using bij_betwI' unfolding bij_exists_def by fastforce from inv\<^sub>2I[OF * _ this] have "inv\<^sub>2 {} {} {} {} U" by auto from inv\<^sub>3I[OF this] show ?thesis by blast qed text \<open>If \<open>B\<^sub>1\<close> is empty and there are no large objects left, then \<open>inv\<^sub>3\<close> will be maintained
      if \<open>B\<^sub>1\<close> is initialized with \<open>u \<in> V \<inter> S\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (rule loop_init)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.50
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (38%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_stepA:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 = {}" "V \<inter> L = {}" "u \<in> V \<inter> S"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] have WEIGHT: "W B\<^sub>1 + w u \<le> c" using S_def assms(2,4) by simp from assms(4) have "u \<in> V" by blast from inv\<^sub>1_stepA[OF invrules(1) this WEIGHT] assms(2) have 1: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" by simp have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap {u}. B \<inter> L \<noteq> {}" using assms(3) by blast from inv\<^sub>2I[OF 1 2] invrules have "inv\<^sub>2 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] . qed text \<open>If \<open>B\<^sub>1\<close> is empty and there are large objects left, then \<open>inv\<^sub>3\<close> will be maintained
      if \<open>B\<^sub>1\<close> is initialized with \<open>u \<in> V \<inter> L\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv<^sub>3 P<^sub>1 P<^sub>2 B<^sub>1 B<^sub>2 V" "B<^sub>1 = {}" "V ∩ L = {}" "u ∈ V ∩ S"
  hence "inv<^sub>3 P<^sub>1 P<^sub>2 {u} B<^sub>2 (V - {u})"
    using "B<^sub>1 = {}" "V ∩ L = {}" "u ∈ V ∩ S"
    by (auto simp: inv<^sub>3_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.35
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (39%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_stepB:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 = {}" "u \<in> V \<inter> L"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] have WEIGHT: "W B\<^sub>1 + w u \<le> c" using L_def weight assms(2,3) by simp from assms(3) have "u \<in> V" by blast from inv\<^sub>1_stepA[OF invrules(1) this WEIGHT] assms(2) have 1: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" by simp have "\<forall>B\<in>P\<^sub>1. B \<inter> L \<noteq> {}" using assms(3) invrules(2) by blast then have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap {u}. B \<inter> L \<noteq> {}" using assms(3) by (metis Int_iff UnE empty_iff insertE singletonI wrap_not_empty) from inv\<^sub>2I[OF 1 2] invrules have "inv\<^sub>2 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] . qed text \<open>If \<open>B\<^sub>1\<close> is not empty and \<open>u \<in> V \<inter> S\<close> does not exceed its maximum capacity, then \<open>inv\<^sub>3\<close>
      will be maintained if \<open>B\<^sub>1\<close> and \<open>{u}\<close> are replaced with \<open>B\<^sub>1 \<union> {u}\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv<^sub>3 P<^sub>1 P<^sub>2 B<^sub>1 B<^sub>2 V" "B<^sub>1 = {}" "u ∈ V ∩ L"
  hence "inv<^sub>3 P<^sub>1 P<^sub>2 {u} B<^sub>2 (V - {u})"
    using "B<^sub>1 = {}" "u ∈ V ∩ L"
    by (auto simp: inv<^sub>3_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
*** At command "by" (line 107 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.33
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (40%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_stepC:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 \<noteq> {}" "u \<in> V \<inter> S" "W B\<^sub>1 + w(u) \<le> c"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] from assms(3) have "u \<in> V" by blast from inv\<^sub>1_stepA[OF invrules(1) this assms(4)] have 1: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})" . have "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}" using invrules(2) by blast then have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}). B \<inter> L \<noteq> {}" by (metis Int_commute Un_empty_right Un_insert_right assms(2) disjoint_insert(2) insert_iff wrap_not_empty) from inv\<^sub>2I[OF 1 2] invrules have "inv\<^sub>2 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})" by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] . qed text \<open>If \<open>B\<^sub>1\<close> is not empty and \<open>u \<in> V \<inter> S\<close> does exceed its maximum capacity but not the capacity of \<open>B\<^sub>2\<close>,
      then \<open>inv\<^sub>3\<close> will be maintained if \<open>B\<^sub>1\<close> is added to \<open>P\<^sub>1\<close> and emptied, and \<open>B\<^sub>2\<close> and \<open>{u}\<close> are replaced with \<open>B\<^sub>2 \<union> {u}\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv<^sub>3 P<^sub>1 P<^sub>2 B<^sub>1 B<^sub>2 V" "B<^sub>1 ≠ {}" "u ∈ V ∩ S" "W B<^sub>1 + w(u) ≤ c"
  hence "B<^sub>1 ∪ {u} ⊆ V" by (simp add: assms(1))
  hence "B<^sub>1 ∪ {u} ≠ {}" by (simp add: assms(2))
  hence "inv<^sub>3 P<^sub>1 P<^sub>2 (B<^sub>1 ∪ {u}) B<^sub>2 (V - {u})" by (simp add: assms(1))
  moreover
  have "B<^sub>2 ∩ (V - {u}) = B<^sub>2" by (simp add: assms(1))
  hence "inv<^sub>3 P<^sub>1 P<^sub>2 (B<^sub>1 ∪ {u}) B<^sub>2 (V - {u})" by (simp add: assms(1))
  ultimately show "inv<^sub>3 P<^sub>1 P<^sub>2 (B<^sub>1 ∪ {u}) B<^sub>2 (V - {u})" by (simp add: assms(1))
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.41
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (41%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_stepD:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 \<noteq> {}" "u \<in> V \<inter> S" "W B\<^sub>1 + w(u) > c" "W B\<^sub>2 + w(u) \<le> c"
  shows "inv\<^sub>3 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] from assms(3) have "u \<in> V" by blast from inv\<^sub>1_stepB[OF invrules(1) this assms(5)] have 1: "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})" . have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}. B \<inter> L \<noteq> {}" using invrules(2) unfolding wrap_empty by blast from invrules(3) obtain f where f_def: "bij_betw f P\<^sub>1 (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" "\<forall>B\<in>P\<^sub>1. c < W B + w (f B)" unfolding bij_exists_def by blast have "B\<^sub>1 \<notin> P\<^sub>1" using inv\<^sub>1E(3)[OF invrules(1)] by blast have "u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" using inv\<^sub>1E(2)[OF invrules(1)] assms(3) by blast then have "(\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}))) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}}))" by (metis Sup_empty Un_assoc Union_Un_distrib ccpo_Sup_singleton wrap_empty wrap_not_empty) also have "... = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" by simp finally have UN: "(\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}))) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" . have "wrap B\<^sub>1 = {B\<^sub>1}" using wrap_not_empty[of B\<^sub>1] assms(2) by simp let ?f = "f (B\<^sub>1 := u)" have BIJ: "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})))" unfolding wrap_empty \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> UN using f_def(1) \<open>B\<^sub>1 \<notin> P\<^sub>1\<close> \<open>u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))\<close> by (metis (no_types, lifting) bij_betw_cong fun_upd_other fun_upd_same notIn_Un_bij_betw3) have "c < W B\<^sub>1 + w (?f B\<^sub>1)" using assms(4) by simp then have "(\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" unfolding \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> using f_def(2) by simp with BIJ have "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})))
              \<and> (\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" by blast then have 3: "bij_exists (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})))" unfolding bij_exists_def by blast from inv\<^sub>2I[OF 1 2 3] have "inv\<^sub>2 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})" using invrules(4) by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] assms(3) by blast qed text \<open>If the maximum capacity of \<open>B\<^sub>2\<close> is exceeded by \<open>u \<in> V \<inter> S\<close>,
      then \<open>B\<^sub>2\<close> must contain at least two objects.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv<^sub>3 P<^sub>1 P<^sub>2 B<^sub>1 B<^sub>2 V" "B<^sub>1 ≠ {}" "u ∈ V ∩ S" "W B<^sub>1 + w(u) > c" "W B<^sub>2 + w(u) ≤ c"
  hence "inv<^sub>3 (P<^sub>1 ∪ wrap B<^sub>1) P<^sub>2 {} (B<^sub>2 ∪ {u}) (V - {u})"
    using "B<^sub>1 ≠ {}" "u ∈ V ∩ S" "W B<^sub>1 + w(u) > c" "W B<^sub>2 + w(u) ≤ c"
    by (auto simp: inv<^sub>3_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** exception Option raised (line 84 of "General/basics.ML")
*** At command "by" (line 283 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.40
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (42%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma B\<^sub>2_at_least_two_objects:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V \<inter> S" "W B\<^sub>2 + w(u) > c"
  shows "2 \<le> card B\<^sub>2"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (rule ccontr, simp add: not_le) have FINITE: "finite B\<^sub>2" using inv\<^sub>1E(1)[OF inv\<^sub>2E(1)[OF inv\<^sub>3E(1)[OF assms(1)]]] by (metis (no_types, lifting) Finite_Set.finite.simps U_Finite Union_Un_distrib bpE(3) ccpo_Sup_singleton finite_Un wrap_not_empty) assume "card B\<^sub>2 < 2" then consider (0) "card B\<^sub>2 = 0" | (1) "card B\<^sub>2 = 1" by linarith then show False proof cases case 0 then have "B\<^sub>2 = {}" using FINITE by simp then show ?thesis using assms(2,3) S_def by simp next case 1 then obtain v where "B\<^sub>2 = {v}" using card_1_singletonE by auto with inv\<^sub>3E(2)[OF assms(1)] have "2 * w v \<le> c" using S_def by simp moreover from \<open>B\<^sub>2 = {v}\<close> have "W B\<^sub>2 = w v" by simp ultimately show ?thesis using assms(2,3) S_def by simp qed qed text \<open>If \<open>B\<^sub>1\<close> is not empty and \<open>u \<in> V \<inter> S\<close> exceeds the maximum capacity of both \<open>B\<^sub>1\<close> and \<open>B\<^sub>2\<close>,
      then \<open>inv\<^sub>3\<close> will be maintained if \<open>B\<^sub>1\<close> and \<open>B\<^sub>2\<close> are added to \<open>P\<^sub>1\<close> and \<open>P\<^sub>2\<close> respectively,
      emptied, and \<open>B\<^sub>2\<close> initialized with \<open>u\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma B2_at_least_two_objects:
  assumes "inv3 P1 P2 B1 B2 V" "u ∈ V ∩ S" "W B2 + w(u) > c"
  shows "2 ≤ card B2"
proof -
  from assms have "W B2 + w(u) > c" by (rule assms)
  moreover have "u ∈ V ∩ S" by (rule assms)
  ultimately have "2 ≤ card B2" by (rule inv3)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.32
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (43%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_stepE:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 \<noteq> {}" "u \<in> V \<inter> S" "W B\<^sub>1 + w(u) > c" "W B\<^sub>2 + w(u) > c"
  shows "inv\<^sub>3 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] from assms(3) have "u \<in> V" by blast from inv\<^sub>1_stepC[OF invrules(1) this] have 1: "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})" . have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}. B \<inter> L \<noteq> {}" using invrules(2) unfolding wrap_empty by blast from invrules(3) obtain f where f_def: "bij_betw f P\<^sub>1 (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" "\<forall>B\<in>P\<^sub>1. c < W B + w (f B)" unfolding bij_exists_def by blast have "B\<^sub>1 \<notin> P\<^sub>1" using inv\<^sub>1E(3)[OF invrules(1)] by blast have "u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" using inv\<^sub>1E(2)[OF invrules(1)] assms(3) by blast have "(\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u})) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}}))" unfolding wrap_def by simp also have "... = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" by simp finally have UN: "(\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u})) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" . have "wrap B\<^sub>1 = {B\<^sub>1}" using wrap_not_empty[of B\<^sub>1] assms(2) by simp let ?f = "f (B\<^sub>1 := u)" have BIJ: "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}))" unfolding wrap_empty \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> UN using f_def(1) \<open>B\<^sub>1 \<notin> P\<^sub>1\<close> \<open>u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))\<close> by (metis (no_types, lifting) bij_betw_cong fun_upd_other fun_upd_same notIn_Un_bij_betw3) have "c < W B\<^sub>1 + w (?f B\<^sub>1)" using assms(4) by simp then have "(\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" unfolding \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> using f_def(2) by simp with BIJ have "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}))
              \<and> (\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" by blast then have 3: "bij_exists (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}))" unfolding bij_exists_def by blast have 4: "2 * card (P\<^sub>2 \<union> wrap B\<^sub>2) \<le> card (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" proof - note bprules = bpE[OF inv\<^sub>1E(1)[OF invrules(1)]] have "pairwise disjnt (P\<^sub>2 \<union> wrap B\<^sub>2)" using bprules(1) pairwise_subset by blast moreover have "B\<^sub>2 \<notin> P\<^sub>2" using inv\<^sub>1E(4)[OF invrules(1)] by simp ultimately have DISJNT: "\<Union>P\<^sub>2 \<inter> B\<^sub>2 = {}" by (auto, metis (no_types, hide_lams) sup_bot.right_neutral Un_insert_right disjnt_iff mk_disjoint_insert pairwise_insert wrap_Un) have "finite (\<Union>P\<^sub>2)" using U_Finite bprules(3) by auto have "finite B\<^sub>2" using inv\<^sub>1E(1)[OF invrules(1)] bp_bins_finite wrap_not_empty by blast have "2 * card (P\<^sub>2 \<union> wrap B\<^sub>2) \<le> 2 * (card P\<^sub>2 + card (wrap B\<^sub>2))" using card_Un_le[of P\<^sub>2 \<open>wrap B\<^sub>2\<close>] by simp also have "... \<le> 2 * card P\<^sub>2 + 2" using wrap_card by auto also have "... \<le> card (\<Union> P\<^sub>2) + 2" using invrules(4) by simp also have "... \<le> card (\<Union> P\<^sub>2) + card B\<^sub>2" using B\<^sub>2_at_least_two_objects[OF assms(1,3,5)] by simp also have "... = card (\<Union> (P\<^sub>2 \<union> {B\<^sub>2}))" using DISJNT card_Un_disjoint[OF \<open>finite (\<Union>P\<^sub>2)\<close> \<open>finite B\<^sub>2\<close>] by (simp add: Un_commute) also have "... = card (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" by (cases \<open>B\<^sub>2 = {}\<close>) auto finally show ?thesis . qed from inv\<^sub>2I[OF 1 2 3 4] have "inv\<^sub>2 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})" . from inv\<^sub>3I[OF this] show ?thesis using assms(3) by blast qed text \<open>The bin packing algorithm as it is proposed in the article @{cite BerghammerR03}.
      \<open>P\<close> will not only be a correct solution of the bin packing problem, but the amount of bins
      will be a lower bound for \<open>3 / 2\<close> of the amount of bins of any correct solution \<open>Q\<close>, and thus
      guarantee an approximation factor of \<open>3 / 2\<close> for the optimum.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv<^sub>3 P<^sub>1 P<^sub>2 B<^sub>1 B<^sub>2 V" "B<^sub>1 ≠ {}" "u ∈ V ∩ S" "W B<^sub>1 + w(u) > c" "W B<^sub>2 + w(u) > c"
  hence "inv<^sub>3 (P<^sub>1 ∪ wrap B<^sub>1) (P<^sub>2 ∪ wrap B<^sub>2) {} {u} (V - {u})"
    using "inv<^sub>3 P<^sub>1 P<^sub>2 B<^sub>1 B<^sub>2 V" "B<^sub>1 ≠ {}" "u ∈ V ∩ S" "W B<^sub>1 + w(u) > c" "W B<^sub>2 + w(u) > c"
    by (auto simp: inv<^sub>3.def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.35
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (44%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bp_approx:
"VARS P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u
  {True}
  P\<^sub>1 := {}; P\<^sub>2 := {}; B\<^sub>1 := {}; B\<^sub>2 := {}; V := U;
  WHILE V \<inter> S \<noteq> {} INV {inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V} DO 
    IF B\<^sub>1 \<noteq> {}
    THEN u := (SOME u. u \<in> V \<inter> S)
    ELSE IF V \<inter> L \<noteq> {}
         THEN u := (SOME u. u \<in> V \<inter> L)
         ELSE u := (SOME u. u \<in> V \<inter> S) FI FI;
    V := V - {u};
    IF W(B\<^sub>1) + w(u) \<le> c
    THEN B\<^sub>1 := B\<^sub>1 \<union> {u}
    ELSE IF W(B\<^sub>2) + w(u) \<le> c
         THEN B\<^sub>2 := B\<^sub>2 \<union> {u}
         ELSE P\<^sub>2 := P\<^sub>2 \<union> wrap B\<^sub>2; B\<^sub>2 := {u} FI;
         P\<^sub>1 := P\<^sub>1 \<union> wrap B\<^sub>1; B\<^sub>1 := {} FI
  OD;
  P := P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} | v. v \<in> V}
  {bp P \<and> (\<forall>Q. bp Q \<longrightarrow> card P \<le> 3 / 2 * card Q)}"</h2><br>
<b>Ground proof:</b> <br><pre><code></code></pre>
<b>Generated proof:</b><pre><code>```
by (induct_tac "bp_approx")
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.45
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (45%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bpE:
  assumes "bp P"
  shows "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding bp_def partition_on_def by blast+</code></pre>
<b>Generated proof:</b><pre><code>```
lemma bpE:
  assumes "bp P"
  shows "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"
proof -
  have "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c" using assm by (auto simp: bp_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.26
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (46%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bpI:
  assumes "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"
  shows "bp P"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding bp_def partition_on_def by blast text \<open>Although we assume the \<open>S\<close> and \<open>L\<close> sets as given, manually obtaining them from \<open>U\<close> is trivial
      and can be achieved in linear time. Proposed by the article @{cite "BerghammerR03"}.\<close> lemma S_L_set_generation:
"VARS S L W u
  {True}
  S := {}; L := {}; W := U;
  WHILE W \<noteq> {}
  INV {W \<subseteq> U \<and> S = {v \<in> U - W. w(v) \<le> c / 2} \<and> L = {v \<in> U - W. w(v) > c / 2}} DO
    u := (SOME u. u \<in> W);
    IF 2 * w(u) \<le> c
    THEN S := S \<union> {u}
    ELSE L := L \<union> {u} FI;
    W := W - {u}
  OD
  {S = {v \<in> U. w(v) \<le> c / 2} \<and> L = {v \<in> U. w(v) > c / 2}}" by vcg (auto simp: some_in_eq) subsection \<open>The Proposed Approximation Algorithm\<close> subsubsection \<open>Functional Correctness\<close> text \<open>According to the article, \<open>inv\<^sub>1\<close> holds if \<open>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}\<close>
      is a correct solution for the bin packing problem @{cite BerghammerR03}. However, various
      assumptions made in the article seem to suggest that more information is demanded from this
      invariant and, indeed, mere correctness (as defined in @{thm [source] bp_def}) does not appear to suffice.
      To amend this, four additional conjuncts have been added to this invariant, whose necessity
      will be explained in the following proofs. It should be noted that there may be other (shorter) ways to amend this invariant.
      This approach, however, makes for rather straight-forward proofs, as these conjuncts can be utilized and proved in relatively few steps.\<close> definition inv\<^sub>1 :: "'a set set \<Rightarrow> 'a set set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<longleftrightarrow> bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) \<comment> \<open>A correct solution to the bin packing problem\<close>
                       \<and> \<Union>(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - V \<comment> \<open>The partial solution does not contain objects that have not yet been assigned\<close>
                       \<and> B\<^sub>1 \<notin> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) \<comment> \<open>\<open>B\<^sub>1\<close> is distinct from all the other bins\<close>
                       \<and> B\<^sub>2 \<notin> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2) \<comment> \<open>\<open>B\<^sub>2\<close> is distinct from all the other bins\<close>
                       \<and> (P\<^sub>1 \<union> wrap B\<^sub>1) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {} \<comment> \<open>The first and second partial solutions are disjoint from each other.\<close>" (*
lemma "partition_on U (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) \<Longrightarrow> u \<in> V \<Longrightarrow>
partition_on U (P\<^sub>1 \<union> wrap (insert u B\<^sub>1) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> (V-{u})})"
  nitpick*)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma bpI:
  assumes "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"
  shows "bp P"
proof -
  have "bp P"
  proof -
    have "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"
    proof -
      assume "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"
      then have "bp P" by (rule bpI)
    qed
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.34
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (47%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1E:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
  shows "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})"
    and "\<Union>(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - V"
    and "B\<^sub>1 \<notin> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)"
    and "B\<^sub>2 \<notin> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2)"
    and "(P\<^sub>1 \<union> wrap B\<^sub>1) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>1_def by auto</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, hide_lams) inv_1E.inv_1E inv_1E.inv_2E inv_1E.inv_3E inv_1E.inv_4E inv_1E.inv_5E)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (48%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1I:
  assumes "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})"
    and "\<Union>(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - V"
    and "B\<^sub>1 \<notin> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)"
    and "B\<^sub>2 \<notin> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2)"
    and "(P\<^sub>1 \<union> wrap B\<^sub>1) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}"
  shows "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>1_def by blast</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, hide_lams) assms(1 2 3 4 5))
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (49%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wrap_Un [simp]: "wrap (M \<union> {x}) = {M \<union> {x}}"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wrap_def by simp</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume M is a set.
2. By definition of set union, we have M \<union> {x} = {y | y ∈ M ∨ y = x}.
3. Therefore, wrap (M \<union> {x}) = wrap {y | y ∈ M ∨ y = x}.
4. By definition of wrap, we have wrap {y | y ∈ M ∨ y = x} = {M \<union> {x}}.
5. Hence, wrap (M \<union> {x}) = {M \<union> {x}}.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but identifier Proof (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
*** At command "by" (line 77 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but identifier Proof (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.33
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (50%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wrap_empty [simp]: "wrap {} = {}"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wrap_def by simp</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by (simp add: wrap_empty)
QED

This proof uses the `simp` tactic with the `add` option to include the `wrap_empty` theorem in the simplification process. The `QED` keyword signifies the end of the proof.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but identifier Proof (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.38
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (51%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wrap_not_empty [simp]: "M \<noteq> {} \<longleftrightarrow> wrap M = {M}"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wrap_def by simp text \<open>If \<open>inv\<^sub>1\<close> holds for the current partial solution, and the weight of an object \<open>u \<in> V\<close> added to \<open>B\<^sub>1\<close> does
      not exceed its capacity, then \<open>inv\<^sub>1\<close> also holds if \<open>B\<^sub>1\<close> and \<open>{u}\<close> are replaced by \<open>B\<^sub>1 \<union> {u}\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume M \<noteq> {}
2. By definition of wrap, we have wrap M = {M}
3. Therefore, M \<noteq> {} \<longleftrightarrow> wrap M = {M}

QED.

Proof:

1. Assume M \<noteq> {}
2. By definition of wrap, we have wrap M = {M}
3. Therefore, M \<noteq> {} \<longleftrightarrow> wrap M = {M}

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but identifier Proof (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.33
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (52%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1_stepA:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V" "W(B\<^sub>1) + w(u) \<le> c"
  shows "inv\<^sub>1 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>1E[OF assms(1)] and bprules = bpE[OF invrules(1)] text \<open>In the proof for \<open>Theorem 3.2\<close> of the article it is erroneously argued that
        if \<open>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}\<close> is a partition of \<open>U\<close>,
        then the same holds if \<open>B\<^sub>1\<close> is replaced by \<open>B\<^sub>1 \<union> {u}\<close>.
        This is, however, not necessarily the case if \<open>B\<^sub>1\<close> or \<open>{u}\<close> are already contained in the partial solution.
        Suppose \<open>P\<^sub>1\<close> contains the non-empty bin \<open>B\<^sub>1\<close>, then \<open>P\<^sub>1 \<union> wrap B\<^sub>1\<close> would still be pairwise disjoint, provided \<open>P\<^sub>1\<close> was pairwise disjoint before, as the union simply ignores the duplicate \<open>B\<^sub>1\<close>. Now, if the algorithm modifies \<open>B\<^sub>1\<close> by adding an element from \<open>V\<close> such that \<open>B\<^sub>1\<close> becomes some non-empty \<open>B\<^sub>1'\<close> with \<open>B\<^sub>1 \<inter> B\<^sub>1' \<noteq> \<emptyset>\<close> and \<open>B\<^sub>1' \<notin> P\<^sub>1\<close>, one can see that this property would no longer be preserved.
        To avoid such a situation, we will use the first additional conjunct in \<open>inv\<^sub>1\<close> to ensure that \<open>{u}\<close>
        is not yet contained in the partial solution, and the second additional conjunct to ensure that \<open>B\<^sub>1\<close>
        is not yet contained in the partial solution.\<close>

  \<comment> \<open>Rule 1: Pairwise Disjoint\<close> have NOTIN: "\<forall>M \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. u \<notin> M" using invrules(2) assms(2) by blast have "{{v} |v. v \<in> V} = {{u}} \<union> {{v} |v. v \<in> V - {u}}" using assms(2) by blast then have "pairwise disjnt (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> ({{u}} \<union> {{v} |v. v \<in> V - {u}}))" using bprules(1) assms(2) by simp then have "pairwise disjnt (wrap B\<^sub>1 \<union> {{u}} \<union> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}})" by (simp add: Un_commute) then have assm: "pairwise disjnt (wrap B\<^sub>1 \<union> {{u}} \<union> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by (simp add: Un_assoc) have "pairwise disjnt ({B\<^sub>1 \<union> {u}} \<union> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" proof (cases \<open>B\<^sub>1 = {}\<close>) case True with assm show ?thesis by simp next case False with assm have assm: "pairwise disjnt ({B\<^sub>1} \<union> {{u}} \<union> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by simp from NOTIN have "{u} \<notin> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}" by blast from pairwise_disjnt_Un[OF assm _ this] invrules(2,3) show ?thesis using False by auto qed then have 1: "pairwise disjnt (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}})" unfolding wrap_Un by simp

  \<comment> \<open>Rule 2: No empty sets\<close> from bprules(2) have 2: "{} \<notin> P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}" unfolding wrap_def by simp

  \<comment> \<open>Rule 3: Union preserved\<close> from bprules(3) have "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}}) = U" using assms(2) by blast then have 3: "\<Union> (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}) = U" unfolding wrap_def by force

  \<comment> \<open>Rule 4: Weights below capacity\<close> have "0 < w u" using weight assms(2) bprules(3) by blast have "finite B\<^sub>1" using bprules(3) U_Finite by (cases \<open>B\<^sub>1 = {}\<close>) auto then have "W (B\<^sub>1 \<union> {u}) \<le> W B\<^sub>1 + w u" using \<open>0 < w u\<close> by (cases \<open>u \<in> B\<^sub>1\<close>) (auto simp: insert_absorb) also have "... \<le> c" using assms(3) . finally have "W (B\<^sub>1 \<union> {u}) \<le> c" . then have "\<forall>B \<in> wrap (B\<^sub>1 \<union> {u}). W B \<le> c" unfolding wrap_Un by blast moreover have "\<forall>B\<in>P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" using bprules(4) by blast ultimately have 4: "\<forall>B\<in>P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" by blast from bpI[OF 1 2 3 4] have 1: "bp (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}})" .

  \<comment> \<open>Auxiliary information is preserved\<close> have "u \<in> U" using assms(2) bprules(3) by blast then have R: "U - (V - {u}) = U - V \<union> {u}" by blast have L: "\<Union> (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = \<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) \<union> {u}" unfolding wrap_def using NOTIN by auto have 2: "\<Union> (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - (V - {u})" unfolding L R invrules(2) .. have 3: "B\<^sub>1 \<union> {u} \<notin> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2" using NOTIN by auto have 4: "B\<^sub>2 \<notin> P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2" using invrules(4) NOTIN unfolding wrap_def by fastforce have 5: "(P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u})) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}" using invrules(5) NOTIN unfolding wrap_Un by auto from inv\<^sub>1I[OF 1 2 3 4 5] show ?thesis . qed text \<open>If \<open>inv\<^sub>1\<close> holds for the current partial solution, and the weight of an object \<open>u \<in> V\<close> added to \<open>B\<^sub>2\<close> does
      not exceed its capacity, then \<open>inv\<^sub>1\<close> also holds if \<open>B\<^sub>2\<close> and \<open>{u}\<close> are replaced by \<open>B\<^sub>2 \<union> {u}\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma inv_1_stepA:
  assumes "inv_1 P_1 P_2 B_1 B_2 V" "u ∈ V" "W(B_1) + w(u) ≤ c"
  shows "inv_1 P_1 P_2 (B_1 ∪ {u}) B_2 (V - {u})"
proof -
  from assms have "inv_1 P_1 P_2 B_1 B_2 V" by fact
  moreover have "u ∈ V" by fact
  moreover have "W(B_1) + w(u) ≤ c" by fact
  then have "inv_1 P_1 P_2 (B_1 ∪ {u}) B_2 (V - {u})"
    using inv_1_def by (auto simp: inv_1_def)
  finally show "inv_1 P_1 P_2 (B_1 ∪ {u}) B_2 (V - {u})" by blast
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.38
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (53%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1_stepB:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V" "W B\<^sub>2 + w u \<le> c"
  shows "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>1E[OF assms(1)] and bprules = bpE[OF invrules(1)] text \<open>The argumentation here is similar to the one in @{thm [source] inv\<^sub>1_stepA} with
      \<open>B\<^sub>1\<close> replaced with \<open>B\<^sub>2\<close> and using the first and third additional conjuncts of \<open>inv\<^sub>1\<close>
      to amend the issue, instead of the first and second.\<close>
  \<comment> \<open>Rule 1: Pairwise Disjoint\<close> have NOTIN: "\<forall>M \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. u \<notin> M" using invrules(2) assms(2) by blast have "{{v} |v. v \<in> V} = {{u}} \<union> {{v} |v. v \<in> V - {u}}" using assms(2) by blast then have "pairwise disjnt (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}})" using bprules(1) assms(2) by simp then have assm: "pairwise disjnt (wrap B\<^sub>2 \<union> {{u}} \<union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by (simp add: Un_assoc Un_commute) have "pairwise disjnt ({B\<^sub>2 \<union> {u}} \<union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" proof (cases \<open>B\<^sub>2 = {}\<close>) case True with assm show ?thesis by simp next case False with assm have assm: "pairwise disjnt ({B\<^sub>2} \<union> {{u}} \<union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by simp from NOTIN have "{u} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}" by blast from pairwise_disjnt_Un[OF assm _ this] invrules(2,4) show ?thesis using False by auto qed then have 1: "pairwise disjnt (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}})" unfolding wrap_Un by simp

  \<comment> \<open>Rule 2: No empty sets\<close> from bprules(2) have 2: "{} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}}" unfolding wrap_def by simp

  \<comment> \<open>Rule 3: Union preserved\<close> from bprules(3) have "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}}) = U" using assms(2) by blast then have 3: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}}) = U" unfolding wrap_def by force

  \<comment> \<open>Rule 4: Weights below capacity\<close> have "0 < w u" using weight assms(2) bprules(3) by blast have "finite B\<^sub>2" using bprules(3) U_Finite by (cases \<open>B\<^sub>2 = {}\<close>) auto then have "W (B\<^sub>2 \<union> {u}) \<le> W B\<^sub>2 + w u" using \<open>0 < w u\<close> by (cases \<open>u \<in> B\<^sub>2\<close>) (auto simp: insert_absorb) also have "... \<le> c" using assms(3) . finally have "W (B\<^sub>2 \<union> {u}) \<le> c" . then have "\<forall>B \<in> wrap (B\<^sub>2 \<union> {u}). W B \<le> c" unfolding wrap_Un by blast moreover have "\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" using bprules(4) by blast ultimately have 4: "\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" by auto from bpI[OF 1 2 3 4] have 1: "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}})" .

  \<comment> \<open>Auxiliary information is preserved\<close> have "u \<in> U" using assms(2) bprules(3) by blast then have R: "U - (V - {u}) = U - V \<union> {u}" by blast have L: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})) = \<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap B\<^sub>2) \<union> {u}" unfolding wrap_def using NOTIN by auto have 2: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})) = U - (V - {u})" unfolding L R using invrules(2) by simp have 3: "{} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})" using bpE(2)[OF 1] by simp have 4: "B\<^sub>2 \<union> {u} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2" using NOTIN by auto have 5: "(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}) \<inter> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})) = {}" using invrules(5) NOTIN unfolding wrap_empty wrap_Un by auto from inv\<^sub>1I[OF 1 2 3 4 5] show ?thesis . qed text \<open>If \<open>inv\<^sub>1\<close> holds for the current partial solution, then \<open>inv\<^sub>1\<close> also holds if \<open>B\<^sub>1\<close> and \<open>B\<^sub>2\<close> are
      added to \<open>P\<^sub>1\<close> and \<open>P\<^sub>2\<close> respectively, \<open>B\<^sub>1\<close> is emptied and \<open>B\<^sub>2\<close> initialized with \<open>u \<in> V\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv<sub>1</sub> P<sub>1</sub> P<sub>2</sub> B<sub>1</sub> B<sub>2</sub> V" "u ∈ V" "W B<sub>2</sub> + w u ≤ c"
  hence "inv<sub>1</sub> (P<sub>1</sub> ∪ wrap B<sub>1</sub>) P<sub>2</sub> {} (B<sub>2</sub> ∪ {u}) (V - {u})"
    using "inv<sub>1</sub> P<sub>1</sub> P<sub>2</sub> B<sub>1</sub> B<sub>2</sub> V" "u ∈ V" "W B<sub>2</sub> + w u ≤ c"
    by (auto simp: inv<sub>1</sub>_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.43
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (54%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1_stepC:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V"
  shows "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>1E[OF assms(1)]
  \<comment> \<open>Rule 1-4: Correct Bin Packing\<close> have "P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u} \<union> {{v} |v. v \<in> V - {u}}
      = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}}" by (metis (no_types, lifting) Un_assoc Un_empty_right insert_not_empty wrap_empty wrap_not_empty) also have "... = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}" using assms(2) by auto finally have EQ: "P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u} \<union> {{v} |v. v \<in> V - {u}}
                  = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}" . from invrules(1) have 1: "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u} \<union> {{v} |v. v \<in> V - {u}})" unfolding EQ .

  \<comment> \<open>Auxiliary information is preserved\<close> have NOTIN: "\<forall>M \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. u \<notin> M" using invrules(2) assms(2) by blast have "u \<in> U" using assms(2) bpE(3)[OF invrules(1)] by blast then have R: "U - (V - {u}) = U - V \<union> {u}" by blast have L: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u}) = \<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" unfolding wrap_def using NOTIN by auto have 2: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u}) = U - (V - {u})" unfolding L R using invrules(2) by auto have 3: "{} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u}" using bpE(2)[OF 1] by simp have 4: "{u} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2)" using NOTIN by auto have 5: "(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}) = {}" using invrules(5) NOTIN unfolding wrap_def by force from inv\<^sub>1I[OF 1 2 3 4 5] show ?thesis . qed text \<open>A simplified version of the bin packing algorithm proposed in the article.
      It serves as an introduction into the approach taken, and, while it does not provide the desired
      approximation factor, it does ensure that \<open>P\<close> is a correct solution of the bin packing problem.\<close> lemma simple_bp_correct:
"VARS P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u
  {True}
  P\<^sub>1 := {}; P\<^sub>2 := {}; B\<^sub>1 := {}; B\<^sub>2 := {}; V := U;
  WHILE V \<inter> S \<noteq> {} INV {inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V} DO
    u := (SOME u. u \<in> V); V := V - {u};
    IF W(B\<^sub>1) + w(u) \<le> c
    THEN B\<^sub>1 := B\<^sub>1 \<union> {u}
    ELSE IF W(B\<^sub>2) + w(u) \<le> c
         THEN B\<^sub>2 := B\<^sub>2 \<union> {u}
         ELSE P\<^sub>2 := P\<^sub>2 \<union> wrap B\<^sub>2; B\<^sub>2 := {u} FI;
         P\<^sub>1 := P\<^sub>1 \<union> wrap B\<^sub>1; B\<^sub>1 := {} FI
  OD;
  P := P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} | v. v \<in> V}
  {bp P}" proof (vcg, goal_cases) case (1 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u) show ?case unfolding bp_def partition_on_def pairwise_def wrap_def inv\<^sub>1_def using weight by auto next case (2 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u) then have INV: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" .. from 2 have "V \<noteq> {}" by blast then have IN: "(SOME u. u \<in> V) \<in> V" by (simp add: some_in_eq) from inv\<^sub>1_stepA[OF INV IN] inv\<^sub>1_stepB[OF INV IN] inv\<^sub>1_stepC[OF INV IN] show ?case by blast next case (3 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u) then show ?case unfolding inv\<^sub>1_def by blast qed subsubsection \<open>Lower Bounds for the Bin Packing Problem\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv<sub>1</sub> P<sub>1</sub> P<sub>2</sub> B<sub>1</sub> B<sub>2</sub> V" "u ∈ V"
  then have "inv<sub>1</sub> (P<sub>1</sub> ∪ wrap B<sub>1</sub>) (P<sub>2</sub> ∪ wrap B<sub>2</sub>) {} {u} (V - {u})"
    using "inv<sub>1</sub> P<sub>1</sub> P<sub>2</sub> B<sub>1</sub> B<sub>2</sub> V" "u ∈ V"
    by (auto simp: inv<sub>1</sub>_stepC)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.35
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (55%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bp_bins_finite [simp]:
  assumes "bp P"
  shows "\<forall>B \<in> P. finite B"</h2><br>
<b>Ground proof:</b> <br><pre><code>using bpE(3)[OF assms] U_Finite by (meson Sup_upper finite_subset)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis bp_finite)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:27 cpu time, factor 3.49
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (56%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bp_sol_finite [simp]:
  assumes "bp P"
  shows "finite P"</h2><br>
<b>Ground proof:</b> <br><pre><code>using bpE(3)[OF assms] U_Finite by (simp add: finite_UnionD) text \<open>If \<open>P\<close> is a solution of the bin packing problem, then no bin in \<open>P\<close> may contain more than
      one large object.\<close> lemma only_one_L_per_bin:
  assumes "bp P" "B \<in> P"
  shows "\<forall>x \<in> B. \<forall>y \<in> B. x \<noteq> y \<longrightarrow> x \<notin> L \<or> y \<notin> L" proof (rule ccontr, simp) assume "\<exists>x\<in>B. \<exists>y\<in>B. x \<noteq> y \<and> x \<in> L \<and> y \<in> L" then obtain x y where *: "x \<in> B" "y \<in> B" "x \<noteq> y" "x \<in> L" "y \<in> L" by blast then have "c < w x + w y" using L_def S_def by force have "finite B" using assms by simp have "y \<in> B - {x}" using *(2,3) by blast have "W B = W (B - {x}) + w x" using *(1) \<open>finite B\<close> by (simp add: sum.remove) also have "... = W (B - {x} - {y}) + w x + w y" using \<open>y \<in> B - {x}\<close> \<open>finite B\<close> by (simp add: sum.remove) finally have *: "W B = W (B - {x} - {y}) + w x + w y" . have "\<forall>u \<in> B. 0 < w u" using bpE(3)[OF assms(1)] assms(2) weight by blast then have "0 \<le> W (B - {x} - {y})" by (smt DiffD1 sum_nonneg) with * have "c < W B" using \<open>c < w x + w y\<close> by simp then show False using bpE(4)[OF assms(1)] assms(2) by fastforce qed text \<open>If \<open>P\<close> is a solution of the bin packing problem, then the amount of large objects
      is a lower bound for the amount of bins in P.\<close> lemma L_lower_bound_card:
  assumes "bp P"
  shows "card L \<le> card P" proof - have "\<forall>x \<in> L. \<exists>B \<in> P. x \<in> B" using bpE(3)[OF assms] L_def by blast then obtain f where f_def: "\<forall>u \<in> L. u \<in> f u \<and> f u \<in> P" by metis then have "inj_on f L" unfolding inj_on_def using only_one_L_per_bin[OF assms] by blast then have card_eq: "card L = card (f ` L)" by (simp add: card_image) have "f ` L \<subseteq> P" using f_def by blast moreover have "finite P" using assms by simp ultimately have "card (f ` L) \<le> card P" by (simp add: card_mono) then show ?thesis unfolding card_eq . qed text \<open>If \<open>P\<close> is a solution of the bin packing problem, then the amount of bins of a subset of P
      in which every bin contains a large object is a lower bound on the amount of large objects.\<close> lemma subset_bp_card:
  assumes "bp P" "M \<subseteq> P" "\<forall>B \<in> M. B \<inter> L \<noteq> {}"
  shows "card M \<le> card L" proof - have "\<forall>B \<in> M. \<exists>u \<in> L. u \<in> B" using assms(3) by fast then have "\<exists>f. \<forall>B \<in> M. f B \<in> L \<and> f B \<in> B" by metis then obtain f where f_def: "\<forall>B \<in> M. f B \<in> L \<and> f B \<in> B" .. have "inj_on f M" proof (rule ccontr) assume "\<not> inj_on f M" then have "\<exists>x \<in> M. \<exists>y \<in> M. x \<noteq> y \<and> f x = f y" unfolding inj_on_def by blast then obtain x y where *: "x \<in> M" "y \<in> M" "x \<noteq> y" "f x = f y" by blast then have "\<exists>u. u \<in> x \<and> u \<in> y" using f_def by metis then have "x \<inter> y \<noteq> {}" by blast moreover have "pairwise disjnt M" using pairwise_subset[OF bpE(1)[OF assms(1)] assms(2)] . ultimately show False using * unfolding pairwise_def disjnt_def by simp qed moreover have "finite L" using L_def U_Finite by blast moreover have "f ` M \<subseteq> L" using f_def by blast ultimately show ?thesis using card_inj_on_le by blast qed text \<open>If \<open>P\<close> is a correct solution of the bin packing problem, \<open>inv\<^sub>1\<close> holds for the partial solution,
      and every bin in \<open>P\<^sub>1 \<union> wrap B\<^sub>1\<close> contains a large object, then the amount of bins in
      \<open>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}\<close> is a lower bound for the amount of bins in \<open>P\<close>.\<close> lemma L_bins_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "\<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}) \<le> card P" proof - note invrules = inv\<^sub>1E[OF assms(2)] have "\<forall>B \<in> {{v} |v. v \<in> V \<inter> L}. B \<inter> L \<noteq> {}" by blast with assms(3) have
    "P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L} \<subseteq> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}"
    "\<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}. B \<inter> L \<noteq> {}" by blast+ from subset_bp_card[OF invrules(1) this] show ?thesis using L_lower_bound_card[OF assms(1)] by linarith qed text \<open>If \<open>P\<close> is a correct solution of the bin packing problem, then the sum of the weights of the
      objects is equal to the sum of the weights of the bins in \<open>P\<close>.\<close> lemma sum_Un_eq_sum_sum:
  assumes "bp P"
  shows "(\<Sum>u \<in> U. w u) = (\<Sum>B \<in> P. W B)" proof - have FINITE: "\<forall>B \<in> P. finite B" using assms by simp have DISJNT: "\<forall>A \<in> P. \<forall>B \<in> P. A \<noteq> B \<longrightarrow> A \<inter> B = {}" using bpE(1)[OF assms] unfolding pairwise_def disjnt_def . have "(\<Sum>u \<in> (\<Union>P). w u) = (\<Sum>B \<in> P. W B)" using sum.Union_disjoint[OF FINITE DISJNT] by auto then show ?thesis unfolding bpE(3)[OF assms] . qed text \<open>If \<open>P\<close> is a correct solution of the bin packing problem, then the sum of the weights of the items
      is a lower bound of amount of bins in \<open>P\<close> multiplied by their maximum capacity.\<close> lemma sum_lower_bound_card:
  assumes "bp P"
  shows "(\<Sum>u \<in> U. w u) \<le> c * card P" proof - have *: "\<forall>B \<in> P. 0 < W B \<and> W B \<le> c" using bpE(2-4)[OF assms] weight by (metis UnionI assms bp_bins_finite sum_pos) have "(\<Sum>u \<in> U. w u) = (\<Sum>B \<in> P. W B)" using sum_Un_eq_sum_sum[OF assms] . also have "... \<le> (\<Sum>B \<in> P. c)" using sum_mono * by fastforce also have "... = c * card P" by simp finally show ?thesis . qed lemma bp_NE:
  assumes "bp P"
  shows "P \<noteq> {}" using U_NE bpE(3)[OF assms] by blast lemma sum_Un_ge:
  fixes f :: "_ \<Rightarrow> real"
  assumes "finite M" "finite N" "\<forall>B \<in> M \<union> N. 0 < f B"
  shows "sum f M \<le> sum f (M \<union> N)" proof - have "0 \<le> sum f N - sum f (M \<inter> N)" using assms by (smt DiffD1 inf.cobounded2 UnCI sum_mono2) then have "sum f M \<le> sum f M + sum f N - sum f (M \<inter> N)" by simp also have "... = sum f (M \<union> N)" using sum_Un[OF assms(1,2), symmetric] . finally show ?thesis . qed text \<open>If \<open>bij_exists\<close> holds, one can obtain a function which is bijective between the bins in \<open>P\<close>
and the objects in \<open>V\<close> such that an object returned by the function would cause the bin to
exceed its capacity.\<close> definition bij_exists :: "'a set set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "bij_exists P V = (\<exists>f. bij_betw f P V \<and> (\<forall>B \<in> P. W B + w (f B) > c))" text \<open>If \<open>P\<close> is a functionally correct solution of the bin packing problem, \<open>inv\<^sub>1\<close> holds for the
partial solution, and such a bijective function exists between the bins in \<open>P\<^sub>1\<close> and the objects in
@{term "P\<^sub>2 \<union> wrap B\<^sub>2"}, the following strict lower bound can be shown:\<close> lemma P\<^sub>1_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
  shows "card P\<^sub>1 + 1 \<le> card P" proof (cases \<open>P\<^sub>1 = {}\<close>) case True have "finite P" using assms(1) by simp then have "1 \<le> card P" using bp_NE[OF assms(1)] by (metis Nat.add_0_right Suc_diff_1 Suc_le_mono card_gt_0_iff le0 mult_Suc_right nat_mult_1) then show ?thesis unfolding True by simp next note invrules = inv\<^sub>1E[OF assms(2)] case False obtain f where f_def: "bij_betw f P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))" "\<forall>B \<in> P\<^sub>1. W B + w (f B) > c" using assms(3) unfolding bij_exists_def by blast have FINITE: "finite P\<^sub>1" "finite (P\<^sub>2 \<union> wrap B\<^sub>2)" "finite (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)" "finite (wrap B\<^sub>1 \<union> {{v} |v. v \<in> V})" using inv\<^sub>1E(1)[OF assms(2)] bp_sol_finite by blast+ have F: "\<forall>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. finite B" using invrules(1) by simp have D: "\<forall>A \<in> P\<^sub>2 \<union> wrap B\<^sub>2. \<forall>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. A \<noteq> B \<longrightarrow> A \<inter> B = {}" using bpE(1)[OF invrules(1)] unfolding pairwise_def disjnt_def by auto have sum_eq: "W (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) = (\<Sum>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. W B)" using sum.Union_disjoint[OF F D] by auto have "\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}. 0 < W B" using bpE(2,3)[OF invrules(1)] weight by (metis (no_types, lifting) UnionI bp_bins_finite invrules(1) sum_pos) then have "(\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2. W B) \<le> (\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> (wrap B\<^sub>1 \<union> {{v} |v. v \<in> V}). W B)" using sum_Un_ge[OF FINITE(3,4), of W] by blast also have "... = (\<Sum>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}. W B)" by (smt Un_assoc Un_commute) also have "... = W U" using sum_Un_eq_sum_sum[OF invrules(1), symmetric] . finally have *: "(\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2. W B) \<le> W U" .

  \<comment> \<open>This follows from the fourth and final additional conjunct of \<open>inv\<^sub>1\<close> and is necessary to combine the sums of the bins
      of the two partial solutions. This does not inherently follow from the union being a correct solution,
      as this need not be the case if \<open>P\<^sub>1\<close> and \<open>P\<^sub>2 \<union> wrap B\<^sub>2\<close> happened to be equal.\<close> have DISJNT: "P\<^sub>1 \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}" using invrules(5) by blast

  \<comment> \<open>This part of the proof is based on the proof on page 72 of the article @{cite BerghammerR03}.\<close> have "c * card P\<^sub>1 = (\<Sum>B \<in> P\<^sub>1. c)" by simp also have "... < (\<Sum>B \<in> P\<^sub>1. W B + w (f B))" using f_def(2) sum_strict_mono[OF FINITE(1) False] by fastforce also have "... = (\<Sum>B \<in> P\<^sub>1. W B) + (\<Sum>B \<in> P\<^sub>1. w (f B))" by (simp add: Groups_Big.comm_monoid_add_class.sum.distrib) also have "... = (\<Sum>B \<in> P\<^sub>1. W B) + W (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" unfolding sum.reindex_bij_betw[OF f_def(1), of w] .. also have "... = (\<Sum>B \<in> P\<^sub>1. W B) + (\<Sum>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. W B)" unfolding sum_eq .. also have "... = (\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2. W B)" using sum.union_disjoint[OF FINITE(1,2) DISJNT, of W] by (simp add: Un_assoc) also have "... \<le> (\<Sum>u \<in> U. w u)" using * . also have "... \<le> c * card P" using sum_lower_bound_card[OF assms(1)] . finally show ?thesis by (meson discrete nat_mult_less_cancel_disj of_nat_less_imp_less) qed text \<open>As @{thm wrap_card} holds, it follows that the amount of bins in \<open>P\<^sub>1 \<union> wrap B\<^sub>1\<close>
      are a lower bound for the amount of bins in \<open>P\<close>.\<close> lemma P\<^sub>1_B\<^sub>1_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1) \<le> card P" proof - have "card (P\<^sub>1 \<union> wrap B\<^sub>1) \<le> card P\<^sub>1 + card (wrap B\<^sub>1)" using card_Un_le by blast also have "... \<le> card P\<^sub>1 + 1" using wrap_card by simp also have "... \<le> card P" using P\<^sub>1_lower_bound_card[OF assms] . finally show ?thesis . qed text \<open>If \<open>inv\<^sub>1\<close> holds, there are at most half as many bins in \<open>P\<^sub>2\<close> as there are objects in \<open>P\<^sub>2\<close>, and we can again
      obtain a bijective function between the bins in \<open>P\<^sub>1\<close> and the objects of the second partial solution,
      then the amount of bins in the second partial solution are a strict lower bound for half the bins of
      the first partial solution.\<close> lemma P\<^sub>2_B\<^sub>2_lower_bound_P\<^sub>1:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)" "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
  shows "2 * card (P\<^sub>2 \<union> wrap B\<^sub>2) \<le> card P\<^sub>1 + 1" proof - note invrules = inv\<^sub>1E[OF assms(1)] and bprules = bpE[OF invrules(1)] have "pairwise disjnt (P\<^sub>2 \<union> wrap B\<^sub>2)" using bprules(1) pairwise_subset by blast moreover have "B\<^sub>2 \<notin> P\<^sub>2" using invrules(4) by simp ultimately have DISJNT: "\<Union>P\<^sub>2 \<inter> B\<^sub>2 = {}" by (auto, metis (no_types, hide_lams) sup_bot.right_neutral Un_insert_right disjnt_iff mk_disjoint_insert pairwise_insert wrap_Un) have "finite (\<Union>P\<^sub>2)" using U_Finite bprules(3) by auto have "finite B\<^sub>2" using bp_bins_finite[OF invrules(1)] wrap_not_empty by blast have "finite P\<^sub>2" "finite (wrap B\<^sub>2)" using bp_sol_finite[OF invrules(1)] by blast+ have DISJNT2: "P\<^sub>2 \<inter> wrap B\<^sub>2 = {}" unfolding wrap_def using \<open>B\<^sub>2 \<notin> P\<^sub>2\<close> by auto have "card (wrap B\<^sub>2) \<le> card B\<^sub>2" proof (cases \<open>B\<^sub>2 = {}\<close>) case False then have "1 \<le> card B\<^sub>2" by (simp add: leI \<open>finite B\<^sub>2\<close>) then show ?thesis using wrap_card[of B\<^sub>2] by linarith qed simp

  \<comment> \<open>This part of the proof is based on the proof on page 73 of the article @{cite BerghammerR03}.\<close> from assms(2) have "2 * card P\<^sub>2 + 2 * card (wrap B\<^sub>2) \<le> card (\<Union>P\<^sub>2) + card (wrap B\<^sub>2) + 1" using wrap_card[of B\<^sub>2] by linarith then have "2 * (card P\<^sub>2 + card (wrap B\<^sub>2)) \<le> card (\<Union>P\<^sub>2) + card B\<^sub>2 + 1" using \<open>card (wrap B\<^sub>2) \<le> card B\<^sub>2\<close> by simp then have "2 * (card (P\<^sub>2 \<union> wrap B\<^sub>2)) \<le> card (\<Union>P\<^sub>2 \<union> B\<^sub>2) + 1" using card_Un_disjoint[OF \<open>finite (\<Union>P\<^sub>2)\<close> \<open>finite B\<^sub>2\<close> DISJNT]
      and card_Un_disjoint[OF \<open>finite P\<^sub>2\<close> \<open>finite (wrap B\<^sub>2)\<close> DISJNT2] by argo then have "2 * (card (P\<^sub>2 \<union> wrap B\<^sub>2)) \<le> card (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2)) + 1" by (cases \<open>B\<^sub>2 = {}\<close>) (auto simp: Un_commute) then show "2 * (card (P\<^sub>2 \<union> wrap B\<^sub>2)) \<le> card P\<^sub>1 + 1" using assms(3) bij_betw_same_card unfolding bij_exists_def by metis qed subsubsection \<open>Proving the Approximation Factor\<close> text \<open>We define \<open>inv\<^sub>2\<close> as it is defined in the article.
      These conjuncts allow us to prove the desired approximation factor.\<close> definition inv\<^sub>2 :: "'a set set \<Rightarrow> 'a set set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<longleftrightarrow> inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<comment> \<open>\<open>inv\<^sub>1\<close> holds for the partial solution\<close>
                       \<and> (V \<inter> L \<noteq> {} \<longrightarrow> (\<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {})) \<comment> \<open>If there are still large objects left, then every bin of the first partial solution must contain a large object\<close>
                       \<and> bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2)) \<comment> \<open>There exists a bijective function between the bins of the first partial solution and the objects of the second one\<close>
                       \<and> (2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)) \<comment> \<open>There are at most twice as many bins in \<open>P\<^sub>2\<close> as there are objects in \<open>P\<^sub>2\<close>\<close>" lemma inv\<^sub>2E:
  assumes "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
  shows "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
    and "V \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}"
    and "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
    and "2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)" using assms unfolding inv\<^sub>2_def by blast+ lemma inv\<^sub>2I:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
    and "V \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}"
    and "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
    and "2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)"
  shows "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" using assms unfolding inv\<^sub>2_def by blast text \<open>If \<open>P\<close> is a correct solution of the bin packing problem, \<open>inv\<^sub>2\<close> holds for the partial solution,
      and there are no more small objects left to be distributed, then the amount of bins of the partial solution
      is no larger than \<open>3 / 2\<close> of the amount of bins in \<open>P\<close>. This proof strongly follows the proof in
      \<open>Theorem 4.1\<close> of the article @{cite BerghammerR03}.\<close> lemma bin_packing_lower_bound_card:
  assumes "V \<inter> S = {}" "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "bp P"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) \<le> 3 / 2 * card P" proof (cases \<open>V = {}\<close>) note invrules = inv\<^sub>2E[OF assms(2)] case True then have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})
           = card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)" by simp also have "... \<le> card (P\<^sub>1 \<union> wrap B\<^sub>1) + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using card_Un_le[of \<open>P\<^sub>1 \<union> wrap B\<^sub>1\<close>] by (simp add: Un_assoc) also have "... \<le> card P + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using P\<^sub>1_B\<^sub>1_lower_bound_card[OF assms(3) invrules(1,3)] by simp also have "... \<le> card P + card P / 2" using P\<^sub>2_B\<^sub>2_lower_bound_P\<^sub>1[OF invrules(1,4,3)]
      and P\<^sub>1_lower_bound_card[OF assms(3) invrules(1,3)] by linarith finally show ?thesis by linarith next note invrules = inv\<^sub>2E[OF assms(2)] case False have "U = S \<union> L" using S_def L_def by blast then have *: "V = V \<inter> L" using bpE(3)[OF inv\<^sub>1E(1)[OF invrules(1)]]
      and assms(1) by blast with False have NE: "V \<inter> L \<noteq> {}" by simp have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})
      = card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L} \<union> P\<^sub>2 \<union> wrap B\<^sub>2)" using * by (simp add: Un_commute Un_assoc) also have "... \<le> card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}) + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using card_Un_le[of \<open>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}\<close>] by (simp add: Un_assoc) also have "... \<le> card P + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using L_bins_lower_bound_card[OF assms(3) invrules(1) invrules(2)[OF NE]] by linarith also have "... \<le> card P + card P / 2" using P\<^sub>2_B\<^sub>2_lower_bound_P\<^sub>1[OF invrules(1,4,3)]
      and P\<^sub>1_lower_bound_card[OF assms(3) invrules(1,3)] by linarith finally show ?thesis by linarith qed text \<open>We define \<open>inv\<^sub>3\<close> as it is defined in the article.
      This final conjunct allows us to prove that the invariant will be maintained by the algorithm.\<close> definition inv\<^sub>3 :: "'a set set \<Rightarrow> 'a set set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<longleftrightarrow> inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<and> B\<^sub>2 \<subseteq> S" lemma inv\<^sub>3E:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
  shows "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" and "B\<^sub>2 \<subseteq> S" using assms unfolding inv\<^sub>3_def by blast+ lemma inv\<^sub>3I:
  assumes "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" and "B\<^sub>2 \<subseteq> S"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" using assms unfolding inv\<^sub>3_def by blast lemma loop_init:
  "inv\<^sub>3 {} {} {} {} U" proof - have *: "inv\<^sub>1 {} {} {} {} U" unfolding bp_def partition_on_def pairwise_def wrap_def inv\<^sub>1_def using weight by auto have "bij_exists {} (\<Union> ({} \<union> wrap {}))" using bij_betwI' unfolding bij_exists_def by fastforce from inv\<^sub>2I[OF * _ this] have "inv\<^sub>2 {} {} {} {} U" by auto from inv\<^sub>3I[OF this] show ?thesis by blast qed text \<open>If \<open>B\<^sub>1\<close> is empty and there are no large objects left, then \<open>inv\<^sub>3\<close> will be maintained
      if \<open>B\<^sub>1\<close> is initialized with \<open>u \<in> V \<inter> S\<close>.\<close> lemma loop_stepA:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 = {}" "V \<inter> L = {}" "u \<in> V \<inter> S"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] have WEIGHT: "W B\<^sub>1 + w u \<le> c" using S_def assms(2,4) by simp from assms(4) have "u \<in> V" by blast from inv\<^sub>1_stepA[OF invrules(1) this WEIGHT] assms(2) have 1: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" by simp have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap {u}. B \<inter> L \<noteq> {}" using assms(3) by blast from inv\<^sub>2I[OF 1 2] invrules have "inv\<^sub>2 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] . qed text \<open>If \<open>B\<^sub>1\<close> is empty and there are large objects left, then \<open>inv\<^sub>3\<close> will be maintained
      if \<open>B\<^sub>1\<close> is initialized with \<open>u \<in> V \<inter> L\<close>.\<close> lemma loop_stepB:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 = {}" "u \<in> V \<inter> L"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] have WEIGHT: "W B\<^sub>1 + w u \<le> c" using L_def weight assms(2,3) by simp from assms(3) have "u \<in> V" by blast from inv\<^sub>1_stepA[OF invrules(1) this WEIGHT] assms(2) have 1: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" by simp have "\<forall>B\<in>P\<^sub>1. B \<inter> L \<noteq> {}" using assms(3) invrules(2) by blast then have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap {u}. B \<inter> L \<noteq> {}" using assms(3) by (metis Int_iff UnE empty_iff insertE singletonI wrap_not_empty) from inv\<^sub>2I[OF 1 2] invrules have "inv\<^sub>2 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] . qed text \<open>If \<open>B\<^sub>1\<close> is not empty and \<open>u \<in> V \<inter> S\<close> does not exceed its maximum capacity, then \<open>inv\<^sub>3\<close>
      will be maintained if \<open>B\<^sub>1\<close> and \<open>{u}\<close> are replaced with \<open>B\<^sub>1 \<union> {u}\<close>.\<close> lemma loop_stepC:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 \<noteq> {}" "u \<in> V \<inter> S" "W B\<^sub>1 + w(u) \<le> c"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})" proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] from assms(3) have "u \<in> V" by blast from inv\<^sub>1_stepA[OF invrules(1) this assms(4)] have 1: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})" . have "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}" using invrules(2) by blast then have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}). B \<inter> L \<noteq> {}" by (metis Int_commute Un_empty_right Un_insert_right assms(2) disjoint_insert(2) insert_iff wrap_not_empty) from inv\<^sub>2I[OF 1 2] invrules have "inv\<^sub>2 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})" by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] . qed text \<open>If \<open>B\<^sub>1\<close> is not empty and \<open>u \<in> V \<inter> S\<close> does exceed its maximum capacity but not the capacity of \<open>B\<^sub>2\<close>,
      then \<open>inv\<^sub>3\<close> will be maintained if \<open>B\<^sub>1\<close> is added to \<open>P\<^sub>1\<close> and emptied, and \<open>B\<^sub>2\<close> and \<open>{u}\<close> are replaced with \<open>B\<^sub>2 \<union> {u}\<close>.\<close> lemma loop_stepD:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 \<noteq> {}" "u \<in> V \<inter> S" "W B\<^sub>1 + w(u) > c" "W B\<^sub>2 + w(u) \<le> c"
  shows "inv\<^sub>3 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})" proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] from assms(3) have "u \<in> V" by blast from inv\<^sub>1_stepB[OF invrules(1) this assms(5)] have 1: "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})" . have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}. B \<inter> L \<noteq> {}" using invrules(2) unfolding wrap_empty by blast from invrules(3) obtain f where f_def: "bij_betw f P\<^sub>1 (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" "\<forall>B\<in>P\<^sub>1. c < W B + w (f B)" unfolding bij_exists_def by blast have "B\<^sub>1 \<notin> P\<^sub>1" using inv\<^sub>1E(3)[OF invrules(1)] by blast have "u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" using inv\<^sub>1E(2)[OF invrules(1)] assms(3) by blast then have "(\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}))) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}}))" by (metis Sup_empty Un_assoc Union_Un_distrib ccpo_Sup_singleton wrap_empty wrap_not_empty) also have "... = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" by simp finally have UN: "(\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}))) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" . have "wrap B\<^sub>1 = {B\<^sub>1}" using wrap_not_empty[of B\<^sub>1] assms(2) by simp let ?f = "f (B\<^sub>1 := u)" have BIJ: "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})))" unfolding wrap_empty \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> UN using f_def(1) \<open>B\<^sub>1 \<notin> P\<^sub>1\<close> \<open>u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))\<close> by (metis (no_types, lifting) bij_betw_cong fun_upd_other fun_upd_same notIn_Un_bij_betw3) have "c < W B\<^sub>1 + w (?f B\<^sub>1)" using assms(4) by simp then have "(\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" unfolding \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> using f_def(2) by simp with BIJ have "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})))
              \<and> (\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" by blast then have 3: "bij_exists (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})))" unfolding bij_exists_def by blast from inv\<^sub>2I[OF 1 2 3] have "inv\<^sub>2 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})" using invrules(4) by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] assms(3) by blast qed text \<open>If the maximum capacity of \<open>B\<^sub>2\<close> is exceeded by \<open>u \<in> V \<inter> S\<close>,
      then \<open>B\<^sub>2\<close> must contain at least two objects.\<close> lemma B\<^sub>2_at_least_two_objects:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V \<inter> S" "W B\<^sub>2 + w(u) > c"
  shows "2 \<le> card B\<^sub>2" proof (rule ccontr, simp add: not_le) have FINITE: "finite B\<^sub>2" using inv\<^sub>1E(1)[OF inv\<^sub>2E(1)[OF inv\<^sub>3E(1)[OF assms(1)]]] by (metis (no_types, lifting) Finite_Set.finite.simps U_Finite Union_Un_distrib bpE(3) ccpo_Sup_singleton finite_Un wrap_not_empty) assume "card B\<^sub>2 < 2" then consider (0) "card B\<^sub>2 = 0" | (1) "card B\<^sub>2 = 1" by linarith then show False proof cases case 0 then have "B\<^sub>2 = {}" using FINITE by simp then show ?thesis using assms(2,3) S_def by simp next case 1 then obtain v where "B\<^sub>2 = {v}" using card_1_singletonE by auto with inv\<^sub>3E(2)[OF assms(1)] have "2 * w v \<le> c" using S_def by simp moreover from \<open>B\<^sub>2 = {v}\<close> have "W B\<^sub>2 = w v" by simp ultimately show ?thesis using assms(2,3) S_def by simp qed qed text \<open>If \<open>B\<^sub>1\<close> is not empty and \<open>u \<in> V \<inter> S\<close> exceeds the maximum capacity of both \<open>B\<^sub>1\<close> and \<open>B\<^sub>2\<close>,
      then \<open>inv\<^sub>3\<close> will be maintained if \<open>B\<^sub>1\<close> and \<open>B\<^sub>2\<close> are added to \<open>P\<^sub>1\<close> and \<open>P\<^sub>2\<close> respectively,
      emptied, and \<open>B\<^sub>2\<close> initialized with \<open>u\<close>.\<close> lemma loop_stepE:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 \<noteq> {}" "u \<in> V \<inter> S" "W B\<^sub>1 + w(u) > c" "W B\<^sub>2 + w(u) > c"
  shows "inv\<^sub>3 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})" proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] from assms(3) have "u \<in> V" by blast from inv\<^sub>1_stepC[OF invrules(1) this] have 1: "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})" . have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}. B \<inter> L \<noteq> {}" using invrules(2) unfolding wrap_empty by blast from invrules(3) obtain f where f_def: "bij_betw f P\<^sub>1 (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" "\<forall>B\<in>P\<^sub>1. c < W B + w (f B)" unfolding bij_exists_def by blast have "B\<^sub>1 \<notin> P\<^sub>1" using inv\<^sub>1E(3)[OF invrules(1)] by blast have "u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" using inv\<^sub>1E(2)[OF invrules(1)] assms(3) by blast have "(\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u})) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}}))" unfolding wrap_def by simp also have "... = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" by simp finally have UN: "(\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u})) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" . have "wrap B\<^sub>1 = {B\<^sub>1}" using wrap_not_empty[of B\<^sub>1] assms(2) by simp let ?f = "f (B\<^sub>1 := u)" have BIJ: "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}))" unfolding wrap_empty \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> UN using f_def(1) \<open>B\<^sub>1 \<notin> P\<^sub>1\<close> \<open>u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))\<close> by (metis (no_types, lifting) bij_betw_cong fun_upd_other fun_upd_same notIn_Un_bij_betw3) have "c < W B\<^sub>1 + w (?f B\<^sub>1)" using assms(4) by simp then have "(\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" unfolding \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> using f_def(2) by simp with BIJ have "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}))
              \<and> (\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" by blast then have 3: "bij_exists (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}))" unfolding bij_exists_def by blast have 4: "2 * card (P\<^sub>2 \<union> wrap B\<^sub>2) \<le> card (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" proof - note bprules = bpE[OF inv\<^sub>1E(1)[OF invrules(1)]] have "pairwise disjnt (P\<^sub>2 \<union> wrap B\<^sub>2)" using bprules(1) pairwise_subset by blast moreover have "B\<^sub>2 \<notin> P\<^sub>2" using inv\<^sub>1E(4)[OF invrules(1)] by simp ultimately have DISJNT: "\<Union>P\<^sub>2 \<inter> B\<^sub>2 = {}" by (auto, metis (no_types, hide_lams) sup_bot.right_neutral Un_insert_right disjnt_iff mk_disjoint_insert pairwise_insert wrap_Un) have "finite (\<Union>P\<^sub>2)" using U_Finite bprules(3) by auto have "finite B\<^sub>2" using inv\<^sub>1E(1)[OF invrules(1)] bp_bins_finite wrap_not_empty by blast have "2 * card (P\<^sub>2 \<union> wrap B\<^sub>2) \<le> 2 * (card P\<^sub>2 + card (wrap B\<^sub>2))" using card_Un_le[of P\<^sub>2 \<open>wrap B\<^sub>2\<close>] by simp also have "... \<le> 2 * card P\<^sub>2 + 2" using wrap_card by auto also have "... \<le> card (\<Union> P\<^sub>2) + 2" using invrules(4) by simp also have "... \<le> card (\<Union> P\<^sub>2) + card B\<^sub>2" using B\<^sub>2_at_least_two_objects[OF assms(1,3,5)] by simp also have "... = card (\<Union> (P\<^sub>2 \<union> {B\<^sub>2}))" using DISJNT card_Un_disjoint[OF \<open>finite (\<Union>P\<^sub>2)\<close> \<open>finite B\<^sub>2\<close>] by (simp add: Un_commute) also have "... = card (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" by (cases \<open>B\<^sub>2 = {}\<close>) auto finally show ?thesis . qed from inv\<^sub>2I[OF 1 2 3 4] have "inv\<^sub>2 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})" . from inv\<^sub>3I[OF this] show ?thesis using assms(3) by blast qed text \<open>The bin packing algorithm as it is proposed in the article @{cite BerghammerR03}.
      \<open>P\<close> will not only be a correct solution of the bin packing problem, but the amount of bins
      will be a lower bound for \<open>3 / 2\<close> of the amount of bins of any correct solution \<open>Q\<close>, and thus
      guarantee an approximation factor of \<open>3 / 2\<close> for the optimum.\<close> lemma bp_approx:
"VARS P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u
  {True}
  P\<^sub>1 := {}; P\<^sub>2 := {}; B\<^sub>1 := {}; B\<^sub>2 := {}; V := U;
  WHILE V \<inter> S \<noteq> {} INV {inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V} DO 
    IF B\<^sub>1 \<noteq> {}
    THEN u := (SOME u. u \<in> V \<inter> S)
    ELSE IF V \<inter> L \<noteq> {}
         THEN u := (SOME u. u \<in> V \<inter> L)
         ELSE u := (SOME u. u \<in> V \<inter> S) FI FI;
    V := V - {u};
    IF W(B\<^sub>1) + w(u) \<le> c
    THEN B\<^sub>1 := B\<^sub>1 \<union> {u}
    ELSE IF W(B\<^sub>2) + w(u) \<le> c
         THEN B\<^sub>2 := B\<^sub>2 \<union> {u}
         ELSE P\<^sub>2 := P\<^sub>2 \<union> wrap B\<^sub>2; B\<^sub>2 := {u} FI;
         P\<^sub>1 := P\<^sub>1 \<union> wrap B\<^sub>1; B\<^sub>1 := {} FI
  OD;
  P := P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} | v. v \<in> V}
  {bp P \<and> (\<forall>Q. bp Q \<longrightarrow> card P \<le> 3 / 2 * card Q)}" proof (vcg, goal_cases) case (1 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u) then show ?case by (simp add: loop_init) next case (2 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u) then have INV: "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" .. let ?s = "SOME u. u \<in> V \<inter> S" let ?l = "SOME u. u \<in> V \<inter> L" have LIN: "V \<inter> L \<noteq> {} \<Longrightarrow> ?l \<in> V \<inter> L" using some_in_eq by metis then have LWEIGHT: "V \<inter> L \<noteq> {} \<Longrightarrow> w ?l \<le> c" using L_def weight by blast from 2 have "V \<inter> S \<noteq> {}" .. then have IN: "?s \<in> V \<inter> S" using some_in_eq by metis then have "w ?s \<le> c" using S_def by simp then show ?case using LWEIGHT loop_stepA[OF INV _ _ IN] loop_stepB[OF INV _ LIN] loop_stepC[OF INV _ IN]
      and loop_stepD[OF INV _ IN] loop_stepE[OF INV _ IN] by (cases \<open>B\<^sub>1 = {}\<close>, cases \<open>V \<inter> L = {}\<close>) auto next case (3 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u) then have INV: "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" and EMPTY: "V \<inter> S = {}" by blast+ from inv\<^sub>1E(1)[OF inv\<^sub>2E(1)[OF inv\<^sub>3E(1)[OF INV]]] and bin_packing_lower_bound_card[OF EMPTY inv\<^sub>3E(1)[OF INV]] show ?case by blast qed end (* BinPacking *) subsection \<open>The Full Linear Time Version of the Proposed Algorithm\<close> text \<open>Finally, we prove the Algorithm proposed on page 78 of the article @{cite BerghammerR03}.
      This version generates the S and L sets beforehand and uses them directly to calculate the solution,
      thus removing the need for intersection operations, and ensuring linear time if we can
      perform \<open>insertion, removal, and selection of an element, the union of two sets,
      and the emptiness test in constant time\<close> @{cite BerghammerR03}.\<close> locale BinPacking_Complete =
  fixes U :: "'a set" \<comment> \<open>A finite, non-empty set of objects\<close>
    and w :: "'a \<Rightarrow> real" \<comment> \<open>A mapping from objects to their respective weights (positive real numbers)\<close>
    and c :: nat \<comment> \<open>The maximum capacity of a bin (as a natural number)\<close>
  assumes weight: "\<forall>u \<in> U. 0 < w(u) \<and> w(u) \<le> c"
      and U_Finite: "finite U"
      and U_NE: "U \<noteq> {}"
begin text \<open>The correctness proofs will be identical to the ones of the simplified algorithm.\<close> abbreviation W :: "'a set \<Rightarrow> real" where
  "W B \<equiv> (\<Sum>u \<in> B. w(u))" definition bp :: "'a set set \<Rightarrow> bool" where
  "bp P \<longleftrightarrow> partition_on U P \<and> (\<forall>B \<in> P. W(B) \<le> c)" lemma bpE:
  assumes "bp P"
  shows "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c" using assms unfolding bp_def partition_on_def by blast+ lemma bpI:
  assumes "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"
  shows "bp P" using assms unfolding bp_def partition_on_def by blast definition inv\<^sub>1 :: "'a set set \<Rightarrow> 'a set set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<longleftrightarrow> bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) \<comment> \<open>A correct solution to the bin packing problem\<close>
                       \<and> \<Union>(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - V \<comment> \<open>The partial solution does not contain objects that have not yet been assigned\<close>
                       \<and> B\<^sub>1 \<notin> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) \<comment> \<open>\<open>B\<^sub>1\<close> is distinct from all the other bins\<close>
                       \<and> B\<^sub>2 \<notin> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2) \<comment> \<open>\<open>B\<^sub>2\<close> is distinct from all the other bins\<close>
                       \<and> (P\<^sub>1 \<union> wrap B\<^sub>1) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {} \<comment> \<open>The first and second partial solutions are disjoint from each other.\<close>" lemma inv\<^sub>1E:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
  shows "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})"
    and "\<Union>(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - V"
    and "B\<^sub>1 \<notin> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)"
    and "B\<^sub>2 \<notin> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2)"
    and "(P\<^sub>1 \<union> wrap B\<^sub>1) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}" using assms unfolding inv\<^sub>1_def by auto lemma inv\<^sub>1I:
  assumes "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})"
    and "\<Union>(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - V"
    and "B\<^sub>1 \<notin> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)"
    and "B\<^sub>2 \<notin> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2)"
    and "(P\<^sub>1 \<union> wrap B\<^sub>1) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}"
  shows "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" using assms unfolding inv\<^sub>1_def by blast lemma wrap_Un [simp]: "wrap (M \<union> {x}) = {M \<union> {x}}" unfolding wrap_def by simp lemma wrap_empty [simp]: "wrap {} = {}" unfolding wrap_def by simp lemma wrap_not_empty [simp]: "M \<noteq> {} \<longleftrightarrow> wrap M = {M}" unfolding wrap_def by simp lemma inv\<^sub>1_stepA:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V" "W(B\<^sub>1) + w(u) \<le> c"
  shows "inv\<^sub>1 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})" proof - note invrules = inv\<^sub>1E[OF assms(1)] and bprules = bpE[OF invrules(1)]

  \<comment> \<open>Rule 1: Pairwise Disjoint\<close> have NOTIN: "\<forall>M \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. u \<notin> M" using invrules(2) assms(2) by blast have "{{v} |v. v \<in> V} = {{u}} \<union> {{v} |v. v \<in> V - {u}}" using assms(2) by blast then have "pairwise disjnt (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> ({{u}} \<union> {{v} |v. v \<in> V - {u}}))" using bprules(1) assms(2) by simp then have "pairwise disjnt (wrap B\<^sub>1 \<union> {{u}} \<union> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}})" by (simp add: Un_commute) then have assm: "pairwise disjnt (wrap B\<^sub>1 \<union> {{u}} \<union> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by (simp add: Un_assoc) have "pairwise disjnt ({B\<^sub>1 \<union> {u}} \<union> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" proof (cases \<open>B\<^sub>1 = {}\<close>) case True with assm show ?thesis by simp next case False with assm have assm: "pairwise disjnt ({B\<^sub>1} \<union> {{u}} \<union> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by simp from NOTIN have "{u} \<notin> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}" by blast from pairwise_disjnt_Un[OF assm _ this] invrules(2,3) show ?thesis using False by auto qed then have 1: "pairwise disjnt (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}})" unfolding wrap_Un by simp

  \<comment> \<open>Rule 2: No empty sets\<close> from bprules(2) have 2: "{} \<notin> P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}" unfolding wrap_def by simp

  \<comment> \<open>Rule 3: Union preserved\<close> from bprules(3) have "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}}) = U" using assms(2) by blast then have 3: "\<Union> (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}) = U" unfolding wrap_def by force

  \<comment> \<open>Rule 4: Weights below capacity\<close> have "0 < w u" using weight assms(2) bprules(3) by blast have "finite B\<^sub>1" using bprules(3) U_Finite by (cases \<open>B\<^sub>1 = {}\<close>) auto then have "W (B\<^sub>1 \<union> {u}) \<le> W B\<^sub>1 + w u" using \<open>0 < w u\<close> by (cases \<open>u \<in> B\<^sub>1\<close>) (auto simp: insert_absorb) also have "... \<le> c" using assms(3) . finally have "W (B\<^sub>1 \<union> {u}) \<le> c" . then have "\<forall>B \<in> wrap (B\<^sub>1 \<union> {u}). W B \<le> c" unfolding wrap_Un by blast moreover have "\<forall>B\<in>P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" using bprules(4) by blast ultimately have 4: "\<forall>B\<in>P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" by blast from bpI[OF 1 2 3 4] have 1: "bp (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}})" .

  \<comment> \<open>Auxiliary information is preserved\<close> have "u \<in> U" using assms(2) bprules(3) by blast then have R: "U - (V - {u}) = U - V \<union> {u}" by blast have L: "\<Union> (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = \<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) \<union> {u}" unfolding wrap_def using NOTIN by auto have 2: "\<Union> (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - (V - {u})" unfolding L R invrules(2) .. have 3: "B\<^sub>1 \<union> {u} \<notin> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2" using NOTIN by auto have 4: "B\<^sub>2 \<notin> P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2" using invrules(4) NOTIN unfolding wrap_def by fastforce have 5: "(P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u})) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}" using invrules(5) NOTIN unfolding wrap_Un by auto from inv\<^sub>1I[OF 1 2 3 4 5] show ?thesis . qed lemma inv\<^sub>1_stepB:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V" "W B\<^sub>2 + w u \<le> c"
  shows "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})" proof - note invrules = inv\<^sub>1E[OF assms(1)] and bprules = bpE[OF invrules(1)] have NOTIN: "\<forall>M \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. u \<notin> M" using invrules(2) assms(2) by blast have "{{v} |v. v \<in> V} = {{u}} \<union> {{v} |v. v \<in> V - {u}}" using assms(2) by blast then have "pairwise disjnt (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}})" using bprules(1) assms(2) by simp then have assm: "pairwise disjnt (wrap B\<^sub>2 \<union> {{u}} \<union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by (simp add: Un_assoc Un_commute) have "pairwise disjnt ({B\<^sub>2 \<union> {u}} \<union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" proof (cases \<open>B\<^sub>2 = {}\<close>) case True with assm show ?thesis by simp next case False with assm have assm: "pairwise disjnt ({B\<^sub>2} \<union> {{u}} \<union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by simp from NOTIN have "{u} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}" by blast from pairwise_disjnt_Un[OF assm _ this] invrules(2,4) show ?thesis using False by auto qed then have 1: "pairwise disjnt (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}})" unfolding wrap_Un by simp

  \<comment> \<open>Rule 2: No empty sets\<close> from bprules(2) have 2: "{} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}}" unfolding wrap_def by simp

  \<comment> \<open>Rule 3: Union preserved\<close> from bprules(3) have "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}}) = U" using assms(2) by blast then have 3: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}}) = U" unfolding wrap_def by force

  \<comment> \<open>Rule 4: Weights below capacity\<close> have "0 < w u" using weight assms(2) bprules(3) by blast have "finite B\<^sub>2" using bprules(3) U_Finite by (cases \<open>B\<^sub>2 = {}\<close>) auto then have "W (B\<^sub>2 \<union> {u}) \<le> W B\<^sub>2 + w u" using \<open>0 < w u\<close> by (cases \<open>u \<in> B\<^sub>2\<close>) (auto simp: insert_absorb) also have "... \<le> c" using assms(3) . finally have "W (B\<^sub>2 \<union> {u}) \<le> c" . then have "\<forall>B \<in> wrap (B\<^sub>2 \<union> {u}). W B \<le> c" unfolding wrap_Un by blast moreover have "\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" using bprules(4) by blast ultimately have 4: "\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" by auto from bpI[OF 1 2 3 4] have 1: "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}})" .

  \<comment> \<open>Auxiliary information is preserved\<close> have "u \<in> U" using assms(2) bprules(3) by blast then have R: "U - (V - {u}) = U - V \<union> {u}" by blast have L: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})) = \<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap B\<^sub>2) \<union> {u}" unfolding wrap_def using NOTIN by auto have 2: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})) = U - (V - {u})" unfolding L R using invrules(2) by simp have 3: "{} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})" using bpE(2)[OF 1] by simp have 4: "B\<^sub>2 \<union> {u} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2" using NOTIN by auto have 5: "(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}) \<inter> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})) = {}" using invrules(5) NOTIN unfolding wrap_empty wrap_Un by auto from inv\<^sub>1I[OF 1 2 3 4 5] show ?thesis . qed lemma inv\<^sub>1_stepC:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V"
  shows "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})" proof - note invrules = inv\<^sub>1E[OF assms(1)]
  \<comment> \<open>Rule 1-4: Correct Bin Packing\<close> have "P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u} \<union> {{v} |v. v \<in> V - {u}}
      = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}}" by (metis (no_types, lifting) Un_assoc Un_empty_right insert_not_empty wrap_empty wrap_not_empty) also have "... = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}" using assms(2) by auto finally have EQ: "P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u} \<union> {{v} |v. v \<in> V - {u}}
                  = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}" . from invrules(1) have 1: "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u} \<union> {{v} |v. v \<in> V - {u}})" unfolding EQ .

  \<comment> \<open>Auxiliary information is preserved\<close> have NOTIN: "\<forall>M \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. u \<notin> M" using invrules(2) assms(2) by blast have "u \<in> U" using assms(2) bpE(3)[OF invrules(1)] by blast then have R: "U - (V - {u}) = U - V \<union> {u}" by blast have L: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u}) = \<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" unfolding wrap_def using NOTIN by auto have 2: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u}) = U - (V - {u})" unfolding L R using invrules(2) by auto have 3: "{} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u}" using bpE(2)[OF 1] by simp have 4: "{u} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2)" using NOTIN by auto have 5: "(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}) = {}" using invrules(5) NOTIN unfolding wrap_def by force from inv\<^sub>1I[OF 1 2 3 4 5] show ?thesis . qed text \<open>From this point onward, we will require a different approach for proving lower bounds.
      Instead of fixing and assuming the definitions of the \<open>S\<close> and \<open>L\<close> sets, we will introduce
      the abbreviations \<open>S\<^sub>U\<close> and \<open>L\<^sub>U\<close> for any occurrences of the original \<open>S\<close> and \<open>L\<close> sets.
      The union of \<open>S\<close> and \<open>L\<close> can be interpreted as \<open>V\<close>. As a result, occurrences of \<open>V \<inter> S\<close>
      become \<open>(S \<union> L) \<inter> S = S\<close>, and \<open>V \<inter> L\<close> become \<open>(S \<union> L) \<inter> L = L\<close>.
      Occurrences of these sets will have to be replaced appropriately.\<close> abbreviation S\<^sub>U where
  "S\<^sub>U \<equiv> {u \<in> U. w u \<le> c / 2}" abbreviation L\<^sub>U where
  "L\<^sub>U \<equiv> {u \<in> U. c / 2 < w u}" text \<open>As we will remove elements from \<open>S\<close> and \<open>L\<close>, we will only be able to show that they remain
      subsets of \<open>S\<^sub>U\<close> and \<open>L\<^sub>U\<close> respectively.\<close> abbreviation SL where
  "SL S L \<equiv> S \<subseteq> S\<^sub>U \<and> L \<subseteq> L\<^sub>U" lemma bp_bins_finite [simp]:
  assumes "bp P"
  shows "\<forall>B \<in> P. finite B" using bpE(3)[OF assms] U_Finite by (meson Sup_upper finite_subset) lemma bp_sol_finite [simp]:
  assumes "bp P"
  shows "finite P" using bpE(3)[OF assms] U_Finite by (simp add: finite_UnionD)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule finite_subset)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (57%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma only_one_L_per_bin:
  assumes "bp P" "B \<in> P"
  shows "\<forall>x \<in> B. \<forall>y \<in> B. x \<noteq> y \<longrightarrow> x \<notin> L\<^sub>U \<or> y \<notin> L\<^sub>U"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (rule ccontr, simp) assume "\<exists>x\<in>B. \<exists>y\<in>B. x \<noteq> y \<and> y \<in> U \<and> x \<in> U \<and> real c < w x * 2 \<and> real c < w y * 2" then obtain x y where *: "x \<in> B" "y \<in> B" "x \<noteq> y" "x \<in> L\<^sub>U" "y \<in> L\<^sub>U" by auto then have "c < w x + w y" by force have "finite B" using assms by simp have "y \<in> B - {x}" using *(2,3) by blast have "W B = W (B - {x}) + w x" using *(1) \<open>finite B\<close> by (simp add: sum.remove) also have "... = W (B - {x} - {y}) + w x + w y" using \<open>y \<in> B - {x}\<close> \<open>finite B\<close> by (simp add: sum.remove) finally have *: "W B = W (B - {x} - {y}) + w x + w y" . have "\<forall>u \<in> B. 0 < w u" using bpE(3)[OF assms(1)] assms(2) weight by blast then have "0 \<le> W (B - {x} - {y})" by (smt DiffD1 sum_nonneg) with * have "c < W B" using \<open>c < w x + w y\<close> by simp then show False using bpE(4)[OF assms(1)] assms(2) by fastforce qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma only_one_L_per_bin:
  assumes "bp P" "B \<in> P"
  shows "\<forall>x \<in> B. \<forall>y \<in> B. x \<noteq> y \<longrightarrow> x \<notin> L\<^sub>U \<or> y \<notin> L\<^sub>U"
proof -
  fix x y :: 'a
  assume "x \<in> B" "y \<in> B" "x \<noteq> y"
  have "x \<notin> L\<^sub>U \<or> y \<notin> L\<^sub>U"
  using bp[OF "x \<in> B" "y \<in> B"]
  by auto
  thus "\<forall>x \<in> B. \<forall>y \<in> B. x \<noteq> y \<longrightarrow> x \<notin> L\<^sub>U \<or> y \<notin> L\<^sub>U"
  by blast
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.53
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (58%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma L_lower_bound_card:
  assumes "bp P"
  shows "card L\<^sub>U \<le> card P"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "\<forall>x \<in> L\<^sub>U. \<exists>B \<in> P. x \<in> B" using bpE(3)[OF assms] by blast then obtain f where f_def: "\<forall>u \<in> L\<^sub>U. u \<in> f u \<and> f u \<in> P" by metis then have "inj_on f L\<^sub>U" unfolding inj_on_def using only_one_L_per_bin[OF assms] by blast then have card_eq: "card L\<^sub>U = card (f ` L\<^sub>U)" by (simp add: card_image) have "f ` L\<^sub>U \<subseteq> P" using f_def by blast moreover have "finite P" using assms by simp ultimately have "card (f ` L\<^sub>U) \<le> card P" by (simp add: card_mono) then show ?thesis unfolding card_eq . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma L_lower_bound_card:
  assumes "bp P"
  shows "card L\<^sub>U \<le> card P"
proof -
  have "card L\<^sub>U = card (L\<^sub>U \<cap> P) + card (L\<^sub>U \<cap> P\<^complement>)" by simp
  also have "card (L\<^sub>U \<cap> P) \<le> card P" by simp
  moreover have "card (L\<^sub>U \<cap> P\<^complement>) = 0" by simp
  ultimately show "card L\<^sub>U \<le> card P" by arith
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (59%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma subset_bp_card:
  assumes "bp P" "M \<subseteq> P" "\<forall>B \<in> M. B \<inter> L\<^sub>U \<noteq> {}"
  shows "card M \<le> card L\<^sub>U"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "\<forall>B \<in> M. \<exists>u \<in> L\<^sub>U. u \<in> B" using assms(3) by fast then have "\<exists>f. \<forall>B \<in> M. f B \<in> L\<^sub>U \<and> f B \<in> B" by metis then obtain f where f_def: "\<forall>B \<in> M. f B \<in> L\<^sub>U \<and> f B \<in> B" .. have "inj_on f M" proof (rule ccontr) assume "\<not> inj_on f M" then have "\<exists>x \<in> M. \<exists>y \<in> M. x \<noteq> y \<and> f x = f y" unfolding inj_on_def by blast then obtain x y where *: "x \<in> M" "y \<in> M" "x \<noteq> y" "f x = f y" by blast then have "\<exists>u. u \<in> x \<and> u \<in> y" using f_def by metis then have "x \<inter> y \<noteq> {}" by blast moreover have "pairwise disjnt M" using pairwise_subset[OF bpE(1)[OF assms(1)] assms(2)] . ultimately show False using * unfolding pairwise_def disjnt_def by simp qed moreover have "finite L\<^sub>U" using U_Finite by auto moreover have "f ` M \<subseteq> L\<^sub>U" using f_def by blast ultimately show ?thesis using card_inj_on_le by blast qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma subset_bp_card:
  assumes "bp P" "M \<subseteq> P" "\<forall>B \<in> M. B \<inter> L\<^sub>U \<noteq> {}"
  shows "card M \<le> card L\<^sub>U"
proof -
  have "card M \<le> card (M \<inter> L\<^sub>U)" by (rule card_mono)
  also have "card (M \<inter> L\<^sub>U) \<le> card L\<^sub>U" by (rule card_mono)
  finally show "card M \<le> card L\<^sub>U" by (rule le_trans)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.49
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (60%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma L_bins_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 (S \<union> L)" "\<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L\<^sub>U \<noteq> {}"
      and SL_def: "SL S L"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> L}) \<le> card P"</h2><br>
<b>Ground proof:</b> <br><pre><code></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume the given conditions:
   - bp P
   - inv<^sub>1 P<^sub>1 P<^sub>2 B<^sub>1 B<^sub>2 (S ∪ L)
   - ∀B ∈ P<^sub>1 ∪ wrap B<^sub>1. B ∩ L<^sub>U ≠ {}
   - SL S L

2. We need to show that card (P<^sub>1 ∪ wrap B<^sub>1 ∪ {v | v ∈ L}) ≤ card P

3. By the definition of cardinality and set operations, we can rewrite the left-hand side of the inequality:
   card (P<^sub>1 ∪ wrap B<^sub>1 ∪ {v | v ∈ L}) = card (P<^sub>1 ∪ wrap B<^sub>1) + card ({v | v ∈ L})

4. Since L is a subset of S, and S is a subset of P<^sub>1 ∪ wrap B<^sub>1, we have:
   card ({v | v ∈ L}) ≤ card (P<^sub>1 ∪ wrap B<^sub>1)

5. Therefore, card (P<^sub>1 ∪ wrap B<^sub>1 ∪ {v | v ∈ L}) ≤ card (P<^sub>1 ∪ wrap B<^sub>1) + card (P<^sub>1 ∪ wrap B<^sub>1)

6. Simplifying the right-hand side, we get:
   2 * card (P<^sub>1 ∪ wrap B<^sub>1)

7. Since card (P<^sub>1 ∪ wrap B<^sub>1) ≤ card P, we have:
   2 * card (P<^sub>1 ∪ wrap B<^sub>1) ≤ 2 * card P

8. Finally, we can conclude that:
   card (P<^sub>1 ∪ wrap B<^sub>1 ∪ {v | v ∈ L}) ≤ card P

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but identifier Proof (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.29
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (61%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sum_Un_eq_sum_sum:
  assumes "bp P"
  shows "(\<Sum>u \<in> U. w u) = (\<Sum>B \<in> P. W B)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have FINITE: "\<forall>B \<in> P. finite B" using assms by simp have DISJNT: "\<forall>A \<in> P. \<forall>B \<in> P. A \<noteq> B \<longrightarrow> A \<inter> B = {}" using bpE(1)[OF assms] unfolding pairwise_def disjnt_def . have "(\<Sum>u \<in> (\<Union>P). w u) = (\<Sum>B \<in> P. W B)" using sum.Union_disjoint[OF FINITE DISJNT] by auto then show ?thesis unfolding bpE(3)[OF assms] . qed text \<open>If \<open>P\<close> is a correct solution of the bin packing problem, then the sum of the weights of the items
      is a lower bound of amount of bins in \<open>P\<close> multiplied by their maximum capacity.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma sum_Un_eq_sum_sum:
  assumes "bp P"
  shows "(\<Sum>u \<in> U. w u) = (\<Sum>B \<in> P. W B)"

proof -
  have "(\<Sum>u \<in> U. w u) = (\<Sum>B \<in> P. W B)" by (rule sum.cong)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.34
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (62%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sum_lower_bound_card:
  assumes "bp P"
  shows "(\<Sum>u \<in> U. w u) \<le> c * card P"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have *: "\<forall>B \<in> P. 0 < W B \<and> W B \<le> c" using bpE(2-4)[OF assms] weight by (metis UnionI assms bp_bins_finite sum_pos) have "(\<Sum>u \<in> U. w u) = (\<Sum>B \<in> P. W B)" using sum_Un_eq_sum_sum[OF assms] . also have "... \<le> (\<Sum>B \<in> P. c)" using sum_mono * by fastforce also have "... = c * card P" by simp finally show ?thesis . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma sum_lower_bound_card:
  assumes "bp P"
  shows "(\<Sum>u \<in> U. w u) \<le> c * card P"
proof -
  have "(\<Sum>u \<in> U. w u) = (\<Sum>u \<in> U. w u) + 0" by simp
  also have "(\<Sum>u \<in> U. w u) + 0 \<le> (\<Sum>u \<in> U. w u) + (\<Sum>u \<in> U. c)" by simp
  also have "(\<Sum>u \<in> U. w u) + (\<Sum>u \<in> U. c) \<le> (\<Sum>u \<in> U. w u + c)" by simp
  also have "(\<Sum>u \<in> U. w u + c) \<le> (\<Sum>u \<in> U. c * card P)" by simp
  finally show "(\<Sum>u \<in> U. w u) \<le> c * card P" by simp
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (63%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bp_NE:
  assumes "bp P"
  shows "P \<noteq> {}"</h2><br>
<b>Ground proof:</b> <br><pre><code>using U_NE bpE(3)[OF assms] by blast</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule bp_def)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (64%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sum_Un_ge:
  fixes f :: "_ \<Rightarrow> real"
  assumes "finite M" "finite N" "\<forall>B \<in> M \<union> N. 0 < f B"
  shows "sum f M \<le> sum f (M \<union> N)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "0 \<le> sum f N - sum f (M \<inter> N)" using assms by (smt DiffD1 inf.cobounded2 UnCI sum_mono2) then have "sum f M \<le> sum f M + sum f N - sum f (M \<inter> N)" by simp also have "... = sum f (M \<union> N)" using sum_Un[OF assms(1,2), symmetric] . finally show ?thesis . qed text \<open>If \<open>bij_exists\<close> holds, one can obtain a function which is bijective between the bins in \<open>P\<close>
and the objects in \<open>V\<close> such that an object returned by the function would cause the bin to
exceed its capacity.\<close> definition bij_exists :: "'a set set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "bij_exists P V = (\<exists>f. bij_betw f P V \<and> (\<forall>B \<in> P. W B + w (f B) > c))" text \<open>If \<open>P\<close> is a functionally correct solution of the bin packing problem, \<open>inv\<^sub>1\<close> holds for the
partial solution, and such a bijective function exists between the bins in \<open>P\<^sub>1\<close> and the objects in
@{term "P\<^sub>2 \<union> wrap B\<^sub>2"}, the following strict lower bound can be shown:\<close> lemma P\<^sub>1_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
  shows "card P\<^sub>1 + 1 \<le> card P" proof (cases \<open>P\<^sub>1 = {}\<close>) case True have "finite P" using assms(1) by simp then have "1 \<le> card P" using bp_NE[OF assms(1)] by (metis Nat.add_0_right Suc_diff_1 Suc_le_mono card_gt_0_iff le0 mult_Suc_right nat_mult_1) then show ?thesis unfolding True by simp next note invrules = inv\<^sub>1E[OF assms(2)] case False obtain f where f_def: "bij_betw f P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))" "\<forall>B \<in> P\<^sub>1. W B + w (f B) > c" using assms(3) unfolding bij_exists_def by blast have FINITE: "finite P\<^sub>1" "finite (P\<^sub>2 \<union> wrap B\<^sub>2)" "finite (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)" "finite (wrap B\<^sub>1 \<union> {{v} |v. v \<in> V})" using inv\<^sub>1E(1)[OF assms(2)] bp_sol_finite by blast+ have F: "\<forall>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. finite B" using invrules(1) by simp have D: "\<forall>A \<in> P\<^sub>2 \<union> wrap B\<^sub>2. \<forall>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. A \<noteq> B \<longrightarrow> A \<inter> B = {}" using bpE(1)[OF invrules(1)] unfolding pairwise_def disjnt_def by auto have sum_eq: "W (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) = (\<Sum>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. W B)" using sum.Union_disjoint[OF F D] by auto have "\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}. 0 < W B" using bpE(2,3)[OF invrules(1)] weight by (metis (no_types, lifting) UnionI bp_bins_finite invrules(1) sum_pos) then have "(\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2. W B) \<le> (\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> (wrap B\<^sub>1 \<union> {{v} |v. v \<in> V}). W B)" using sum_Un_ge[OF FINITE(3,4), of W] by blast also have "... = (\<Sum>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}. W B)" by (smt Un_assoc Un_commute) also have "... = W U" using sum_Un_eq_sum_sum[OF invrules(1), symmetric] . finally have *: "(\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2. W B) \<le> W U" .

  \<comment> \<open>This follows from the fourth and final additional conjunct of \<open>inv\<^sub>1\<close> and is necessary to combine the sums of the bins
      of the two partial solutions. This does not inherently follow from the union being a correct solution,
      as this need not be the case if \<open>P\<^sub>1\<close> and \<open>P\<^sub>2 \<union> wrap B\<^sub>2\<close> happened to be equal.\<close> have DISJNT: "P\<^sub>1 \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}" using invrules(5) by blast

  \<comment> \<open>This part of the proof is based on the proof on page 72 of the article @{cite BerghammerR03}.\<close> have "c * card P\<^sub>1 = (\<Sum>B \<in> P\<^sub>1. c)" by simp also have "... < (\<Sum>B \<in> P\<^sub>1. W B + w (f B))" using f_def(2) sum_strict_mono[OF FINITE(1) False] by fastforce also have "... = (\<Sum>B \<in> P\<^sub>1. W B) + (\<Sum>B \<in> P\<^sub>1. w (f B))" by (simp add: Groups_Big.comm_monoid_add_class.sum.distrib) also have "... = (\<Sum>B \<in> P\<^sub>1. W B) + W (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" unfolding sum.reindex_bij_betw[OF f_def(1), of w] .. also have "... = (\<Sum>B \<in> P\<^sub>1. W B) + (\<Sum>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. W B)" unfolding sum_eq .. also have "... = (\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2. W B)" using sum.union_disjoint[OF FINITE(1,2) DISJNT, of W] by (simp add: Un_assoc) also have "... \<le> (\<Sum>u \<in> U. w u)" using * . also have "... \<le> c * card P" using sum_lower_bound_card[OF assms(1)] . finally show ?thesis by (meson discrete nat_mult_less_cancel_disj of_nat_less_imp_less) qed text \<open>As @{thm wrap_card} holds, it follows that the amount of bins in \<open>P\<^sub>1 \<union> wrap B\<^sub>1\<close>
      are a lower bound for the amount of bins in \<open>P\<close>.\<close> lemma P\<^sub>1_B\<^sub>1_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1) \<le> card P" proof - have "card (P\<^sub>1 \<union> wrap B\<^sub>1) \<le> card P\<^sub>1 + card (wrap B\<^sub>1)" using card_Un_le by blast also have "... \<le> card P\<^sub>1 + 1" using wrap_card by simp also have "... \<le> card P" using P\<^sub>1_lower_bound_card[OF assms] . finally show ?thesis . qed text \<open>If \<open>inv\<^sub>1\<close> holds, there are at most half as many bins in \<open>P\<^sub>2\<close> as there are objects in \<open>P\<^sub>2\<close>, and we can again
      obtain a bijective function between the bins in \<open>P\<^sub>1\<close> and the objects of the second partial solution,
      then the amount of bins in the second partial solution are a strict lower bound for half the bins of
      the first partial solution.\<close> lemma P\<^sub>2_B\<^sub>2_lower_bound_P\<^sub>1:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)" "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
  shows "2 * card (P\<^sub>2 \<union> wrap B\<^sub>2) \<le> card P\<^sub>1 + 1" proof - note invrules = inv\<^sub>1E[OF assms(1)] and bprules = bpE[OF invrules(1)] have "pairwise disjnt (P\<^sub>2 \<union> wrap B\<^sub>2)" using bprules(1) pairwise_subset by blast moreover have "B\<^sub>2 \<notin> P\<^sub>2" using invrules(4) by simp ultimately have DISJNT: "\<Union>P\<^sub>2 \<inter> B\<^sub>2 = {}" by (auto, metis (no_types, hide_lams) sup_bot.right_neutral Un_insert_right disjnt_iff mk_disjoint_insert pairwise_insert wrap_Un) have "finite (\<Union>P\<^sub>2)" using U_Finite bprules(3) by auto have "finite B\<^sub>2" using bp_bins_finite[OF invrules(1)] wrap_not_empty by blast have "finite P\<^sub>2" "finite (wrap B\<^sub>2)" using bp_sol_finite[OF invrules(1)] by blast+ have DISJNT2: "P\<^sub>2 \<inter> wrap B\<^sub>2 = {}" unfolding wrap_def using \<open>B\<^sub>2 \<notin> P\<^sub>2\<close> by auto have "card (wrap B\<^sub>2) \<le> card B\<^sub>2" proof (cases \<open>B\<^sub>2 = {}\<close>) case False then have "1 \<le> card B\<^sub>2" by (simp add: leI \<open>finite B\<^sub>2\<close>) then show ?thesis using wrap_card[of B\<^sub>2] by linarith qed simp

  \<comment> \<open>This part of the proof is based on the proof on page 73 of the article @{cite BerghammerR03}.\<close> from assms(2) have "2 * card P\<^sub>2 + 2 * card (wrap B\<^sub>2) \<le> card (\<Union>P\<^sub>2) + card (wrap B\<^sub>2) + 1" using wrap_card[of B\<^sub>2] by linarith then have "2 * (card P\<^sub>2 + card (wrap B\<^sub>2)) \<le> card (\<Union>P\<^sub>2) + card B\<^sub>2 + 1" using \<open>card (wrap B\<^sub>2) \<le> card B\<^sub>2\<close> by simp then have "2 * (card (P\<^sub>2 \<union> wrap B\<^sub>2)) \<le> card (\<Union>P\<^sub>2 \<union> B\<^sub>2) + 1" using card_Un_disjoint[OF \<open>finite (\<Union>P\<^sub>2)\<close> \<open>finite B\<^sub>2\<close> DISJNT]
      and card_Un_disjoint[OF \<open>finite P\<^sub>2\<close> \<open>finite (wrap B\<^sub>2)\<close> DISJNT2] by argo then have "2 * (card (P\<^sub>2 \<union> wrap B\<^sub>2)) \<le> card (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2)) + 1" by (cases \<open>B\<^sub>2 = {}\<close>) (auto simp: Un_commute) then show "2 * (card (P\<^sub>2 \<union> wrap B\<^sub>2)) \<le> card P\<^sub>1 + 1" using assms(3) bij_betw_same_card unfolding bij_exists_def by metis qed subsubsection \<open>Proving the Approximation Factor\<close> text \<open>We define \<open>inv\<^sub>2\<close> as it is defined in the article.
      These conjuncts allow us to prove the desired approximation factor.\<close> definition inv\<^sub>2 :: "'a set set \<Rightarrow> 'a set set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<longleftrightarrow> inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<comment> \<open>\<open>inv\<^sub>1\<close> holds for the partial solution\<close>
                       \<and> (V \<inter> L \<noteq> {} \<longrightarrow> (\<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {})) \<comment> \<open>If there are still large objects left, then every bin of the first partial solution must contain a large object\<close>
                       \<and> bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2)) \<comment> \<open>There exists a bijective function between the bins of the first partial solution and the objects of the second one\<close>
                       \<and> (2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)) \<comment> \<open>There are at most twice as many bins in \<open>P\<^sub>2\<close> as there are objects in \<open>P\<^sub>2\<close>\<close>" lemma inv\<^sub>2E:
  assumes "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
  shows "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
    and "V \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}"
    and "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
    and "2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)" using assms unfolding inv\<^sub>2_def by blast+ lemma inv\<^sub>2I:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
    and "V \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}"
    and "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
    and "2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)"
  shows "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" using assms unfolding inv\<^sub>2_def by blast text \<open>If \<open>P\<close> is a correct solution of the bin packing problem, \<open>inv\<^sub>2\<close> holds for the partial solution,
      and there are no more small objects left to be distributed, then the amount of bins of the partial solution
      is no larger than \<open>3 / 2\<close> of the amount of bins in \<open>P\<close>. This proof strongly follows the proof in
      \<open>Theorem 4.1\<close> of the article @{cite BerghammerR03}.\<close> lemma bin_packing_lower_bound_card:
  assumes "V \<inter> S = {}" "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "bp P"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) \<le> 3 / 2 * card P" proof (cases \<open>V = {}\<close>) note invrules = inv\<^sub>2E[OF assms(2)] case True then have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})
           = card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)" by simp also have "... \<le> card (P\<^sub>1 \<union> wrap B\<^sub>1) + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using card_Un_le[of \<open>P\<^sub>1 \<union> wrap B\<^sub>1\<close>] by (simp add: Un_assoc) also have "... \<le> card P + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using P\<^sub>1_B\<^sub>1_lower_bound_card[OF assms(3) invrules(1,3)] by simp also have "... \<le> card P + card P / 2" using P\<^sub>2_B\<^sub>2_lower_bound_P\<^sub>1[OF invrules(1,4,3)]
      and P\<^sub>1_lower_bound_card[OF assms(3) invrules(1,3)] by linarith finally show ?thesis by linarith next note invrules = inv\<^sub>2E[OF assms(2)] case False have "U = S \<union> L" using S_def L_def by blast then have *: "V = V \<inter> L" using bpE(3)[OF inv\<^sub>1E(1)[OF invrules(1)]]
      and assms(1) by blast with False have NE: "V \<inter> L \<noteq> {}" by simp have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})
      = card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L} \<union> P\<^sub>2 \<union> wrap B\<^sub>2)" using * by (simp add: Un_commute Un_assoc) also have "... \<le> card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}) + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using card_Un_le[of \<open>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> V \<inter> L}\<close>] by (simp add: Un_assoc) also have "... \<le> card P + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using L_bins_lower_bound_card[OF assms(3) invrules(1) invrules(2)[OF NE]] by linarith also have "... \<le> card P + card P / 2" using P\<^sub>2_B\<^sub>2_lower_bound_P\<^sub>1[OF invrules(1,4,3)]
      and P\<^sub>1_lower_bound_card[OF assms(3) invrules(1,3)] by linarith finally show ?thesis by linarith qed text \<open>We define \<open>inv\<^sub>3\<close> as it is defined in the article.
      This final conjunct allows us to prove that the invariant will be maintained by the algorithm.\<close> definition inv\<^sub>3 :: "'a set set \<Rightarrow> 'a set set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<longleftrightarrow> inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<and> B\<^sub>2 \<subseteq> S" lemma inv\<^sub>3E:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
  shows "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" and "B\<^sub>2 \<subseteq> S" using assms unfolding inv\<^sub>3_def by blast+ lemma inv\<^sub>3I:
  assumes "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" and "B\<^sub>2 \<subseteq> S"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" using assms unfolding inv\<^sub>3_def by blast lemma loop_init:
  "inv\<^sub>3 {} {} {} {} U" proof - have *: "inv\<^sub>1 {} {} {} {} U" unfolding bp_def partition_on_def pairwise_def wrap_def inv\<^sub>1_def using weight by auto have "bij_exists {} (\<Union> ({} \<union> wrap {}))" using bij_betwI' unfolding bij_exists_def by fastforce from inv\<^sub>2I[OF * _ this] have "inv\<^sub>2 {} {} {} {} U" by auto from inv\<^sub>3I[OF this] show ?thesis by blast qed text \<open>If \<open>B\<^sub>1\<close> is empty and there are no large objects left, then \<open>inv\<^sub>3\<close> will be maintained
      if \<open>B\<^sub>1\<close> is initialized with \<open>u \<in> V \<inter> S\<close>.\<close> lemma loop_stepA:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 = {}" "V \<inter> L = {}" "u \<in> V \<inter> S"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] have WEIGHT: "W B\<^sub>1 + w u \<le> c" using S_def assms(2,4) by simp from assms(4) have "u \<in> V" by blast from inv\<^sub>1_stepA[OF invrules(1) this WEIGHT] assms(2) have 1: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" by simp have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap {u}. B \<inter> L \<noteq> {}" using assms(3) by blast from inv\<^sub>2I[OF 1 2] invrules have "inv\<^sub>2 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] . qed text \<open>If \<open>B\<^sub>1\<close> is empty and there are large objects left, then \<open>inv\<^sub>3\<close> will be maintained
      if \<open>B\<^sub>1\<close> is initialized with \<open>u \<in> V \<inter> L\<close>.\<close> lemma loop_stepB:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 = {}" "u \<in> V \<inter> L"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] have WEIGHT: "W B\<^sub>1 + w u \<le> c" using L_def weight assms(2,3) by simp from assms(3) have "u \<in> V" by blast from inv\<^sub>1_stepA[OF invrules(1) this WEIGHT] assms(2) have 1: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" by simp have "\<forall>B\<in>P\<^sub>1. B \<inter> L \<noteq> {}" using assms(3) invrules(2) by blast then have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap {u}. B \<inter> L \<noteq> {}" using assms(3) by (metis Int_iff UnE empty_iff insertE singletonI wrap_not_empty) from inv\<^sub>2I[OF 1 2] invrules have "inv\<^sub>2 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (V - {u})" by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] . qed text \<open>If \<open>B\<^sub>1\<close> is not empty and \<open>u \<in> V \<inter> S\<close> does not exceed its maximum capacity, then \<open>inv\<^sub>3\<close>
      will be maintained if \<open>B\<^sub>1\<close> and \<open>{u}\<close> are replaced with \<open>B\<^sub>1 \<union> {u}\<close>.\<close> lemma loop_stepC:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 \<noteq> {}" "u \<in> V \<inter> S" "W B\<^sub>1 + w(u) \<le> c"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})" proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] from assms(3) have "u \<in> V" by blast from inv\<^sub>1_stepA[OF invrules(1) this assms(4)] have 1: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})" . have "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L \<noteq> {}" using invrules(2) by blast then have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}). B \<inter> L \<noteq> {}" by (metis Int_commute Un_empty_right Un_insert_right assms(2) disjoint_insert(2) insert_iff wrap_not_empty) from inv\<^sub>2I[OF 1 2] invrules have "inv\<^sub>2 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})" by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] . qed text \<open>If \<open>B\<^sub>1\<close> is not empty and \<open>u \<in> V \<inter> S\<close> does exceed its maximum capacity but not the capacity of \<open>B\<^sub>2\<close>,
      then \<open>inv\<^sub>3\<close> will be maintained if \<open>B\<^sub>1\<close> is added to \<open>P\<^sub>1\<close> and emptied, and \<open>B\<^sub>2\<close> and \<open>{u}\<close> are replaced with \<open>B\<^sub>2 \<union> {u}\<close>.\<close> lemma loop_stepD:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 \<noteq> {}" "u \<in> V \<inter> S" "W B\<^sub>1 + w(u) > c" "W B\<^sub>2 + w(u) \<le> c"
  shows "inv\<^sub>3 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})" proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] from assms(3) have "u \<in> V" by blast from inv\<^sub>1_stepB[OF invrules(1) this assms(5)] have 1: "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})" . have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}. B \<inter> L \<noteq> {}" using invrules(2) unfolding wrap_empty by blast from invrules(3) obtain f where f_def: "bij_betw f P\<^sub>1 (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" "\<forall>B\<in>P\<^sub>1. c < W B + w (f B)" unfolding bij_exists_def by blast have "B\<^sub>1 \<notin> P\<^sub>1" using inv\<^sub>1E(3)[OF invrules(1)] by blast have "u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" using inv\<^sub>1E(2)[OF invrules(1)] assms(3) by blast then have "(\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}))) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}}))" by (metis Sup_empty Un_assoc Union_Un_distrib ccpo_Sup_singleton wrap_empty wrap_not_empty) also have "... = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" by simp finally have UN: "(\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}))) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" . have "wrap B\<^sub>1 = {B\<^sub>1}" using wrap_not_empty[of B\<^sub>1] assms(2) by simp let ?f = "f (B\<^sub>1 := u)" have BIJ: "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})))" unfolding wrap_empty \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> UN using f_def(1) \<open>B\<^sub>1 \<notin> P\<^sub>1\<close> \<open>u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))\<close> by (metis (no_types, lifting) bij_betw_cong fun_upd_other fun_upd_same notIn_Un_bij_betw3) have "c < W B\<^sub>1 + w (?f B\<^sub>1)" using assms(4) by simp then have "(\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" unfolding \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> using f_def(2) by simp with BIJ have "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})))
              \<and> (\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" by blast then have 3: "bij_exists (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})))" unfolding bij_exists_def by blast from inv\<^sub>2I[OF 1 2 3] have "inv\<^sub>2 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})" using invrules(4) by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] assms(3) by blast qed text \<open>If the maximum capacity of \<open>B\<^sub>2\<close> is exceeded by \<open>u \<in> V \<inter> S\<close>,
      then \<open>B\<^sub>2\<close> must contain at least two objects.\<close> lemma B\<^sub>2_at_least_two_objects:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V \<inter> S" "W B\<^sub>2 + w(u) > c"
  shows "2 \<le> card B\<^sub>2" proof (rule ccontr, simp add: not_le) have FINITE: "finite B\<^sub>2" using inv\<^sub>1E(1)[OF inv\<^sub>2E(1)[OF inv\<^sub>3E(1)[OF assms(1)]]] by (metis (no_types, lifting) Finite_Set.finite.simps U_Finite Union_Un_distrib bpE(3) ccpo_Sup_singleton finite_Un wrap_not_empty) assume "card B\<^sub>2 < 2" then consider (0) "card B\<^sub>2 = 0" | (1) "card B\<^sub>2 = 1" by linarith then show False proof cases case 0 then have "B\<^sub>2 = {}" using FINITE by simp then show ?thesis using assms(2,3) S_def by simp next case 1 then obtain v where "B\<^sub>2 = {v}" using card_1_singletonE by auto with inv\<^sub>3E(2)[OF assms(1)] have "2 * w v \<le> c" using S_def by simp moreover from \<open>B\<^sub>2 = {v}\<close> have "W B\<^sub>2 = w v" by simp ultimately show ?thesis using assms(2,3) S_def by simp qed qed text \<open>If \<open>B\<^sub>1\<close> is not empty and \<open>u \<in> V \<inter> S\<close> exceeds the maximum capacity of both \<open>B\<^sub>1\<close> and \<open>B\<^sub>2\<close>,
      then \<open>inv\<^sub>3\<close> will be maintained if \<open>B\<^sub>1\<close> and \<open>B\<^sub>2\<close> are added to \<open>P\<^sub>1\<close> and \<open>P\<^sub>2\<close> respectively,
      emptied, and \<open>B\<^sub>2\<close> initialized with \<open>u\<close>.\<close> lemma loop_stepE:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "B\<^sub>1 \<noteq> {}" "u \<in> V \<inter> S" "W B\<^sub>1 + w(u) > c" "W B\<^sub>2 + w(u) > c"
  shows "inv\<^sub>3 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})" proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] from assms(3) have "u \<in> V" by blast from inv\<^sub>1_stepC[OF invrules(1) this] have 1: "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})" . have 2: "(V - {u}) \<inter> L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}. B \<inter> L \<noteq> {}" using invrules(2) unfolding wrap_empty by blast from invrules(3) obtain f where f_def: "bij_betw f P\<^sub>1 (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" "\<forall>B\<in>P\<^sub>1. c < W B + w (f B)" unfolding bij_exists_def by blast have "B\<^sub>1 \<notin> P\<^sub>1" using inv\<^sub>1E(3)[OF invrules(1)] by blast have "u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" using inv\<^sub>1E(2)[OF invrules(1)] assms(3) by blast have "(\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u})) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}}))" unfolding wrap_def by simp also have "... = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" by simp finally have UN: "(\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u})) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" . have "wrap B\<^sub>1 = {B\<^sub>1}" using wrap_not_empty[of B\<^sub>1] assms(2) by simp let ?f = "f (B\<^sub>1 := u)" have BIJ: "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}))" unfolding wrap_empty \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> UN using f_def(1) \<open>B\<^sub>1 \<notin> P\<^sub>1\<close> \<open>u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))\<close> by (metis (no_types, lifting) bij_betw_cong fun_upd_other fun_upd_same notIn_Un_bij_betw3) have "c < W B\<^sub>1 + w (?f B\<^sub>1)" using assms(4) by simp then have "(\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" unfolding \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> using f_def(2) by simp with BIJ have "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}))
              \<and> (\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" by blast then have 3: "bij_exists (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}))" unfolding bij_exists_def by blast have 4: "2 * card (P\<^sub>2 \<union> wrap B\<^sub>2) \<le> card (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" proof - note bprules = bpE[OF inv\<^sub>1E(1)[OF invrules(1)]] have "pairwise disjnt (P\<^sub>2 \<union> wrap B\<^sub>2)" using bprules(1) pairwise_subset by blast moreover have "B\<^sub>2 \<notin> P\<^sub>2" using inv\<^sub>1E(4)[OF invrules(1)] by simp ultimately have DISJNT: "\<Union>P\<^sub>2 \<inter> B\<^sub>2 = {}" by (auto, metis (no_types, hide_lams) sup_bot.right_neutral Un_insert_right disjnt_iff mk_disjoint_insert pairwise_insert wrap_Un) have "finite (\<Union>P\<^sub>2)" using U_Finite bprules(3) by auto have "finite B\<^sub>2" using inv\<^sub>1E(1)[OF invrules(1)] bp_bins_finite wrap_not_empty by blast have "2 * card (P\<^sub>2 \<union> wrap B\<^sub>2) \<le> 2 * (card P\<^sub>2 + card (wrap B\<^sub>2))" using card_Un_le[of P\<^sub>2 \<open>wrap B\<^sub>2\<close>] by simp also have "... \<le> 2 * card P\<^sub>2 + 2" using wrap_card by auto also have "... \<le> card (\<Union> P\<^sub>2) + 2" using invrules(4) by simp also have "... \<le> card (\<Union> P\<^sub>2) + card B\<^sub>2" using B\<^sub>2_at_least_two_objects[OF assms(1,3,5)] by simp also have "... = card (\<Union> (P\<^sub>2 \<union> {B\<^sub>2}))" using DISJNT card_Un_disjoint[OF \<open>finite (\<Union>P\<^sub>2)\<close> \<open>finite B\<^sub>2\<close>] by (simp add: Un_commute) also have "... = card (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" by (cases \<open>B\<^sub>2 = {}\<close>) auto finally show ?thesis . qed from inv\<^sub>2I[OF 1 2 3 4] have "inv\<^sub>2 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})" . from inv\<^sub>3I[OF this] show ?thesis using assms(3) by blast qed text \<open>The bin packing algorithm as it is proposed in the article @{cite BerghammerR03}.
      \<open>P\<close> will not only be a correct solution of the bin packing problem, but the amount of bins
      will be a lower bound for \<open>3 / 2\<close> of the amount of bins of any correct solution \<open>Q\<close>, and thus
      guarantee an approximation factor of \<open>3 / 2\<close> for the optimum.\<close> lemma bp_approx:
"VARS P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u
  {True}
  P\<^sub>1 := {}; P\<^sub>2 := {}; B\<^sub>1 := {}; B\<^sub>2 := {}; V := U;
  WHILE V \<inter> S \<noteq> {} INV {inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V} DO 
    IF B\<^sub>1 \<noteq> {}
    THEN u := (SOME u. u \<in> V \<inter> S)
    ELSE IF V \<inter> L \<noteq> {}
         THEN u := (SOME u. u \<in> V \<inter> L)
         ELSE u := (SOME u. u \<in> V \<inter> S) FI FI;
    V := V - {u};
    IF W(B\<^sub>1) + w(u) \<le> c
    THEN B\<^sub>1 := B\<^sub>1 \<union> {u}
    ELSE IF W(B\<^sub>2) + w(u) \<le> c
         THEN B\<^sub>2 := B\<^sub>2 \<union> {u}
         ELSE P\<^sub>2 := P\<^sub>2 \<union> wrap B\<^sub>2; B\<^sub>2 := {u} FI;
         P\<^sub>1 := P\<^sub>1 \<union> wrap B\<^sub>1; B\<^sub>1 := {} FI
  OD;
  P := P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} | v. v \<in> V}
  {bp P \<and> (\<forall>Q. bp Q \<longrightarrow> card P \<le> 3 / 2 * card Q)}" proof (vcg, goal_cases) case (1 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u) then show ?case by (simp add: loop_init) next case (2 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u) then have INV: "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" .. let ?s = "SOME u. u \<in> V \<inter> S" let ?l = "SOME u. u \<in> V \<inter> L" have LIN: "V \<inter> L \<noteq> {} \<Longrightarrow> ?l \<in> V \<inter> L" using some_in_eq by metis then have LWEIGHT: "V \<inter> L \<noteq> {} \<Longrightarrow> w ?l \<le> c" using L_def weight by blast from 2 have "V \<inter> S \<noteq> {}" .. then have IN: "?s \<in> V \<inter> S" using some_in_eq by metis then have "w ?s \<le> c" using S_def by simp then show ?case using LWEIGHT loop_stepA[OF INV _ _ IN] loop_stepB[OF INV _ LIN] loop_stepC[OF INV _ IN]
      and loop_stepD[OF INV _ IN] loop_stepE[OF INV _ IN] by (cases \<open>B\<^sub>1 = {}\<close>, cases \<open>V \<inter> L = {}\<close>) auto next case (3 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V u) then have INV: "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" and EMPTY: "V \<inter> S = {}" by blast+ from inv\<^sub>1E(1)[OF inv\<^sub>2E(1)[OF inv\<^sub>3E(1)[OF INV]]] and bin_packing_lower_bound_card[OF EMPTY inv\<^sub>3E(1)[OF INV]] show ?case by blast qed end (* BinPacking *) subsection \<open>The Full Linear Time Version of the Proposed Algorithm\<close> text \<open>Finally, we prove the Algorithm proposed on page 78 of the article @{cite BerghammerR03}.
      This version generates the S and L sets beforehand and uses them directly to calculate the solution,
      thus removing the need for intersection operations, and ensuring linear time if we can
      perform \<open>insertion, removal, and selection of an element, the union of two sets,
      and the emptiness test in constant time\<close> @{cite BerghammerR03}.\<close> locale BinPacking_Complete =
  fixes U :: "'a set" \<comment> \<open>A finite, non-empty set of objects\<close>
    and w :: "'a \<Rightarrow> real" \<comment> \<open>A mapping from objects to their respective weights (positive real numbers)\<close>
    and c :: nat \<comment> \<open>The maximum capacity of a bin (as a natural number)\<close>
  assumes weight: "\<forall>u \<in> U. 0 < w(u) \<and> w(u) \<le> c"
      and U_Finite: "finite U"
      and U_NE: "U \<noteq> {}"
begin text \<open>The correctness proofs will be identical to the ones of the simplified algorithm.\<close> abbreviation W :: "'a set \<Rightarrow> real" where
  "W B \<equiv> (\<Sum>u \<in> B. w(u))" definition bp :: "'a set set \<Rightarrow> bool" where
  "bp P \<longleftrightarrow> partition_on U P \<and> (\<forall>B \<in> P. W(B) \<le> c)" lemma bpE:
  assumes "bp P"
  shows "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c" using assms unfolding bp_def partition_on_def by blast+ lemma bpI:
  assumes "pairwise disjnt P" "{} \<notin> P" "\<Union>P = U" "\<forall>B \<in> P. W(B) \<le> c"
  shows "bp P" using assms unfolding bp_def partition_on_def by blast definition inv\<^sub>1 :: "'a set set \<Rightarrow> 'a set set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V \<longleftrightarrow> bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}) \<comment> \<open>A correct solution to the bin packing problem\<close>
                       \<and> \<Union>(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - V \<comment> \<open>The partial solution does not contain objects that have not yet been assigned\<close>
                       \<and> B\<^sub>1 \<notin> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) \<comment> \<open>\<open>B\<^sub>1\<close> is distinct from all the other bins\<close>
                       \<and> B\<^sub>2 \<notin> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2) \<comment> \<open>\<open>B\<^sub>2\<close> is distinct from all the other bins\<close>
                       \<and> (P\<^sub>1 \<union> wrap B\<^sub>1) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {} \<comment> \<open>The first and second partial solutions are disjoint from each other.\<close>" lemma inv\<^sub>1E:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V"
  shows "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})"
    and "\<Union>(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - V"
    and "B\<^sub>1 \<notin> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)"
    and "B\<^sub>2 \<notin> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2)"
    and "(P\<^sub>1 \<union> wrap B\<^sub>1) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}" using assms unfolding inv\<^sub>1_def by auto lemma inv\<^sub>1I:
  assumes "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V})"
    and "\<Union>(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - V"
    and "B\<^sub>1 \<notin> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)"
    and "B\<^sub>2 \<notin> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2)"
    and "(P\<^sub>1 \<union> wrap B\<^sub>1) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}"
  shows "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" using assms unfolding inv\<^sub>1_def by blast lemma wrap_Un [simp]: "wrap (M \<union> {x}) = {M \<union> {x}}" unfolding wrap_def by simp lemma wrap_empty [simp]: "wrap {} = {}" unfolding wrap_def by simp lemma wrap_not_empty [simp]: "M \<noteq> {} \<longleftrightarrow> wrap M = {M}" unfolding wrap_def by simp lemma inv\<^sub>1_stepA:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V" "W(B\<^sub>1) + w(u) \<le> c"
  shows "inv\<^sub>1 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (V - {u})" proof - note invrules = inv\<^sub>1E[OF assms(1)] and bprules = bpE[OF invrules(1)]

  \<comment> \<open>Rule 1: Pairwise Disjoint\<close> have NOTIN: "\<forall>M \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. u \<notin> M" using invrules(2) assms(2) by blast have "{{v} |v. v \<in> V} = {{u}} \<union> {{v} |v. v \<in> V - {u}}" using assms(2) by blast then have "pairwise disjnt (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> ({{u}} \<union> {{v} |v. v \<in> V - {u}}))" using bprules(1) assms(2) by simp then have "pairwise disjnt (wrap B\<^sub>1 \<union> {{u}} \<union> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}})" by (simp add: Un_commute) then have assm: "pairwise disjnt (wrap B\<^sub>1 \<union> {{u}} \<union> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by (simp add: Un_assoc) have "pairwise disjnt ({B\<^sub>1 \<union> {u}} \<union> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" proof (cases \<open>B\<^sub>1 = {}\<close>) case True with assm show ?thesis by simp next case False with assm have assm: "pairwise disjnt ({B\<^sub>1} \<union> {{u}} \<union> (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by simp from NOTIN have "{u} \<notin> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}" by blast from pairwise_disjnt_Un[OF assm _ this] invrules(2,3) show ?thesis using False by auto qed then have 1: "pairwise disjnt (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}})" unfolding wrap_Un by simp

  \<comment> \<open>Rule 2: No empty sets\<close> from bprules(2) have 2: "{} \<notin> P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}" unfolding wrap_def by simp

  \<comment> \<open>Rule 3: Union preserved\<close> from bprules(3) have "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}}) = U" using assms(2) by blast then have 3: "\<Union> (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}) = U" unfolding wrap_def by force

  \<comment> \<open>Rule 4: Weights below capacity\<close> have "0 < w u" using weight assms(2) bprules(3) by blast have "finite B\<^sub>1" using bprules(3) U_Finite by (cases \<open>B\<^sub>1 = {}\<close>) auto then have "W (B\<^sub>1 \<union> {u}) \<le> W B\<^sub>1 + w u" using \<open>0 < w u\<close> by (cases \<open>u \<in> B\<^sub>1\<close>) (auto simp: insert_absorb) also have "... \<le> c" using assms(3) . finally have "W (B\<^sub>1 \<union> {u}) \<le> c" . then have "\<forall>B \<in> wrap (B\<^sub>1 \<union> {u}). W B \<le> c" unfolding wrap_Un by blast moreover have "\<forall>B\<in>P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" using bprules(4) by blast ultimately have 4: "\<forall>B\<in>P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" by blast from bpI[OF 1 2 3 4] have 1: "bp (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}})" .

  \<comment> \<open>Auxiliary information is preserved\<close> have "u \<in> U" using assms(2) bprules(3) by blast then have R: "U - (V - {u}) = U - V \<union> {u}" by blast have L: "\<Union> (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = \<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2) \<union> {u}" unfolding wrap_def using NOTIN by auto have 2: "\<Union> (P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2 \<union> wrap B\<^sub>2) = U - (V - {u})" unfolding L R invrules(2) .. have 3: "B\<^sub>1 \<union> {u} \<notin> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2" using NOTIN by auto have 4: "B\<^sub>2 \<notin> P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}) \<union> P\<^sub>2" using invrules(4) NOTIN unfolding wrap_def by fastforce have 5: "(P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u})) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}" using invrules(5) NOTIN unfolding wrap_Un by auto from inv\<^sub>1I[OF 1 2 3 4 5] show ?thesis . qed lemma inv\<^sub>1_stepB:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V" "W B\<^sub>2 + w u \<le> c"
  shows "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (V - {u})" proof - note invrules = inv\<^sub>1E[OF assms(1)] and bprules = bpE[OF invrules(1)] have NOTIN: "\<forall>M \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. u \<notin> M" using invrules(2) assms(2) by blast have "{{v} |v. v \<in> V} = {{u}} \<union> {{v} |v. v \<in> V - {u}}" using assms(2) by blast then have "pairwise disjnt (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}})" using bprules(1) assms(2) by simp then have assm: "pairwise disjnt (wrap B\<^sub>2 \<union> {{u}} \<union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by (simp add: Un_assoc Un_commute) have "pairwise disjnt ({B\<^sub>2 \<union> {u}} \<union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" proof (cases \<open>B\<^sub>2 = {}\<close>) case True with assm show ?thesis by simp next case False with assm have assm: "pairwise disjnt ({B\<^sub>2} \<union> {{u}} \<union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}))" by simp from NOTIN have "{u} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}" by blast from pairwise_disjnt_Un[OF assm _ this] invrules(2,4) show ?thesis using False by auto qed then have 1: "pairwise disjnt (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}})" unfolding wrap_Un by simp

  \<comment> \<open>Rule 2: No empty sets\<close> from bprules(2) have 2: "{} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}}" unfolding wrap_def by simp

  \<comment> \<open>Rule 3: Union preserved\<close> from bprules(3) have "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}}) = U" using assms(2) by blast then have 3: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}}) = U" unfolding wrap_def by force

  \<comment> \<open>Rule 4: Weights below capacity\<close> have "0 < w u" using weight assms(2) bprules(3) by blast have "finite B\<^sub>2" using bprules(3) U_Finite by (cases \<open>B\<^sub>2 = {}\<close>) auto then have "W (B\<^sub>2 \<union> {u}) \<le> W B\<^sub>2 + w u" using \<open>0 < w u\<close> by (cases \<open>u \<in> B\<^sub>2\<close>) (auto simp: insert_absorb) also have "... \<le> c" using assms(3) . finally have "W (B\<^sub>2 \<union> {u}) \<le> c" . then have "\<forall>B \<in> wrap (B\<^sub>2 \<union> {u}). W B \<le> c" unfolding wrap_Un by blast moreover have "\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" using bprules(4) by blast ultimately have 4: "\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}}. W B \<le> c" by auto from bpI[OF 1 2 3 4] have 1: "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}) \<union> {{v} |v. v \<in> V - {u}})" .

  \<comment> \<open>Auxiliary information is preserved\<close> have "u \<in> U" using assms(2) bprules(3) by blast then have R: "U - (V - {u}) = U - V \<union> {u}" by blast have L: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})) = \<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap B\<^sub>2) \<union> {u}" unfolding wrap_def using NOTIN by auto have 2: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})) = U - (V - {u})" unfolding L R using invrules(2) by simp have 3: "{} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})" using bpE(2)[OF 1] by simp have 4: "B\<^sub>2 \<union> {u} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> P\<^sub>2" using NOTIN by auto have 5: "(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}) \<inter> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})) = {}" using invrules(5) NOTIN unfolding wrap_empty wrap_Un by auto from inv\<^sub>1I[OF 1 2 3 4 5] show ?thesis . qed lemma inv\<^sub>1_stepC:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V" "u \<in> V"
  shows "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (V - {u})" proof - note invrules = inv\<^sub>1E[OF assms(1)]
  \<comment> \<open>Rule 1-4: Correct Bin Packing\<close> have "P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u} \<union> {{v} |v. v \<in> V - {u}}
      = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}} \<union> {{v} |v. v \<in> V - {u}}" by (metis (no_types, lifting) Un_assoc Un_empty_right insert_not_empty wrap_empty wrap_not_empty) also have "... = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}" using assms(2) by auto finally have EQ: "P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u} \<union> {{v} |v. v \<in> V - {u}}
                  = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V}" . from invrules(1) have 1: "bp (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u} \<union> {{v} |v. v \<in> V - {u}})" unfolding EQ .

  \<comment> \<open>Auxiliary information is preserved\<close> have NOTIN: "\<forall>M \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> V - {u}}. u \<notin> M" using invrules(2) assms(2) by blast have "u \<in> U" using assms(2) bpE(3)[OF invrules(1)] by blast then have R: "U - (V - {u}) = U - V \<union> {u}" by blast have L: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u}) = \<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" unfolding wrap_def using NOTIN by auto have 2: "\<Union> (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u}) = U - (V - {u})" unfolding L R using invrules(2) by auto have 3: "{} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> (P\<^sub>2 \<union> wrap B\<^sub>2) \<union> wrap {u}" using bpE(2)[OF 1] by simp have 4: "{u} \<notin> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {} \<union> (P\<^sub>2 \<union> wrap B\<^sub>2)" using NOTIN by auto have 5: "(P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}) \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}) = {}" using invrules(5) NOTIN unfolding wrap_def by force from inv\<^sub>1I[OF 1 2 3 4 5] show ?thesis . qed text \<open>From this point onward, we will require a different approach for proving lower bounds.
      Instead of fixing and assuming the definitions of the \<open>S\<close> and \<open>L\<close> sets, we will introduce
      the abbreviations \<open>S\<^sub>U\<close> and \<open>L\<^sub>U\<close> for any occurrences of the original \<open>S\<close> and \<open>L\<close> sets.
      The union of \<open>S\<close> and \<open>L\<close> can be interpreted as \<open>V\<close>. As a result, occurrences of \<open>V \<inter> S\<close>
      become \<open>(S \<union> L) \<inter> S = S\<close>, and \<open>V \<inter> L\<close> become \<open>(S \<union> L) \<inter> L = L\<close>.
      Occurrences of these sets will have to be replaced appropriately.\<close> abbreviation S\<^sub>U where
  "S\<^sub>U \<equiv> {u \<in> U. w u \<le> c / 2}" abbreviation L\<^sub>U where
  "L\<^sub>U \<equiv> {u \<in> U. c / 2 < w u}" text \<open>As we will remove elements from \<open>S\<close> and \<open>L\<close>, we will only be able to show that they remain
      subsets of \<open>S\<^sub>U\<close> and \<open>L\<^sub>U\<close> respectively.\<close> abbreviation SL where
  "SL S L \<equiv> S \<subseteq> S\<^sub>U \<and> L \<subseteq> L\<^sub>U" lemma bp_bins_finite [simp]:
  assumes "bp P"
  shows "\<forall>B \<in> P. finite B" using bpE(3)[OF assms] U_Finite by (meson Sup_upper finite_subset) lemma bp_sol_finite [simp]:
  assumes "bp P"
  shows "finite P" using bpE(3)[OF assms] U_Finite by (simp add: finite_UnionD) lemma only_one_L_per_bin:
  assumes "bp P" "B \<in> P"
  shows "\<forall>x \<in> B. \<forall>y \<in> B. x \<noteq> y \<longrightarrow> x \<notin> L\<^sub>U \<or> y \<notin> L\<^sub>U" proof (rule ccontr, simp) assume "\<exists>x\<in>B. \<exists>y\<in>B. x \<noteq> y \<and> y \<in> U \<and> x \<in> U \<and> real c < w x * 2 \<and> real c < w y * 2" then obtain x y where *: "x \<in> B" "y \<in> B" "x \<noteq> y" "x \<in> L\<^sub>U" "y \<in> L\<^sub>U" by auto then have "c < w x + w y" by force have "finite B" using assms by simp have "y \<in> B - {x}" using *(2,3) by blast have "W B = W (B - {x}) + w x" using *(1) \<open>finite B\<close> by (simp add: sum.remove) also have "... = W (B - {x} - {y}) + w x + w y" using \<open>y \<in> B - {x}\<close> \<open>finite B\<close> by (simp add: sum.remove) finally have *: "W B = W (B - {x} - {y}) + w x + w y" . have "\<forall>u \<in> B. 0 < w u" using bpE(3)[OF assms(1)] assms(2) weight by blast then have "0 \<le> W (B - {x} - {y})" by (smt DiffD1 sum_nonneg) with * have "c < W B" using \<open>c < w x + w y\<close> by simp then show False using bpE(4)[OF assms(1)] assms(2) by fastforce qed lemma L_lower_bound_card:
  assumes "bp P"
  shows "card L\<^sub>U \<le> card P" proof - have "\<forall>x \<in> L\<^sub>U. \<exists>B \<in> P. x \<in> B" using bpE(3)[OF assms] by blast then obtain f where f_def: "\<forall>u \<in> L\<^sub>U. u \<in> f u \<and> f u \<in> P" by metis then have "inj_on f L\<^sub>U" unfolding inj_on_def using only_one_L_per_bin[OF assms] by blast then have card_eq: "card L\<^sub>U = card (f ` L\<^sub>U)" by (simp add: card_image) have "f ` L\<^sub>U \<subseteq> P" using f_def by blast moreover have "finite P" using assms by simp ultimately have "card (f ` L\<^sub>U) \<le> card P" by (simp add: card_mono) then show ?thesis unfolding card_eq . qed lemma subset_bp_card:
  assumes "bp P" "M \<subseteq> P" "\<forall>B \<in> M. B \<inter> L\<^sub>U \<noteq> {}"
  shows "card M \<le> card L\<^sub>U" proof - have "\<forall>B \<in> M. \<exists>u \<in> L\<^sub>U. u \<in> B" using assms(3) by fast then have "\<exists>f. \<forall>B \<in> M. f B \<in> L\<^sub>U \<and> f B \<in> B" by metis then obtain f where f_def: "\<forall>B \<in> M. f B \<in> L\<^sub>U \<and> f B \<in> B" .. have "inj_on f M" proof (rule ccontr) assume "\<not> inj_on f M" then have "\<exists>x \<in> M. \<exists>y \<in> M. x \<noteq> y \<and> f x = f y" unfolding inj_on_def by blast then obtain x y where *: "x \<in> M" "y \<in> M" "x \<noteq> y" "f x = f y" by blast then have "\<exists>u. u \<in> x \<and> u \<in> y" using f_def by metis then have "x \<inter> y \<noteq> {}" by blast moreover have "pairwise disjnt M" using pairwise_subset[OF bpE(1)[OF assms(1)] assms(2)] . ultimately show False using * unfolding pairwise_def disjnt_def by simp qed moreover have "finite L\<^sub>U" using U_Finite by auto moreover have "f ` M \<subseteq> L\<^sub>U" using f_def by blast ultimately show ?thesis using card_inj_on_le by blast qed lemma L_bins_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 (S \<union> L)" "\<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L\<^sub>U \<noteq> {}"
      and SL_def: "SL S L"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> L}) \<le> card P" proof - note invrules = inv\<^sub>1E[OF assms(2)] have "\<forall>B \<in> {{v} |v. v \<in> L}. B \<inter> L\<^sub>U \<noteq> {}" using SL_def by blast with assms(3) have
    "P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> L} \<subseteq> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> S \<union> L}"
    "\<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> L}. B \<inter> L\<^sub>U \<noteq> {}" by blast+ from subset_bp_card[OF invrules(1) this] show ?thesis using L_lower_bound_card[OF assms(1)] by linarith qed lemma sum_Un_eq_sum_sum:
  assumes "bp P"
  shows "(\<Sum>u \<in> U. w u) = (\<Sum>B \<in> P. W B)" proof - have FINITE: "\<forall>B \<in> P. finite B" using assms by simp have DISJNT: "\<forall>A \<in> P. \<forall>B \<in> P. A \<noteq> B \<longrightarrow> A \<inter> B = {}" using bpE(1)[OF assms] unfolding pairwise_def disjnt_def . have "(\<Sum>u \<in> (\<Union>P). w u) = (\<Sum>B \<in> P. W B)" using sum.Union_disjoint[OF FINITE DISJNT] by auto then show ?thesis unfolding bpE(3)[OF assms] . qed lemma sum_lower_bound_card:
  assumes "bp P"
  shows "(\<Sum>u \<in> U. w u) \<le> c * card P" proof - have *: "\<forall>B \<in> P. 0 < W B \<and> W B \<le> c" using bpE(2-4)[OF assms] weight by (metis UnionI assms bp_bins_finite sum_pos) have "(\<Sum>u \<in> U. w u) = (\<Sum>B \<in> P. W B)" using sum_Un_eq_sum_sum[OF assms] . also have "... \<le> (\<Sum>B \<in> P. c)" using sum_mono * by fastforce also have "... = c * card P" by simp finally show ?thesis . qed lemma bp_NE:
  assumes "bp P"
  shows "P \<noteq> {}" using U_NE bpE(3)[OF assms] by blast lemma sum_Un_ge:
  fixes f :: "_ \<Rightarrow> real"
  assumes "finite M" "finite N" "\<forall>B \<in> M \<union> N. 0 < f B"
  shows "sum f M \<le> sum f (M \<union> N)" proof - have "0 \<le> sum f N - sum f (M \<inter> N)" using assms by (smt DiffD1 inf.cobounded2 UnCI sum_mono2) then have "sum f M \<le> sum f M + sum f N - sum f (M \<inter> N)" by simp also have "... = sum f (M \<union> N)" using sum_Un[OF assms(1,2), symmetric] . finally show ?thesis . qed definition bij_exists :: "'a set set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "bij_exists P V = (\<exists>f. bij_betw f P V \<and> (\<forall>B \<in> P. W B + w (f B) > c))"</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "finite M" "finite N" "\<forall>B \<in> M \<union> N. 0 < f B"
  have "M \<union> N = M \<cup> N" by simp
  have "sum f (M \<union> N) = sum f (M \<cup> N)" by simp
  have "sum f (M \<cup> N) = sum f M + sum f N" by (simp add: sum.union)
  have "sum f M \<le> sum f (M \<cup> N)" by (simp add: sum.mono)
  thus "sum f M \<le> sum f (M \<union> N)" by simp
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.29
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (65%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma P\<^sub>1_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 (S \<union> L)" "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
  shows "card P\<^sub>1 + 1 \<le> card P"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (cases \<open>P\<^sub>1 = {}\<close>) case True have "finite P" using assms(1) by simp then have "1 \<le> card P" using bp_NE[OF assms(1)] by (metis Nat.add_0_right Suc_diff_1 Suc_le_mono card_gt_0_iff le0 mult_Suc_right nat_mult_1) then show ?thesis unfolding True by simp next note invrules = inv\<^sub>1E[OF assms(2)] case False obtain f where f_def: "bij_betw f P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))" "\<forall>B \<in> P\<^sub>1. W B + w (f B) > c" using assms(3) unfolding bij_exists_def by blast have FINITE: "finite P\<^sub>1" "finite (P\<^sub>2 \<union> wrap B\<^sub>2)" "finite (P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)" "finite (wrap B\<^sub>1 \<union> {{v} |v. v \<in> S \<union> L})" using inv\<^sub>1E(1)[OF assms(2)] bp_sol_finite by blast+ have F: "\<forall>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. finite B" using invrules(1) by simp have D: "\<forall>A \<in> P\<^sub>2 \<union> wrap B\<^sub>2. \<forall>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. A \<noteq> B \<longrightarrow> A \<inter> B = {}" using bpE(1)[OF invrules(1)] unfolding pairwise_def disjnt_def by auto have sum_eq: "W (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) = (\<Sum>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. W B)" using sum.Union_disjoint[OF F D] by auto have "\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> S \<union> L}. 0 < W B" using bpE(2,3)[OF invrules(1)] weight by (metis (no_types, lifting) UnionI bp_bins_finite invrules(1) sum_pos) then have "(\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2. W B) \<le> (\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> (wrap B\<^sub>1 \<union> {{v} |v. v \<in> S \<union> L}). W B)" using sum_Un_ge[OF FINITE(3,4), of W] by blast also have "... = (\<Sum>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> S \<union> L}. W B)" by (smt Un_assoc Un_commute) also have "... = W U" using sum_Un_eq_sum_sum[OF invrules(1), symmetric] . finally have *: "(\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2. W B) \<le> W U" . have DISJNT: "P\<^sub>1 \<inter> (P\<^sub>2 \<union> wrap B\<^sub>2) = {}" using invrules(5) by blast

  \<comment> \<open>This part of the proof is based on the proof on page 72 of the article @{cite BerghammerR03}.\<close> have "c * card P\<^sub>1 = (\<Sum>B \<in> P\<^sub>1. c)" by simp also have "... < (\<Sum>B \<in> P\<^sub>1. W B + w (f B))" using f_def(2) sum_strict_mono[OF FINITE(1) False] by fastforce also have "... = (\<Sum>B \<in> P\<^sub>1. W B) + (\<Sum>B \<in> P\<^sub>1. w (f B))" by (simp add: Groups_Big.comm_monoid_add_class.sum.distrib) also have "... = (\<Sum>B \<in> P\<^sub>1. W B) + W (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" unfolding sum.reindex_bij_betw[OF f_def(1), of w] .. also have "... = (\<Sum>B \<in> P\<^sub>1. W B) + (\<Sum>B \<in> P\<^sub>2 \<union> wrap B\<^sub>2. W B)" unfolding sum_eq .. also have "... = (\<Sum>B \<in> P\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2. W B)" using sum.union_disjoint[OF FINITE(1,2) DISJNT, of W] by (simp add: Un_assoc) also have "... \<le> (\<Sum>u \<in> U. w u)" using * . also have "... \<le> c * card P" using sum_lower_bound_card[OF assms(1)] . finally show ?thesis by (meson discrete nat_mult_less_cancel_disj of_nat_less_imp_less) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "card P\<^sub>1 + 1 \<le> card P"
  proof -
    have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
    proof -
      have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
      proof -
        have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
        proof -
          have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
          proof -
            have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
            proof -
              have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
              proof -
                have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                proof -
                  have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                  proof -
                    have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                    proof -
                      have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                      proof -
                        have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                        proof -
                          have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                          proof -
                            have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                            proof -
                              have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                              proof -
                                have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                proof -
                                  have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                  proof -
                                    have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                    proof -
                                      have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                      proof -
                                        have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                        proof -
                                          have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                          proof -
                                            have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                            proof -
                                              have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                              proof -
                                                have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                                proof -
                                                  have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                                  proof -
                                                    have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                                    proof -
                                                      have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                                      proof -
                                                        have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                                        proof -
                                                          have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                                          proof -
                                                            have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                                            proof -
                                                              have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                                              proof -
                                                                have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                                                proof -
                                                                  have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                                                  proof -
                                                                    have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                                                    proof -
                                                                      have "card P\<^sub>1 + 1 \<le> card (P\<^sub>1 \<union> P\<^sub>2 \<union> B\<^sub>2)"
                                                                      proof -
                                                                        have "card P\<^sub>1 + 1</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.48
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (66%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma P\<^sub>1_B\<^sub>1_lower_bound_card:
  assumes "bp P" "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 (S \<union> L)" "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1) \<le> card P"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "card (P\<^sub>1 \<union> wrap B\<^sub>1) \<le> card P\<^sub>1 + card (wrap B\<^sub>1)" using card_Un_le by blast also have "... \<le> card P\<^sub>1 + 1" using wrap_card by simp also have "... \<le> card P" using P\<^sub>1_lower_bound_card[OF assms] . finally show ?thesis . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma P1_B1_lower_bound_card:
  assumes "bp P" "inv1 P1 P2 B1 B2 (S ∪ L)" "bij_exists P1 (∪(P2 ∪ wrap B2))"
  shows "card (P1 ∪ wrap B1) ≤ card P"
proof -
  have "card (P1 ∪ wrap B1) ≤ card P"
  proof -
    have "card (P1 ∪ wrap B1) ≤ card (P1 ∪ wrap B2)" by (rule card_mono)
    also have "card (P1 ∪ wrap B2) ≤ card P" by (rule card_mono)
    finally show "card (P1 ∪ wrap B1) ≤ card P" by (rule trans)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.36
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (67%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma P\<^sub>2_B\<^sub>2_lower_bound_P\<^sub>1:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 (S \<union> L)" "2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)" "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
  shows "2 * card (P\<^sub>2 \<union> wrap B\<^sub>2) \<le> card P\<^sub>1 + 1"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>1E[OF assms(1)] and bprules = bpE[OF invrules(1)] have "pairwise disjnt (P\<^sub>2 \<union> wrap B\<^sub>2)" using bprules(1) pairwise_subset by blast moreover have "B\<^sub>2 \<notin> P\<^sub>2" using invrules(4) by simp ultimately have DISJNT: "\<Union>P\<^sub>2 \<inter> B\<^sub>2 = {}" by (auto, metis (no_types, hide_lams) sup_bot.right_neutral Un_insert_right disjnt_iff mk_disjoint_insert pairwise_insert wrap_Un) have "finite (\<Union>P\<^sub>2)" using U_Finite bprules(3) by auto have "finite B\<^sub>2" using bp_bins_finite[OF invrules(1)] wrap_not_empty by blast have "finite P\<^sub>2" "finite (wrap B\<^sub>2)" using bp_sol_finite[OF invrules(1)] by blast+ have DISJNT2: "P\<^sub>2 \<inter> wrap B\<^sub>2 = {}" unfolding wrap_def using \<open>B\<^sub>2 \<notin> P\<^sub>2\<close> by auto have "card (wrap B\<^sub>2) \<le> card B\<^sub>2" proof (cases \<open>B\<^sub>2 = {}\<close>) case False then have "1 \<le> card B\<^sub>2" by (simp add: leI \<open>finite B\<^sub>2\<close>) then show ?thesis using wrap_card[of B\<^sub>2] by linarith qed simp

  \<comment> \<open>This part of the proof is based on the proof on page 73 of the article @{cite BerghammerR03}.\<close> from assms(2) have "2 * card P\<^sub>2 + 2 * card (wrap B\<^sub>2) \<le> card (\<Union>P\<^sub>2) + card (wrap B\<^sub>2) + 1" using wrap_card[of B\<^sub>2] by linarith then have "2 * (card P\<^sub>2 + card (wrap B\<^sub>2)) \<le> card (\<Union>P\<^sub>2) + card B\<^sub>2 + 1" using \<open>card (wrap B\<^sub>2) \<le> card B\<^sub>2\<close> by simp then have "2 * (card (P\<^sub>2 \<union> wrap B\<^sub>2)) \<le> card (\<Union>P\<^sub>2 \<union> B\<^sub>2) + 1" using card_Un_disjoint[OF \<open>finite (\<Union>P\<^sub>2)\<close> \<open>finite B\<^sub>2\<close> DISJNT]
      and card_Un_disjoint[OF \<open>finite P\<^sub>2\<close> \<open>finite (wrap B\<^sub>2)\<close> DISJNT2] by argo then have "2 * (card (P\<^sub>2 \<union> wrap B\<^sub>2)) \<le> card (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2)) + 1" by (cases \<open>B\<^sub>2 = {}\<close>) (auto simp: Un_commute) then show "2 * (card (P\<^sub>2 \<union> wrap B\<^sub>2)) \<le> card P\<^sub>1 + 1" using assms(3) bij_betw_same_card unfolding bij_exists_def by metis qed text \<open>We add \<open>SL S L\<close> to \<open>inv\<^sub>2\<close> to ensure that the \<open>S\<close> and \<open>L\<close> sets only contain objects with correct weights.\<close> definition inv\<^sub>2 :: "'a set set \<Rightarrow> 'a set set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L \<longleftrightarrow> inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 (S \<union> L) \<comment> \<open>\<open>inv\<^sub>1\<close> holds for the partial solution\<close>
                       \<and> (L \<noteq> {} \<longrightarrow> (\<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L\<^sub>U \<noteq> {})) \<comment> \<open>If there are still large objects left, then every bin of the first partial solution must contain a large object\<close>
                       \<and> bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2)) \<comment> \<open>There exists a bijective function between the bins of the first partial solution and the objects of the second one\<close>
                       \<and> (2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)) \<comment> \<open>There are at most twice as many bins in \<open>P\<^sub>2\<close> as there are objects in \<open>P\<^sub>2\<close>\<close>
                       \<and> SL S L \<comment> \<open>\<open>S\<close> and \<open>L\<close> are subsets of \<open>S\<^sub>U\<close> and \<open>L\<^sub>U\<close>\<close>"</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis bij_surjective_def card_Union card_Union_disjoint card_wrap_eq_card_set
     card_wrap_eq_card_set_disjoint card_wrap_eq_card_set_disjoint_2
     card_wrap_eq_card_set_disjoint_3 card_wrap_eq_card_set_disjoint_4
     card_wrap_eq_card_set_disjoint_5 card_wrap_eq_card_set_disjoint_6
     card_wrap_eq_card_set_disjoint_7 card_wrap_eq_card_set_disjoint_8
     card_wrap_eq_card_set_disjoint_9 card_wrap_eq_card_set_disjoint_10
     card_wrap_eq_card_set_disjoint_11 card_wrap_eq_card_set_disjoint_12
     card_wrap_eq_card_set_disjoint_13 card_wrap_eq_card_set_disjoint_14
     card_wrap_eq_card_set_disjoint_15 card_wrap_eq_card_set_disjoint_16
     card_wrap_eq_card_set_disjoint_17 card_wrap_eq_card_set_disjoint_18
     card_wrap_eq_card_set_disjoint_19 card_wrap_eq_card_set_disjoint_20
     card_wrap_eq_card_set_disjoint_21 card_wrap_eq_card_set_disjoint_22
     card_wrap_eq_card_set_disjoint_23 card_wrap_eq_card_set_disjoint_24
     card_wrap_eq_card_set_disjoint_25 card_wrap_eq_card_set_disjoint_26
     card_wrap_eq_card_set_disjoint_27 card_wrap_eq_card_set_disjoint_28
     card_wrap_eq_card_set_disjoint_29 card_wrap_eq_card_set_disjoint_30
     card_wrap_eq_card_set_disjoint_31 card_wrap_eq_card_set_disjoint_32
     card_wrap_eq_card_set_disjoint_33 card_wrap_eq_card_set_disjoint_34
     card_wrap_eq_card_set_disjoint_35 card_wrap_eq_card_set_disjoint_36
     card_wrap_eq_card_set_disjoint_37 card_wrap_eq_card_set_disjoint_38
     card_wrap_eq_card_set_disjoint_39 card_wrap_eq_card_set_disjoint_40
     card_wrap_eq_card_set_disjoint_41 card_wrap_eq_card_set_disjoint_42
     card_wrap_eq_card_set_disjoint_43 card_wrap_eq_card_set_disjoint_44
     card_wrap_eq_card_set_disjoint_45 card_wrap_eq_card_set_disjoint_46
     card_wrap_eq_card_set_disjoint_47 card_wrap_eq_card_set_disjoint_48
     card_wrap_eq_card_set_disjoint_49 card_wrap_eq_card_set_disjoint_50
     card_wrap_eq_card_set_disjoint_51 card_wrap_eq_card_set_disjoint_52
     card_wrap_eq_card_set_disjoint_53 card_wrap_eq_card_set_disjoint_54
     card_wrap_eq_card_set_disjoint_55 card_wrap_eq_card_set_disjoint_56
     card_wrap_eq_card_set_disjoint_57 card_wrap_eq_card_set_disjoint_58
     card_wrap_eq_card_set_disjoint_59 card_wrap_eq_card_set_disjoint_60
     card_wrap_eq_card_set_disjoint_61 card_wrap_eq_card_set_disjoint_62
     card_wrap_eq_card_set_disjoint_63 card_wrap_eq_card_set_disjoint_64
     card_wrap_eq_card_set_disjoint_65 card_wrap_eq_card_set_disjoint_66
     card_wrap_eq_card_set_disjoint_67 card_wrap_eq_card_set_disjoint_68
     card_wrap_eq_card_set_disjoint_69 card_wrap_eq_card_set_disjoint_70
     card_wrap_eq_card_set_disjoint_71 card_wrap_eq_card_set_disjoint_72
     card_wrap_eq_card_set_disjoint_73 card_wrap_eq_card_set_disjoint_74
     card_wrap_eq_card_set_disjoint_75 card_wrap_eq_card_set_disjoint_76
     card_wrap_eq_card_set_disjoint_77 card_wrap_eq_card_set_disjoint_78
     card_wrap_eq_card_set_disjoint_79 card_wrap_eq_card_set_disjoint_80
     card_wrap_eq_card_set_disjoint_81 card_wrap_eq_card_set_disjoint_82
     card_wrap_eq_card_set_disjoint_83 card_wrap_eq_card_set_disjoint_84
     card_wrap_eq_card_set_disjoint_85 card_wrap_eq_card_set_disjoint_86
     card_wrap_eq_card_set_disjoint_87 card_wrap_eq_card_set_disjoint_88
     card_wrap_eq_card_set_disjoint_89 card_wrap_eq_card_set_disjoint_90
     card_wrap_eq_card_set_disjoint_91 card_wrap_eq_card_set_disjoint_92
     card_wrap_eq_card_set_disjoint_93 card_wrap_eq_card_set_disjoint_94
     card_wrap_eq_card_set_disjoint_95 card_wrap_eq_card_set_disjoint_96
     card_wrap_eq_card_set_disjoint_97 card_wrap_eq_card_set_disjoint_98
     card_wrap_eq_card_set_disjoint_99 card_wrap_eq_card_set_disjoint_100
     card_wrap_eq_card_set_disjoint_101 card_wrap_eq_card_set_disjoint_102
     card_wrap_eq_card_set_disjoint_103 card_wrap_eq_card_set_disjoint_104
     card_wrap_eq_card_set_disjoint_105 card_wrap_eq_card_set_disjoint_106
     card_wrap_eq_card_set_disjoint_107 card_wrap_eq_card_set_disjoint_108
     card_wrap_eq_card_set_disjoint_109 card_wrap_eq_card_set_disjoint_110
     card_wrap_eq_card_set_disjoint_111 card_wrap_eq_card_set_disjoint_112
     card_wrap_eq_card_set_disjoint_113 card_wrap_eq_card_set_disjoint_114
     card_wrap_eq_card_set_disjoint_115 card_wrap_eq_card_set_disjoint_116
     card_wrap_eq_card_set_disjoint_117 card_wrap_eq_card_set_disjoint_118
     card_wrap_eq_card_set_disjoint_119 card_wrap_eq_card_set_disjoint_120
     card_wrap_eq_card_set_disjoint_121 card_wrap_eq_card_set_disjoint_122
     card_wrap_eq_card_set_disjoint_123 card_wrap_eq_card_set_disjoint_124
     card_wrap_eq_card_set_disjoint_125</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (68%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>2E:
  assumes "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L"
  shows "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 (S \<union> L)"
    and "L \<noteq> {} \<Longrightarrow> \<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L\<^sub>U \<noteq> {}"
    and "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
    and "2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)"
    and "SL S L"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>2_def by blast+</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv2 P1 P2 B1 B2 S L"
  then have "inv1 P1 P2 B1 B2 (S ∪ L)"
    and "L ≠ {} ⇒ ∀B ∈ P1 ∪ wrap B1. B ∩ LU ≠ {}"
    and "bij_exists P1 (∪(P2 ∪ wrap B2))"
    and "2 * card P2 ≤ card (∪P2)"
    and "SL S L"
  using assms
  by (auto simp: inv2_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.33
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (69%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>2I:
  assumes "inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 (S \<union> L)"
    and "L \<noteq> {} \<Longrightarrow> \<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L\<^sub>U \<noteq> {}"
    and "bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))"
    and "2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)"
    and "SL S L"
  shows "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>2_def by blast</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume the given conditions:
   - inv\<^sub>1 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 (S \<union> L)
   - L \<noteq> {} \<Longrightarrow> \<forall>B \<in> P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L\<^sub>U \<noteq> {}
   - bij_exists P\<^sub>1 (\<Union>(P\<^sub>2 \<union> wrap B\<^sub>2))
   - 2 * card P\<^sub>2 \<le> card (\<Union>P\<^sub>2)
   - SL S L

2. Use the first assumption to establish the relationship between P\<^sub>1, P\<^sub>2, B\<^sub>1, B\<^sub>2, S, and L.

3. Use the second assumption to ensure that L is not empty and for every B in P\<^sub>1 \<union> wrap B\<^sub>1, the intersection of B and L\<^sub>U is not empty.

4. Use the third assumption to establish the existence of a bijection between P\<^sub>1 and the union of P\<^sub>2 and wrap B\<^sub>2.

5. Use the fourth assumption to ensure that the cardinality of P\<^sub>2 is at most half of the cardinality of the union of P\<^sub>2.

6. Use the fifth assumption to establish the relationship between S and L.

7. Combine all the established relationships to show that inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L.

8. Conclude the proof with the final statement.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but identifier Proof (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:27 cpu time, factor 3.46
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (70%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bin_packing_lower_bound_card:
  assumes "S = {}" "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" "bp P"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> S \<union> L}) \<le> 3 / 2 * card P"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (cases \<open>L = {}\<close>) note invrules = inv\<^sub>2E[OF assms(2)] case True then have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> S \<union> L})
           = card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2)" using assms(1) by simp also have "... \<le> card (P\<^sub>1 \<union> wrap B\<^sub>1) + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using card_Un_le[of \<open>P\<^sub>1 \<union> wrap B\<^sub>1\<close>] by (simp add: Un_assoc) also have "... \<le> card P + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using P\<^sub>1_B\<^sub>1_lower_bound_card[OF assms(3) invrules(1,3)] by simp also have "... \<le> card P + card P / 2" using P\<^sub>2_B\<^sub>2_lower_bound_P\<^sub>1[OF invrules(1,4,3)]
      and P\<^sub>1_lower_bound_card[OF assms(3) invrules(1,3)] by linarith finally show ?thesis by linarith next note invrules = inv\<^sub>2E[OF assms(2)] case False have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> S \<union> L})
      = card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> L} \<union> P\<^sub>2 \<union> wrap B\<^sub>2)" using assms(1) by (simp add: Un_commute Un_assoc) also have "... \<le> card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> L}) + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using card_Un_le[of \<open>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> {{v} |v. v \<in> L}\<close>] by (simp add: Un_assoc) also have "... \<le> card P + card (P\<^sub>2 \<union> wrap B\<^sub>2)" using L_bins_lower_bound_card[OF assms(3) invrules(1) invrules(2)[OF False] invrules(5)] by linarith also have "... \<le> card P + card P / 2" using P\<^sub>2_B\<^sub>2_lower_bound_P\<^sub>1[OF invrules(1,4,3)]
      and P\<^sub>1_lower_bound_card[OF assms(3) invrules(1,3)] by linarith finally show ?thesis by linarith qed definition inv\<^sub>3 :: "'a set set \<Rightarrow> 'a set set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L \<longleftrightarrow> inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L \<and> B\<^sub>2 \<subseteq> S\<^sub>U"</code></pre>
<b>Generated proof:</b><pre><code>```
lemma bin_packing_lower_bound_card:
  assumes "S = {}" "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" "bp P"
  shows "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> S \<union> L}) \<le> 3 / 2 * card P"
proof -
  have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> S \<union> L}) = card (P\<^sub>1 \<union> P\<^sub>2) + card (wrap B\<^sub>1 \<union> wrap B\<^sub>2) + card {{v} |v. v \<in> S \<union> L}"
    by (simp add: card_union)
  also have "card (wrap B\<^sub>1 \<union> wrap B\<^sub>2) = card B\<^sub>1 + card B\<^sub>2"
    by (simp add: card_wrap)
  moreover have "card {{v} |v. v \<in> S \<union> L} \<le> card S + card L"
    by (simp add: card_subset)
  ultimately have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> S \<union> L}) \<le> card (P\<^sub>1 \<union> P\<^sub>2) + card B\<^sub>1 + card B\<^sub>2 + card S + card L"
    by (simp add: card_add)
  moreover have "card (P\<^sub>1 \<union> P\<^sub>2) \<le> 2 * card P"
    by (simp add: card_union)
  moreover have "card B\<^sub>1 + card B\<^sub>2 \<le> card P"
    by (simp add: card_wrap)
  moreover have "card S + card L \<le> card P"
    by (simp add: card_subset)
  ultimately have "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> S \<union> L}) \<le> 3 * card P"
    by (simp add: card_add)
  thus "card (P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> S \<union> L}) \<le> 3 / 2 * card P"
    by (simp add: card_divide)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.44
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (71%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>3E:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L"
  shows "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" and "B\<^sub>2 \<subseteq> S\<^sub>U"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>3_def by blast+</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule inv3E)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (72%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>3I:
  assumes "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" and "B\<^sub>2 \<subseteq> S\<^sub>U"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>3_def by blast</code></pre>
<b>Generated proof:</b><pre><code>```
lemma inv_3I:
  assumes "inv_2 P_1 P_2 B_1 B_2 S L" and "B_2 ⊆ S_U"
  shows "inv_3 P_1 P_2 B_1 B_2 S L"
proof -
  from assms(1) have "inv_2 P_1 P_2 B_1 B_2 S L" by auto
  moreover,
  from assms(2) have "B_2 ⊆ S_U" by auto
  ultimately,
  have "inv_3 P_1 P_2 B_1 B_2 S L" by auto
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.23
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (73%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_init:
  "inv\<^sub>3 {} {} {} {} S\<^sub>U L\<^sub>U"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "S\<^sub>U \<union> L\<^sub>U = U" by auto then have *: "inv\<^sub>1 {} {} {} {} (S\<^sub>U \<union> L\<^sub>U)" unfolding bp_def partition_on_def pairwise_def wrap_def inv\<^sub>1_def using weight by auto have "bij_exists {} (\<Union> ({} \<union> wrap {}))" using bij_betwI' unfolding bij_exists_def by fastforce from inv\<^sub>2I[OF * _ this] have "inv\<^sub>2 {} {} {} {} S\<^sub>U L\<^sub>U" by auto from inv\<^sub>3I[OF this] show ?thesis by blast qed</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)
  apply (rule loop_init)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but identifier Proof (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.38
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (74%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_stepA:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" "B\<^sub>1 = {}" "L = {}" "u \<in> S"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (S - {u}) L"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] have WEIGHT: "W B\<^sub>1 + w u \<le> c" using invrules(5) assms(2,4) by fastforce from assms(4) have "u \<in> S \<union> L" by blast from inv\<^sub>1_stepA[OF invrules(1) this WEIGHT] assms(2,3) have 1: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (S - {u} \<union> L)" by simp have 2: "L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap {u}. B \<inter> L\<^sub>U \<noteq> {}" using assms(3) by blast from inv\<^sub>2I[OF 1 2] invrules have "inv\<^sub>2 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (S - {u}) L" by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] . qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, hide_lams) inv_def P_def S_def B_def L_def u_def)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.43
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (75%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_stepB:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" "B\<^sub>1 = {}" "u \<in> L"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 S (L - {u})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] have WEIGHT: "W B\<^sub>1 + w u \<le> c" using weight invrules(5) assms(2,3) by fastforce

  \<comment> \<open>This observation follows from the fact that the \<open>S\<close> and \<open>L\<close> sets have to be disjoint from each other,
      and allows us to reuse our proofs of the preservation of \<open>inv\<^sub>1\<close> by simply replacing \<open>V\<close> with \<open>S \<union> L\<close>\<close> have *: "S \<union> L - {u} = S \<union> (L - {u})" using invrules(5) assms(3) by force from assms(3) have "u \<in> S \<union> L" by blast from inv\<^sub>1_stepA[OF invrules(1) this WEIGHT] assms(2) * have 1: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 (S \<union> (L - {u}))" by simp have "\<forall>B\<in>P\<^sub>1. B \<inter> L\<^sub>U \<noteq> {}" "{u} \<inter> L\<^sub>U \<noteq> {}" using assms(3) invrules(2,5) by blast+ then have 2: "L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap {u}. B \<inter> L\<^sub>U \<noteq> {}" using assms(3) by (metis (full_types) Un_iff empty_iff insert_iff wrap_not_empty) from inv\<^sub>2I[OF 1 2] invrules have "inv\<^sub>2 P\<^sub>1 P\<^sub>2 {u} B\<^sub>2 S (L - {u})" by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv<^sub>3 P<^sub>1 P<^sub>2 B<^sub>1 B<^sub>2 S L" "B<^sub>1 = {}" "u ∈ L"
  then have "inv<^sub>3 P<^sub>1 P<^sub>2 {} B<^sub>2 S (L - {u})"
    using assms by (simp add: inv<^sub>3_def)
  moreover have "B<^sub>2 = B<^sub>2"
    using assms by (simp add: inv<^sub>3_def)
  ultimately have "inv<^sub>3 P<^sub>1 P<^sub>2 {u} B<^sub>2 S (L - {u})"
    using assms by (simp add: inv<^sub>3_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
*** At command "by" (line 245 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.38
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (76%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_stepC:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" "B\<^sub>1 \<noteq> {}" "u \<in> S" "W B\<^sub>1 + w(u) \<le> c"
  shows "inv\<^sub>3 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (S - {u}) L"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]]

  \<comment> \<open>Same approach, but removing \<open>{u}\<close> from \<open>S\<close> instead of \<open>L\<close>\<close> have *: "S \<union> L - {u} = (S - {u}) \<union> L" using invrules(5) assms(3) by force from assms(3) have "u \<in> S \<union> L" by blast from inv\<^sub>1_stepA[OF invrules(1) this assms(4)] * have 1: "inv\<^sub>1 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (S - {u} \<union> L)" by simp have "L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. B \<inter> L\<^sub>U \<noteq> {}" using invrules(2) by blast then have 2: "L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap (B\<^sub>1 \<union> {u}). B \<inter> L\<^sub>U \<noteq> {}" by (smt Int_insert_left Un_empty_right Un_iff Un_insert_right assms(2) insert_not_empty singletonD singletonI wrap_def) from inv\<^sub>2I[OF 1 2] invrules have "inv\<^sub>2 P\<^sub>1 P\<^sub>2 (B\<^sub>1 \<union> {u}) B\<^sub>2 (S - {u}) L" by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv<^sub>3 P<^sub>1 P<^sub>2 B<^sub>1 B<^sub>2 S L" "B<^sub>1 ≠ {}" "u ∈ S" "W B<^sub>1 + w(u) ≤ c"
  hence "B<^sub>1 ∪ {u} ⊆ S" by (simp add: assms(2))
  hence "B<^sub>1 ∪ {u} ≠ {}" by (simp add: assms(2))
  hence "inv<^sub>3 P<^sub>1 P<^sub>2 (B<^sub>1 ∪ {u}) B<^sub>2 (S - {u}) L" by (metis assms(1) inv<^sub>3.def)
  thus "inv<^sub>3 P<^sub>1 P<^sub>2 (B<^sub>1 ∪ {u}) B<^sub>2 (S - {u}) L" by (simp add: assms(1))
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.43
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (77%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_stepD:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" "B\<^sub>1 \<noteq> {}" "u \<in> S" "W B\<^sub>1 + w(u) > c" "W B\<^sub>2 + w(u) \<le> c"
  shows "inv\<^sub>3 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (S - {u}) L"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] have *: "S \<union> L - {u} = (S - {u}) \<union> L" using invrules(5) assms(3) by force from assms(3) have "u \<in> S \<union> L" by blast from inv\<^sub>1_stepB[OF invrules(1) this assms(5)] * have 1: "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (S - {u} \<union> L)" by simp have 2: "L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}. B \<inter> L\<^sub>U \<noteq> {}" using invrules(2) unfolding wrap_empty by blast from invrules(3) obtain f where f_def: "bij_betw f P\<^sub>1 (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" "\<forall>B\<in>P\<^sub>1. c < W B + w (f B)" unfolding bij_exists_def by blast have "B\<^sub>1 \<notin> P\<^sub>1" using inv\<^sub>1E(3)[OF invrules(1)] by blast have "u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" using inv\<^sub>1E(2)[OF invrules(1)] assms(3) by blast then have "(\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}))) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}}))" by (metis Sup_empty Un_assoc Union_Un_distrib ccpo_Sup_singleton wrap_empty wrap_not_empty) also have "... = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" by simp finally have UN: "(\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u}))) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" . have "wrap B\<^sub>1 = {B\<^sub>1}" using wrap_not_empty[of B\<^sub>1] assms(2) by simp let ?f = "f (B\<^sub>1 := u)" have BIJ: "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})))" unfolding wrap_empty \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> UN using f_def(1) \<open>B\<^sub>1 \<notin> P\<^sub>1\<close> \<open>u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))\<close> by (metis (no_types, lifting) bij_betw_cong fun_upd_other fun_upd_same notIn_Un_bij_betw3) have "c < W B\<^sub>1 + w (?f B\<^sub>1)" using assms(4) by simp then have "(\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" unfolding \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> using f_def(2) by simp with BIJ have "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})))
              \<and> (\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" by blast then have 3: "bij_exists (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap (B\<^sub>2 \<union> {u})))" unfolding bij_exists_def by blast from inv\<^sub>2I[OF 1 2 3] have "inv\<^sub>2 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (S - {u}) L" using invrules(4,5) by blast from inv\<^sub>3I[OF this] show ?thesis using inv\<^sub>3E(2)[OF assms(1)] assms(3) invrules(5) by blast qed</code></pre>
<b>Generated proof:</b><pre><code><proof>
apply (rule loop_stepD)
assume "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L"
assume "B\<^sub>1 \<noteq> {}"
assume "u \<in> S"
assume "W B\<^sub>1 + w(u) > c"
assume "W B\<^sub>2 + w(u) \<le> c"
show "inv\<^sub>3 (P\<^sub>1 \<union> wrap B\<^sub>1) P\<^sub>2 {} (B\<^sub>2 \<union> {u}) (S - {u}) L"
by (metis (no_types, lifting))
</proof></s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but keyword < (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.36
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (78%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma B\<^sub>2_at_least_two_objects:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" "u \<in> S" "W B\<^sub>2 + w(u) > c"
  shows "2 \<le> card B\<^sub>2"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (rule ccontr, simp add: not_le) have FINITE: "finite B\<^sub>2" using inv\<^sub>1E(1)[OF inv\<^sub>2E(1)[OF inv\<^sub>3E(1)[OF assms(1)]]] by (metis (no_types, lifting) Finite_Set.finite.simps U_Finite Union_Un_distrib bpE(3) ccpo_Sup_singleton finite_Un wrap_not_empty) assume "card B\<^sub>2 < 2" then consider (0) "card B\<^sub>2 = 0" | (1) "card B\<^sub>2 = 1" by linarith then show False proof cases case 0 then have "B\<^sub>2 = {}" using FINITE by simp then show ?thesis using assms(2,3) inv\<^sub>2E(5)[OF inv\<^sub>3E(1)[OF assms(1)]] by force next case 1 then obtain v where "B\<^sub>2 = {v}" using card_1_singletonE by auto with inv\<^sub>3E(2)[OF assms(1)] have "2 * w v \<le> c" using inv\<^sub>2E(5)[OF inv\<^sub>3E(1)[OF assms(1)]] by simp moreover from \<open>B\<^sub>2 = {v}\<close> have "W B\<^sub>2 = w v" by simp ultimately show ?thesis using assms(2,3) inv\<^sub>2E(5)[OF inv\<^sub>3E(1)[OF assms(1)]] by force qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma B2_at_least_two_objects:
  assumes "inv3 P1 P2 B1 B2 S L" "u ∈ S" "W B2 + w(u) > c"
  shows "2 ≤ card B2"
proof -
  from assms have "W B2 + w(u) > c" by (rule assms)
  moreover have "u ∈ S" by (rule assms)
  then have "W B2 + w(u) > c" by (rule assms)
  then have "2 ≤ card B2" by (rule assms)
  thus "2 ≤ card B2" by (rule assms)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but back-quoted string `` (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:26 cpu time, factor 3.36
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (79%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_stepE:
  assumes "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" "B\<^sub>1 \<noteq> {}" "u \<in> S" "W B\<^sub>1 + w(u) > c" "W B\<^sub>2 + w(u) > c"
  shows "inv\<^sub>3 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (S - {u}) L"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>2E[OF inv\<^sub>3E(1)[OF assms(1)]] have *: "S \<union> L - {u} = (S - {u}) \<union> L" using invrules(5) assms(3) by force from assms(3) have "u \<in> S \<union> L" by blast from inv\<^sub>1_stepC[OF invrules(1) this] * have 1: "inv\<^sub>1 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (S - {u} \<union> L)" by simp have 2: "L \<noteq> {} \<Longrightarrow> \<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1 \<union> wrap {}. B \<inter> L\<^sub>U \<noteq> {}" using invrules(2) unfolding wrap_empty by blast from invrules(3) obtain f where f_def: "bij_betw f P\<^sub>1 (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" "\<forall>B\<in>P\<^sub>1. c < W B + w (f B)" unfolding bij_exists_def by blast have "B\<^sub>1 \<notin> P\<^sub>1" using inv\<^sub>1E(3)[OF invrules(1)] by blast have "u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" using inv\<^sub>1E(2)[OF invrules(1)] assms(3) by blast have "(\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u})) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{u}}))" unfolding wrap_def by simp also have "... = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" by simp finally have UN: "(\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u})) = (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2)) \<union> {u}" . have "wrap B\<^sub>1 = {B\<^sub>1}" using wrap_not_empty[of B\<^sub>1] assms(2) by simp let ?f = "f (B\<^sub>1 := u)" have BIJ: "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}))" unfolding wrap_empty \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> UN using f_def(1) \<open>B\<^sub>1 \<notin> P\<^sub>1\<close> \<open>u \<notin> (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))\<close> by (metis (no_types, lifting) bij_betw_cong fun_upd_other fun_upd_same notIn_Un_bij_betw3) have "c < W B\<^sub>1 + w (?f B\<^sub>1)" using assms(4) by simp then have "(\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" unfolding \<open>wrap B\<^sub>1 = {B\<^sub>1}\<close> using f_def(2) by simp with BIJ have "bij_betw ?f (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}))
              \<and> (\<forall>B\<in>P\<^sub>1 \<union> wrap B\<^sub>1. c < W B + w (?f B))" by blast then have 3: "bij_exists (P\<^sub>1 \<union> wrap B\<^sub>1) (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2 \<union> wrap {u}))" unfolding bij_exists_def by blast have 4: "2 * card (P\<^sub>2 \<union> wrap B\<^sub>2) \<le> card (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" proof - note bprules = bpE[OF inv\<^sub>1E(1)[OF invrules(1)]] have "pairwise disjnt (P\<^sub>2 \<union> wrap B\<^sub>2)" using bprules(1) pairwise_subset by blast moreover have "B\<^sub>2 \<notin> P\<^sub>2" using inv\<^sub>1E(4)[OF invrules(1)] by simp ultimately have DISJNT: "\<Union>P\<^sub>2 \<inter> B\<^sub>2 = {}" by (auto, metis (no_types, hide_lams) sup_bot.right_neutral Un_insert_right disjnt_iff mk_disjoint_insert pairwise_insert wrap_Un) have "finite (\<Union>P\<^sub>2)" using U_Finite bprules(3) by auto have "finite B\<^sub>2" using inv\<^sub>1E(1)[OF invrules(1)] bp_bins_finite wrap_not_empty by blast have "2 * card (P\<^sub>2 \<union> wrap B\<^sub>2) \<le> 2 * (card P\<^sub>2 + card (wrap B\<^sub>2))" using card_Un_le[of P\<^sub>2 \<open>wrap B\<^sub>2\<close>] by simp also have "... \<le> 2 * card P\<^sub>2 + 2" using wrap_card by auto also have "... \<le> card (\<Union> P\<^sub>2) + 2" using invrules(4) by simp also have "... \<le> card (\<Union> P\<^sub>2) + card B\<^sub>2" using B\<^sub>2_at_least_two_objects[OF assms(1,3,5)] by simp also have "... = card (\<Union> (P\<^sub>2 \<union> {B\<^sub>2}))" using DISJNT card_Un_disjoint[OF \<open>finite (\<Union>P\<^sub>2)\<close> \<open>finite B\<^sub>2\<close>] by (simp add: Un_commute) also have "... = card (\<Union> (P\<^sub>2 \<union> wrap B\<^sub>2))" by (cases \<open>B\<^sub>2 = {}\<close>) auto finally show ?thesis . qed from inv\<^sub>2I[OF 1 2 3 4] have "inv\<^sub>2 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (S - {u}) L" using invrules(5) by blast from inv\<^sub>3I[OF this] show ?thesis using assms(3) invrules(5) by blast qed text \<open>The bin packing algorithm as it is proposed on page 78 of the article @{cite BerghammerR03}.
      \<open>P\<close> will not only be a correct solution of the bin packing problem, but the amount of bins
      will be a lower bound for \<open>3 / 2\<close> of the amount of bins of any correct solution \<open>Q\<close>, and thus
      guarantee an approximation factor of \<open>3 / 2\<close> for the optimum.\<close></code></pre>
<b>Generated proof:</b><pre><code><proof>
apply (rule loop_stepE)
assume "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" "B\<^sub>1 \<noteq> {}" "u \<in> S" "W B\<^sub>1 + w(u) > c" "W B\<^sub>2 + w(u) > c"
then show "inv\<^sub>3 (P\<^sub>1 \<union> wrap B\<^sub>1) (P\<^sub>2 \<union> wrap B\<^sub>2) {} {u} (S - {u}) L"
by (auto simp: inv\<^sub>3.def)
</proof></s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): command expected,
*** but keyword < (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy") was found
*** At command "<malformed>" (line 1708 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.31
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (80%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bp_approx:
"VARS P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V S L u
  {True}
  S := {}; L:= {}; V := U;
  WHILE V \<noteq> {} INV {V \<subseteq> U \<and> S = {u \<in> U - V. w(u) \<le> c / 2} \<and> L = {u \<in> U - V. c / 2 < w(u)}} DO
    u := (SOME u. u \<in> V);
    IF w(u) \<le> c / 2
    THEN S := S \<union> {u}
    ELSE L := L \<union> {u} FI;
    V := V - {u}
  OD;
  P\<^sub>1 := {}; P\<^sub>2 := {}; B\<^sub>1 := {}; B\<^sub>2 := {};
  WHILE S \<noteq> {} INV {inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L} DO 
    IF B\<^sub>1 \<noteq> {}
    THEN u := (SOME u. u \<in> S); S := S - {u}
    ELSE IF L \<noteq> {}
         THEN u := (SOME u. u \<in> L); L := L - {u}
         ELSE u := (SOME u. u \<in> S); S := S - {u} FI FI;
    IF W(B\<^sub>1) + w(u) \<le> c
    THEN B\<^sub>1 := B\<^sub>1 \<union> {u}
    ELSE IF W(B\<^sub>2) + w(u) \<le> c
         THEN B\<^sub>2 := B\<^sub>2 \<union> {u}
         ELSE P\<^sub>2 := P\<^sub>2 \<union> wrap B\<^sub>2; B\<^sub>2 := {u} FI;
         P\<^sub>1 := P\<^sub>1 \<union> wrap B\<^sub>1; B\<^sub>1 := {} FI
  OD;
  P := P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2; V := L;
  WHILE V \<noteq> {}
  INV {S = {} \<and> inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L \<and> V \<subseteq> L \<and> P = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v}|v. v \<in> L - V}} DO
    u := (SOME u. u \<in> V); P := P \<union> {{u}}; V := V - {u}
  OD
  {bp P \<and> (\<forall>Q. bp Q \<longrightarrow> card P \<le> 3 / 2 * card Q)}"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (vcg, goal_cases) case (1 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V S L u) then show ?case by blast next case (2 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V S L u) then show ?case by (auto simp: some_in_eq) next case (3 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V S L u) then show ?case using loop_init by force next case (4 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V S L u) then have INV: "inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" .. let ?s = "SOME u. u \<in> S" let ?l = "SOME u. u \<in> L" note SL_def = inv\<^sub>2E(5)[OF inv\<^sub>3E(1)[OF INV]] have LIN: "L \<noteq> {} \<Longrightarrow> ?l \<in> L" using some_in_eq by metis then have LWEIGHT: "L \<noteq> {} \<Longrightarrow> w ?l \<le> c" using weight SL_def by blast from 4 have "S \<noteq> {}" .. then have IN: "?s \<in> S" using some_in_eq by metis then have "w ?s \<le> c" using SL_def by auto then show ?case using LWEIGHT loop_stepA[OF INV _ _ IN] loop_stepB[OF INV _ LIN] loop_stepC[OF INV _ IN]
      and loop_stepD[OF INV _ IN] loop_stepE[OF INV _ IN] by (cases \<open>B\<^sub>1 = {}\<close>, cases \<open>L = {}\<close>) auto next case (5 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V S L u) then show ?case by blast next case (6 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V S L u) then have *: "(SOME u. u \<in> V) \<in> V" "(SOME u. u \<in> V) \<in> L" by (auto simp add: some_in_eq) then have "P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> L - (V - {SOME u. u \<in> V})}
           = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v} |v. v \<in> L - V \<union> {SOME u. u \<in> V}}" by blast with 6 * show ?case by blast next case (7 P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V S L u) then have *: "inv\<^sub>2 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L" using inv\<^sub>3E(1) by blast from inv\<^sub>1E(1)[OF inv\<^sub>2E(1)[OF *]] 7 have "bp P" by fastforce with bin_packing_lower_bound_card[OF _ *] 7 show ?case by fastforce qed end (* BinPacking_Complete *) end (* Theory *)</code></pre>
<b>Generated proof:</b><pre><code>proof -
  (* Introduce the theorem *)
  have "bp P \<and> (\<forall>Q. bp Q \<longrightarrow> card P \<le> 3 / 2 * card Q)"
  proof -
    (* Introduce the necessary variables and initial conditions *)
    let
      VARS P P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 V S L u
      = "{}"
    in
    (* Define the initial conditions *)
    S := {}; L:= {}; V := U;
    (* Define the first while loop *)
    WHILE V \<noteq> {} INV {V \<subseteq> U \<and> S = {u \<in> U - V. w(u) \<le> c / 2} \<and> L = {u \<in> U - V. c / 2 < w(u)}} DO
      (* Define the selection of u *)
      u := (SOME u. u \<in> V);
      (* Define the condition for adding u to S or L *)
      IF w(u) \<le> c / 2
      THEN S := S \<union> {u}
      ELSE L := L \<union> {u} FI;
      (* Remove u from V *)
      V := V - {u}
    OD;
    (* Define the second while loop *)
    P\<^sub>1 := {}; P\<^sub>2 := {}; B\<^sub>1 := {}; B\<^sub>2 := {};
    WHILE S \<noteq> {} INV {inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L} DO
      (* Define the selection of u *)
      IF B\<^sub>1 \<noteq> {}
      THEN u := (SOME u. u \<in> S); S := S - {u}
      ELSE IF L \<noteq> {}
           THEN u := (SOME u. u \<in> L); L := L - {u}
           ELSE u := (SOME u. u \<in> S); S := S - {u} FI FI;
      (* Define the condition for adding u to B\<^sub>1 or B\<^sub>2 *)
      IF W(B\<^sub>1) + w(u) \<le> c
      THEN B\<^sub>1 := B\<^sub>1 \<union> {u}
      ELSE IF W(B\<^sub>2) + w(u) \<le> c
           THEN B\<^sub>2 := B\<^sub>2 \<union> {u}
           ELSE P\<^sub>2 := P\<^sub>2 \<union> wrap B\<^sub>2; B\<^sub>2 := {u} FI;
           P\<^sub>1 := P\<^sub>1 \<union> wrap B\<^sub>1; B\<^sub>1 := {} FI
    OD;
    (* Define the final condition for P *)
    P := P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2; V := L;
    (* Define the final while loop *)
    WHILE V \<noteq> {}
    INV {S = {} \<and> inv\<^sub>3 P\<^sub>1 P\<^sub>2 B\<^sub>1 B\<^sub>2 S L \<and> V \<subseteq> L \<and> P = P\<^sub>1 \<union> wrap B\<^sub>1 \<union> P\<^sub>2 \<union> wrap B\<^sub>2 \<union> {{v}|v. v \<in> L - V}} DO
      (* Define the selection of u *)
      u := (SOME u. u \<in> V); P := P \<union> {{u}}; V := V - {u}
    OD
    (* Conclude the proof *)
    hence "bp P \<and> (\<forall>Q. bp Q \<longrightarrow> card P \<le> 3 / 2 * card Q)" by auto
  qed
qed</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy"): missing theory context for command "proof"
*** At command "<malformed>" (line 1709 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_BP_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:07 elapsed time, 0:00:25 cpu time, factor 3.51
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (81%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/Approximation_Algorithms/_home_qj213_afp-2021-10-22_thys_Approximation_Algorithms_Approx_LB_Hoare_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma sum_le_card_Max: "\<lbrakk> finite A; A \<noteq> {} \<rbrakk> \<Longrightarrow> sum f A \<le> card A * Max (f ` A)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(induction A rule: finite_ne_induct) case (singleton x) then show ?case by simp next case (insert x F) then show ?case by (auto simp: max_def order.trans[of "sum f F" "card F * Max (f ` F)"]) qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis card_Max_le_sum finite_sum_le_card_Max)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 15 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 15 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 14 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:30 cpu time, factor 3.52
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (82%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Max_const[simp]: "\<lbrakk> finite A; A \<noteq> {} \<rbrakk> \<Longrightarrow> Max ((\<lambda>_. c) ` A) = c"</h2><br>
<b>Ground proof:</b> <br><pre><code>using Max_in image_is_empty by blast abbreviation Max\<^sub>0 :: "nat set \<Rightarrow> nat" where
"Max\<^sub>0 N \<equiv> (if N={} then 0 else Max N)" fun f_Max\<^sub>0 :: "(nat \<Rightarrow> nat) \<Rightarrow> nat \<Rightarrow> nat" where
  "f_Max\<^sub>0 f 0 = 0"
| "f_Max\<^sub>0 f (Suc x) = max (f (Suc x)) (f_Max\<^sub>0 f x)"</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types) "Max.idtac[of c]" "Max_def" "Max_finite")
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 24 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 24 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 23 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.53
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (83%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma f_Max\<^sub>0_equiv: "f_Max\<^sub>0 f n = Max\<^sub>0 (f ` {1..n})"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (induction n) (auto simp: not_le atLeastAtMostSuc_conv)</code></pre>
<b>Generated proof:</b><pre><code>```
by (induct n) (auto simp: f_Max\<^sub>0_def)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 33 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:30 cpu time, factor 3.61
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (84%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma f_Max\<^sub>0_correct:
  "\<forall>x \<in> {1..m}. T x \<le> f_Max\<^sub>0 T m"
  "m > 0 \<Longrightarrow> \<exists>x \<in> {1..m}. T x = f_Max\<^sub>0 T m"</h2><br>
<b>Ground proof:</b> <br><pre><code>apply (induction m) apply simp_all apply (metis atLeastAtMost_iff le_Suc_eq max.cobounded1 max.coboundedI2) subgoal for m by (cases \<open>m = 0\<close>) (auto simp: max_def) done</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types) f_Max\<^sub>0_def f_Max\<^sub>0_mono)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.66
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (85%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma f_Max\<^sub>0_mono:
  "y \<le> T x \<Longrightarrow> f_Max\<^sub>0 (T (x := y)) m \<le> f_Max\<^sub>0 T m"
  "T x \<le> y \<Longrightarrow> f_Max\<^sub>0 T m \<le> f_Max\<^sub>0 (T (x := y)) m"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (induction m) auto</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume y \<le> T x
2. By definition of f_Max\<^sub>0, we have f_Max\<^sub>0 (T (x := y)) m \<le> f_Max\<^sub>0 T m
3. Therefore, the first part of the theorem is proved.
4. Assume T x \<le> y
5. By definition of f_Max\<^sub>0, we have f_Max\<^sub>0 T m \<le> f_Max\<^sub>0 (T (x := y)) m
6. Therefore, the second part of the theorem is proved.

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but identifier Proof (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.61
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (86%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma f_Max\<^sub>0_out_of_range [simp]:
  "x \<notin> {1..k} \<Longrightarrow> f_Max\<^sub>0 (T (x := y)) k = f_Max\<^sub>0 T k"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (induction k) auto</code></pre>
<b>Generated proof:</b><pre><code>Proof:
1. Assume x \<notin> {1..k}
2. By definition of f_Max\<^sub>0, we have f_Max\<^sub>0 (T (x := y)) k = f_Max\<^sub>0 T k
3. Therefore, x \<notin> {1..k} \<Longrightarrow> f_Max\<^sub>0 (T (x := y)) k = f_Max\<^sub>0 T k

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but identifier Proof (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:32 cpu time, factor 3.61
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (87%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma fun_upd_f_Max\<^sub>0:
  assumes "x \<in> {1..m}" "T x \<le> y"
  shows "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms by (induction m) auto locale LoadBalancing = (* Load Balancing *)
  fixes t :: "nat \<Rightarrow> nat"
    and m :: nat
    and n :: nat
  assumes m_gt_0: "m > 0"
begin subsection \<open>Formalization of a Correct Load Balancing\<close> subsubsection \<open>Definition\<close> definition lb :: "(nat \<Rightarrow> nat) \<Rightarrow> (nat \<Rightarrow> nat set) \<Rightarrow> nat \<Rightarrow> bool" where
  "lb T A j = ((\<forall>x \<in> {1..m}. \<forall>y \<in> {1..m}. x \<noteq> y \<longrightarrow> A x \<inter> A y = {}) \<comment> \<open>No job is assigned to more than one machine\<close>
             \<and> (\<Union>x \<in> {1..m}. A x) = {1..j} \<comment> \<open>Every job is assigned\<close>
             \<and> (\<forall>x \<in> {1..m}. (\<Sum>j \<in> A x. t j) = T x) \<comment> \<open>The processing times sum up to the correct load\<close>)" abbreviation makespan :: "(nat \<Rightarrow> nat) \<Rightarrow> nat" where
  "makespan T \<equiv> f_Max\<^sub>0 T m"</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "x \<in> {1..m}" "T x \<le> y"
  have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
  proof -
    have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
    proof -
      have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
      proof -
        have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
        proof -
          have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
          proof -
            have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
            proof -
              have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
              proof -
                have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                proof -
                  have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                  proof -
                    have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                    proof -
                      have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                      proof -
                        have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                        proof -
                          have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                          proof -
                            have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                            proof -
                              have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                              proof -
                                have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                proof -
                                  have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                  proof -
                                    have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                    proof -
                                      have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                      proof -
                                        have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                        proof -
                                          have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                          proof -
                                            have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                            proof -
                                              have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                              proof -
                                                have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                proof -
                                                  have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                  proof -
                                                    have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                    proof -
                                                      have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                      proof -
                                                        have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                        proof -
                                                          have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                          proof -
                                                            have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                            proof -
                                                              have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                              proof -
                                                                have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                proof -
                                                                  have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                  proof -
                                                                    have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                    proof -
                                                                      have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                      proof -
                                                                        have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                        proof -
                                                                          have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                          proof -
                                                                            have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                            proof -
                                                                              have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                              proof -
                                                                                have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                                proof -
                                                                                  have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                                  proof -
                                                                                    have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                                    proof -
                                                                                      have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                                      proof -
                                                                                        have "f_Max\<^sub>0 (T (x := y)) m = max y (f_Max\<^sub>0 T m)"
                                                                                        proof -</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.66
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (88%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma makespan_def': "makespan T = Max (T ` {1..m})"</h2><br>
<b>Ground proof:</b> <br><pre><code>using m_gt_0 by (simp add: f_Max\<^sub>0_equiv) (*
lemma makespan_correct:
  "\<forall>x \<in> {1..m}. T x \<le> makespan T m"
  "m > 0 \<Longrightarrow> \<exists>x \<in> {1..m}. T x = makespan T m"
   apply (induction m)
     apply simp_all
   apply (metis atLeastAtMost_iff le_Suc_eq max.cobounded1 max.coboundedI2)
  subgoal for m by (cases \<open>m = 0\<close>) (auto simp: max_def)
  done

lemma no_machines_lb_iff_no_jobs: "lb T A j 0 \<longleftrightarrow> j = 0"
  unfolding lb_def by auto

lemma machines_if_jobs: "\<lbrakk> lb T A j m; j > 0 \<rbrakk> \<Longrightarrow> m > 0"
  using no_machines_lb_iff_no_jobs by (cases m) auto
*)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule makespan_def)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 79 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 79 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 78 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.66
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (89%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma makespan_correct:
  "\<forall>x \<in> {1..m}. T x \<le> makespan T"
  "\<exists>x \<in> {1..m}. T x = makespan T"</h2><br>
<b>Ground proof:</b> <br><pre><code>using f_Max\<^sub>0_correct m_gt_0 by auto</code></pre>
<b>Generated proof:</b><pre><code>```
lemma makespan_correct:
  "\<forall>x \<in> {1..m}. T x \<le> makespan T"
  "\<exists>x \<in> {1..m}. T x = makespan T"
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=makespan T)
  apply(rule_tac x=</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 52 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** exception Option raised (line 84 of "General/basics.ML")
*** At command "by" (line 48 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:30 cpu time, factor 3.65
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (90%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lbE:
  assumes "lb T A j"
  shows "\<forall>x \<in> {1..m}. \<forall>y \<in> {1..m}. x \<noteq> y \<longrightarrow> A x \<inter> A y = {}"
        "(\<Union>x \<in> {1..m}. A x) = {1..j}"
        "\<forall>x \<in> {1..m}. (\<Sum>y \<in> A x. t y) = T x"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding lb_def by blast+</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "lb T A j"
  hence "(\<Union>x \<in> {1..m}. A x) = {1..j}" by (rule lbE.2)
  hence "(\<Sum>y \<in> A x. t y) = T x" for x using "lb T A j" by (rule lbE.3)
  hence "x \<noteq> y \<longrightarrow> A x \<inter> A y = {}" for x y using "lb T A j" by (rule lbE.1)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 48 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 42 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:30 cpu time, factor 3.69
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (91%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lbI:
  assumes "\<forall>x \<in> {1..m}. \<forall>y \<in> {1..m}. x \<noteq> y \<longrightarrow> A x \<inter> A y = {}"
          "(\<Union>x \<in> {1..m}. A x) = {1..j}"
          "\<forall>x \<in> {1..m}. (\<Sum>y \<in> A x. t y) = T x"
  shows "lb T A j"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding lb_def by blast</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, lifting) assms(1) assms(2) assms(3))
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.65
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (92%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma A_lb_finite [simp]:
  assumes "lb T A j" "x \<in> {1..m}"
  shows "finite (A x)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (metis lbE(2) assms finite_UN finite_atLeastAtMost) text \<open>If \<open>A x\<close> is pairwise disjoint for all \<open>x \<in> {1..m}\<close>, then the the sum over the sums of the
      individual \<open>A x\<close> is equal to the sum over the union of all \<open>A x\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types) "finite_subset" "finite_image")
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "apply" (line 40 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.61
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (93%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sum_sum_eq_sum_Un:
  fixes A :: "nat \<Rightarrow> nat set"
  assumes "\<forall>x \<in> {1..m}. \<forall>y \<in> {1..m}. x \<noteq> y \<longrightarrow> A x \<inter> A y = {}"
      and "\<forall>x \<in> {1..m}. finite (A x)"
  shows "(\<Sum>x \<in> {1..m}. (\<Sum>y \<in> A x. t y)) = (\<Sum>x \<in> (\<Union>y \<in> {1..m}. A y). t x)"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms proof (induction m) case (Suc m) have FINITE: "finite (\<Union>x \<in> {1..m}. A x)" "finite (A (Suc m))" using Suc.prems(2) by auto have "\<forall>x \<in> {1..m}. A x \<inter> A (Suc m) = {}" using Suc.prems(1) by simp then have DISJNT: "(\<Union>x \<in> {1..m}. A x) \<inter> (A (Suc m)) = {}" using Union_disjoint by blast have "(\<Sum>x \<in> (\<Union>y \<in> {1..m}. A y). t x) + (\<Sum>x \<in> A (Suc m). t x)
      = (\<Sum>x \<in> ((\<Union>y \<in> {1..m}. A y) \<union> A (Suc m)). t x)" using sum.union_disjoint[OF FINITE DISJNT, symmetric] . also have "... = (\<Sum>x \<in> (\<Union>y \<in> {1..Suc m}. A y). t x)" by (metis UN_insert image_Suc_lessThan image_insert inf_sup_aci(5) lessThan_Suc) finally show ?case using Suc by auto qed simp text \<open>If \<open>T\<close> and \<open>A\<close> are a correct load balancing for \<open>j\<close> jobs and \<open>m\<close> machines, 
      then the sum of the loads has to be equal to the sum of the processing times of the jobs\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  let ?A = "(\<Union>y \<in> {1..m}. A y)"
  have "(\<Sum>x \<in> {1..m}. (\<Sum>y \<in> A x. t y)) = (\<Sum>x \<in> {1..m}. (\<Sum>y \<in> ?A. t y))"
    by (simp add: set_def)
  also have "(\<Sum>x \<in> {1..m}. (\<Sum>y \<in> ?A. t y)) = (\<Sum>x \<in> {1..m}. (\<Sum>y \<in> ?A. t y))"
    by (simp add: set_def)
  finally show "(\<Sum>x \<in> {1..m}. (\<Sum>y \<in> A x. t y)) = (\<Sum>x \<in> (\<Union>y \<in> {1..m}. A y). t x)"
    by (simp add: set_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.65
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (94%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lb_impl_job_sum:
  assumes "lb T A j"
  shows "(\<Sum>x \<in> {1..m}. T x) = (\<Sum>x \<in> {1..j}. t x)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note lbrules = lbE[OF assms] from assms have FINITE: "\<forall>x \<in> {1..m}. finite (A x)" by simp have "(\<Sum>x \<in> {1..m}. T x) = (\<Sum>x \<in> {1..m}. (\<Sum>y \<in> A x. t y))" using lbrules(3) by simp also have "... = (\<Sum>x \<in> {1..j}. t x)" using sum_sum_eq_sum_Un[OF lbrules(1) FINITE] unfolding lbrules(2) . finally show ?thesis . qed subsubsection \<open>Lower Bounds for the Makespan\<close> text \<open>If \<open>T\<close> and \<open>A\<close> are a correct load balancing for \<open>j\<close> jobs and \<open>m\<close> machines, then the processing time
      of any job \<open>x \<in> {1..j}\<close> is a lower bound for the load of some machine \<open>y \<in> {1..m}\<close>\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma lb_impl_job_sum:
  assumes "lb T A j"
  shows "(\<Sum>x \<in> {1..m}. T x) = (\<Sum>x \<in> {1..j}. t x)"

proof -
  have "(\<Sum>x \<in> {1..m}. T x) = (\<Sum>x \<in> {1..j}. T x) + (\<Sum>x \<in> {j+1..m}. T x)" by (simp add: sum.add_split)
  also have "(\<Sum>x \<in> {1..j}. T x) = (\<Sum>x \<in> {1..j}. t x)" by (simp add: lb_def)
  moreover have "(\<Sum>x \<in> {j+1..m}. T x) = (\<Sum>x \<in> {j+1..m}. t x)" by (simp add: lb_def)
  ultimately show "(\<Sum>x \<in> {1..m}. T x) = (\<Sum>x \<in> {1..j}. t x)" by (simp add: sum.add_split)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.69
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (95%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma job_lower_bound_machine:
  assumes "lb T A j" "x \<in> {1..j}"
  shows "\<exists>y \<in> {1..m}. t x \<le> T y"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note lbrules = lbE[OF assms(1)] have "\<exists>y \<in> {1..m}. x \<in> A y" using lbrules(2) assms(2) by blast then obtain y where y_def: "y \<in> {1..m}" "x \<in> A y" .. moreover have "finite (A y)" using assms(1) y_def(1) by simp ultimately have "t x \<le> (\<Sum>x \<in> A y. t x)" using lbrules(1) member_le_sum by fast also have "... = T y" using lbrules(3) y_def(1) by blast finally show ?thesis using y_def(1) by blast qed text \<open>As the load of any machine is a lower bound for the makespan, the processing time 
      of any job \<open>x \<in> {1..j}\<close> has to also be a lower bound for the makespan.
      Follows from @{thm [source] job_lower_bound_machine} and @{thm [source] makespan_correct}.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "lb T A j" "x \<in> {1..j}"
  hence "x \<in> {1..j}" by auto
  hence "t x \<le> T j" by (rule lb_def)
  hence "t x \<le> T m" by (rule lb_def)
  hence "t x \<le> T y" for y = m by auto
  therefore "\<exists>y \<in> {1..m}. t x \<le> T y" by blast
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 42 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:32 cpu time, factor 3.63
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (96%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma job_lower_bound_makespan:
  assumes "lb T A j" "x \<in> {1..j}"
  shows "t x \<le> makespan T"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (meson job_lower_bound_machine[OF assms] makespan_correct(1) le_trans) text \<open>The makespan over \<open>j\<close> jobs is a lower bound for the makespan of any correct load balancing for \<open>j\<close> jobs.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "lb T A j" "x \<in> {1..j}"
  hence "t x \<le> makespan T" by (rule job_lower_bound_makespan)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 52 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 57 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.67
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (97%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma max_job_lower_bound_makespan:
  assumes "lb T A j"
  shows "Max\<^sub>0 (t ` {1..j}) \<le> makespan T"</h2><br>
<b>Ground proof:</b> <br><pre><code>using job_lower_bound_makespan[OF assms] by fastforce</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "lb T A j"
  hence "Max\<^sub>0 (t ` {1..j}) \<le> makespan T" by (simp add: max_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.61
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (98%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma job_dist_lower_bound_makespan:
  assumes "lb T A j"
  shows "(\<Sum>x \<in> {1..j}. t x) / m \<le> makespan T"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "(\<Sum>x \<in> {1..j}. t x) \<le> m * makespan T" using assms lb_impl_job_sum[symmetric]
      and sum_le_card_Max[of "{1..m}"] m_gt_0 by (simp add: makespan_def') then have "real (\<Sum>x \<in> {1..j}. t x) \<le> real m * real (makespan T)" using of_nat_mono by fastforce then show ?thesis by (simp add: field_simps m_gt_0) qed subsection \<open>The Greedy Approximation Algorithm\<close> text \<open>This function will perform a linear scan from \<open>k \<in> {1..m}\<close> and return the index of the machine with minimum load assuming \<open>m > 0\<close>\<close> fun min\<^sub>k :: "(nat \<Rightarrow> nat) \<Rightarrow> nat \<Rightarrow> nat" where
  "min\<^sub>k T 0 = 1"
| "min\<^sub>k T (Suc x) =
   (let k = min\<^sub>k T x
    in if T (Suc x) < T k then (Suc x) else k)"</code></pre>
<b>Generated proof:</b><pre><code>```
lemma job_dist_lower_bound_makespan:
  assumes "lb T A j"
  shows "(\<Sum>x \<in> {1..j}. t x) / m \<le> makespan T"

proof -
  from assms have "(\<Sum>x \<in> {1..j}. t x) / m \<le> (\<Sum>x \<in> {1..j}. t x) / j" by (simp add: div_le_div)
  also have "(\<Sum>x \<in> {1..j}. t x) / j \<le> makespan T" by (metis job_dist_lower_bound)
  finally show "(\<Sum>x \<in> {1..j}. t x) / m \<le> makespan T" by (simp add: div_le_div)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.68
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (99%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma min_correct:
  "\<forall>x \<in> {1..m}. T (min\<^sub>k T m) \<le> T x"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (induction m) (auto simp: Let_def le_Suc_eq, force)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule min_def)
```</s></code></pre><br><br>
<hr><hr><hr><hr>
<h2>lemma min_in_range:
  "k > 0 \<Longrightarrow> (min\<^sub>k T k) \<in> {1..k}"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (induction k) (auto simp: Let_def, force+)</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
lemma min_in_range:
  "k > 0 \<Longrightarrow> (min\<^sub>k T k) \<in> {1..k}"
proof
  assume "k > 0"
  then have "1 \<in> {1..k}" by (rule in_set_1)
  moreover have "k \<in> {1..k}" by (rule in_set_k)
  then have "min\<^sub>k T k \<in> {1..k}" by (rule min_in_set)
  thus "min\<^sub>k T k \<in> {1..k}" by (rule in_set_1)
qed
```</s></code></pre><br><br>
<hr><hr><hr><hr>
<h2>lemma add_job:
  assumes "lb T A j" "x \<in> {1..m}"
  shows "lb (T (x := T x + t (Suc j))) (A (x := A x \<union> {Suc j})) (Suc j)"
    (is \<open>lb ?T ?A _\<close>)</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note lbrules = lbE[OF assms(1)]

  \<comment> \<open>Rule 1: @{term ?A} pairwise disjoint\<close> have NOTIN: "\<forall>i \<in> {1..m}. Suc j \<notin> A i" using lbrules(2) assms(2) by force with lbrules(1) have "\<forall>i \<in> {1..m}. i \<noteq> x \<longrightarrow> A i \<inter> (A x \<union> {Suc j}) = {}" using assms(2) by blast then have 1: "\<forall>x \<in> {1..m}. \<forall>y \<in> {1..m}. x \<noteq> y \<longrightarrow> ?A x \<inter> ?A y = {}" using lbrules(1) by simp

  \<comment> \<open>Rule 2: @{term ?A} contains all jobs\<close> have "(\<Union>y \<in> {1..m}. ?A y) = (\<Union>y \<in> {1..m}. A y) \<union> {Suc j}" using UNION_fun_upd assms(2) by auto also have "... = {1..Suc j}" unfolding lbrules(2) by auto finally have 2: "(\<Union>y \<in> {1..m}. ?A y) = {1..Suc j}" .

  \<comment> \<open>Rule 3: @{term ?A} sums to @{term ?T}\<close> have "(\<Sum>i \<in> ?A x. t i) = (\<Sum>i \<in> A x \<union> {Suc j}. t i)" by simp moreover have "A x \<inter> {Suc j} = {}" using NOTIN assms(2) by blast moreover have "finite (A x)" "finite {Suc j}" using assms by simp+ ultimately have "(\<Sum>i \<in> ?A x. t i) = (\<Sum>i \<in> A x. t i) + (\<Sum>i \<in> {Suc j}. t i)" using sum.union_disjoint by simp also have "... = T x + t (Suc j)" using lbrules(3) assms(2) by simp finally have "(\<Sum>i \<in> ?A x. t i) = ?T x" by simp then have 3: "\<forall>i \<in> {1..m}. (\<Sum>j \<in> ?A i. t j) = ?T i" using lbrules(3) assms(2) by simp from lbI[OF 1 2 3] show ?thesis . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "lb T A j" "x \<in> {1..m}"
  hence "T x + t (Suc j) \<in> A (x := A x \<union> {Suc j})"
  by (simp add: lbD)
  moreover
  have "lb T (A (x := A x \<union> {Suc j})) (Suc j)"
  by (simp add: lbD)
  ultimately show "lb (T (x := T x + t (Suc j))) (A (x := A x \<union> {Suc j})) (Suc j)"
  by (simp add: lbD)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.68
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (100%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma makespan_mono:
  "y \<le> T x \<Longrightarrow> makespan (T (x := y)) \<le> makespan T"
  "T x \<le> y \<Longrightarrow> makespan T \<le> makespan (T (x := y))"</h2><br>
<b>Ground proof:</b> <br><pre><code>using f_Max\<^sub>0_mono by auto</code></pre>
<b>Generated proof:</b><pre><code>```
lemma makespan_mono:
  "y \<le> T x \<Longrightarrow> makespan (T (x := y)) \<le> makespan T"
  "T x \<le> y \<Longrightarrow> makespan T \<le> makespan (T (x := y))"
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_tac[OF makespan_mono])
  apply (rule_</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 48 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "apply" (line 40 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.66
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (101%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma smaller_optimum:
  assumes "lb T A (Suc j)"
  shows "\<exists>T' A'. lb T' A' j \<and> makespan T' \<le> makespan T"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note lbrules = lbE[OF assms] have "\<exists>x \<in> {1..m}. Suc j \<in> A x" using lbrules(2) by auto then obtain x where x_def: "x \<in> {1..m}" "Suc j \<in> A x" .. let ?T = "T (x := T x - t (Suc j))" let ?A = "A (x := A x - {Suc j})"

  \<comment> \<open>Rule 1: @{term ?A} pairwise disjoint\<close> from lbrules(1) have "\<forall>i \<in> {1..m}. i \<noteq> x \<longrightarrow> A i \<inter> (A x - {Suc j}) = {}" using x_def(1) by blast then have 1: "\<forall>x \<in> {1..m}. \<forall>y \<in> {1..m}. x \<noteq> y \<longrightarrow> ?A x \<inter> ?A y = {}" using lbrules(1) by auto

  \<comment> \<open>Rule 2: @{term ?A} contains all jobs\<close> have NOTIN: "\<forall>i \<in> {1..m}. i \<noteq> x \<longrightarrow> Suc j \<notin> A i" using lbrules(1) x_def by blast then have "(\<Union>y \<in> {1..m}. ?A y) = (\<Union>y \<in> {1..m}. A y) - {Suc j}" using UNION_fun_upd x_def by auto also have "... = {1..j}" unfolding lbrules(2) by auto finally have 2: "(\<Union>y \<in> {1..m}. ?A y) = {1..j}" .

  \<comment> \<open>Rule 3: @{term ?A} sums to @{term ?T}\<close> have "(\<Sum>i \<in> A x - {Suc j}. t i) = (\<Sum>i \<in> A x. t i) - t (Suc j)" by (simp add: sum_diff1_nat x_def(2)) also have "... = T x - t (Suc j)" using lbrules(3) x_def(1) by simp finally have "(\<Sum>i \<in> ?A x. t i) = ?T x" by simp then have 3: "\<forall>i \<in> {1..m}. (\<Sum>j \<in> ?A i. t j) = ?T i" using lbrules(3) x_def(1) by simp

  \<comment> \<open>@{term makespan} is not larger\<close> have "lb ?T ?A j \<and> makespan ?T \<le> makespan T" using lbI[OF 1 2 3] makespan_mono(1) by force then show ?thesis by blast qed text \<open>If the processing time \<open>y\<close> does not contribute to the makespan, we can ignore it.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma smaller_optimum:
  assumes "lb T A (Suc j)"
  shows "\<exists>T' A'. lb T' A' j \<and> makespan T' \<le> makespan T"
proof -
  let T' = T
  let A' = A
  have "lb T' A' j" using assms by (simp add: T'A'j_def)
  have "makespan T' \<le> makespan T" using assms by (simp add: makespan_def)
  thus "\<exists>T' A'. lb T' A' j \<and> makespan T' \<le> makespan T" by (rule exI)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 42 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:32 cpu time, factor 3.57
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (102%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma remove_small_job:
  assumes "makespan (T (x := T x + y)) \<noteq> T x + y"
  shows   "makespan (T (x := T x + y)) = makespan T"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - let ?T = "T (x := T x + y)" have NOT_X: "makespan ?T \<noteq> ?T x" using assms(1) by simp then have "\<exists>i \<in> {1..m}. makespan ?T = ?T i \<and> i \<noteq> x" using makespan_correct(2) by metis then obtain i where i_def: "i \<in> {1..m}" "makespan ?T = ?T i" "i \<noteq> x" by blast then have "?T i = T i" using NOT_X by simp moreover from this have "makespan T = T i" by (metis i_def(1,2) antisym_conv le_add1 makespan_mono(2) makespan_correct(1)) ultimately show ?thesis using i_def(2) by simp qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma remove_small_job:
  assumes "makespan (T (x := T x + y)) \<noteq> T x + y"
  shows   "makespan (T (x := T x + y)) = makespan T"

proof -
  have "makespan (T (x := T x + y)) = makespan T"
  using assm by (simp add: makespan_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.62
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (103%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma greedy_makespan_no_jobs [simp]:
  "makespan (\<lambda>_. 0) = 0"</h2><br>
<b>Ground proof:</b> <br><pre><code>using m_gt_0 by (simp add: makespan_def')</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  by (simp add: greedy_makespan_no_jobs)
QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but identifier Proof (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:32 cpu time, factor 3.76
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (104%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma min_avg: "m * T (min\<^sub>k T m) \<le> (\<Sum>i \<in> {1..m}. T i)"
           (is \<open>_ * ?T \<le> ?S\<close>)</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "(\<Sum>_ \<in> {1..m}. ?T) \<le> ?S" using sum_mono[of \<open>{1..m}\<close> \<open>\<lambda>_. ?T\<close> T]
      and min_correct by blast then show ?thesis by simp qed definition inv\<^sub>1 :: "(nat \<Rightarrow> nat) \<Rightarrow> (nat \<Rightarrow> nat set) \<Rightarrow> nat \<Rightarrow> bool" where
  "inv\<^sub>1 T A j = (lb T A j \<and> j \<le> n \<and> (\<forall>T' A'. lb T' A' j \<longrightarrow> makespan T \<le> 2 * makespan T'))"</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume m * T (min\<^sub>k T m) \<le> (\<Sum>i \<in> {1..m}. T i)
2. By definition of min, we have T (min\<^sub>k T m) \<le> T i for all i in {1..m}
3. Multiply both sides by m
4. We get m * T (min\<^sub>k T m) \<le> m * T i for all i in {1..m}
5. Sum both sides over i in {1..m}
6. We get m * T (min\<^sub>k T m) \<le> (\<Sum>i \<in> {1..m}. m * T i)
7. Since m * T i \<le> T i for all i in {1..m}, we have (\<Sum>i \<in> {1..m}. m * T i) \<le> (\<Sum>i \<in> {1..m}. T i)
8. Therefore, m * T (min\<^sub>k T m) \<le> (\<Sum>i \<in> {1..m}. T i)

QED</s></code></pre><br><br>
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1E:
  assumes "inv\<^sub>1 T A j"
  shows "lb T A j" "j \<le> n"
        "lb T' A' j \<Longrightarrow> makespan T \<le> 2 * makespan T'"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>1_def by blast+</code></pre>
<b>Generated proof:</b><pre><code>```
lemma inv_1E:
  assumes "inv_1 T A j"
  shows "lb T A j" "j <= n" "lb T' A' j <Longrightarrow> makespan T <= 2 * makespan T'"
proof -
  have "lb T A j" "j <= n" "lb T' A' j <Longrightarrow> makespan T <= 2 * makespan T'" using assms by (auto simp: makespan_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "apply" (line 40 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.64
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (105%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1I:
  assumes "lb T A j" "j \<le> n" "\<forall>T' A'. lb T' A' j \<longrightarrow> makespan T \<le> 2 * makespan T'"
  shows "inv\<^sub>1 T A j"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>1_def by blast</code></pre>
<b>Generated proof:</b><pre><code>```
lemma inv_1I:
  assumes "lb T A j" "j \<le> n" "\<forall>T' A'. lb T' A' j \<longrightarrow> makespan T \<le> 2 * makespan T'"
  shows "inv_1 T A j"
proof -
  from assms have "lb T A j" "j \<le> n" "\<forall>T' A'. lb T' A' j \<longrightarrow> makespan T \<le> 2 * makespan T'"
  then have "inv_1 T A j" by (rule inv_1_def)
  thus "inv_1 T A j" by simp
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:32 cpu time, factor 3.58
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (106%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>1_step:
  assumes "inv\<^sub>1 T A j" "j < n"
  shows "inv\<^sub>1 (T ((min\<^sub>k T m) := T (min\<^sub>k T m) + t (Suc j)))
              (A ((min\<^sub>k T m) := A (min\<^sub>k T m) \<union> {Suc j})) (Suc j)"
    (is \<open>inv\<^sub>1 ?T ?A _\<close>)</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note invrules = inv\<^sub>1E[OF assms(1)]
  \<comment> \<open>Greedy is correct\<close> have LB: "lb ?T ?A (Suc j)" using add_job[OF invrules(1) min_in_range[OF m_gt_0]] by blast
  \<comment> \<open>Greedy maintains approximation factor\<close> have MK: "\<forall>T' A'. lb T' A' (Suc j) \<longrightarrow> makespan ?T \<le> 2 * makespan T'" proof rule+ fix T\<^sub>1 A\<^sub>1 assume "lb T\<^sub>1 A\<^sub>1 (Suc j)" from smaller_optimum[OF this] obtain T\<^sub>0 A\<^sub>0 where "lb T\<^sub>0 A\<^sub>0 j" "makespan T\<^sub>0 \<le> makespan T\<^sub>1" by blast then have IH: "makespan T \<le> 2 * makespan T\<^sub>1" using invrules(3) by force show "makespan ?T \<le> 2 * makespan T\<^sub>1" proof (cases \<open>makespan ?T = T (min\<^sub>k T m) + t (Suc j)\<close>) case True have "m * T (min\<^sub>k T m) \<le> (\<Sum>i \<in> {1..m}. T i)" by (rule min_avg) also have "... = (\<Sum>i \<in> {1..j}. t i)" by (rule lb_impl_job_sum[OF invrules(1)]) finally have "real m * T (min\<^sub>k T m) \<le> (\<Sum>i \<in> {1..j}. t i)" by (auto dest: of_nat_mono) with m_gt_0 have "T (min\<^sub>k T m) \<le> (\<Sum>i \<in> {1..j}. t i) / m" by (simp add: field_simps) then have "T (min\<^sub>k T m) \<le> makespan T\<^sub>1" using job_dist_lower_bound_makespan[OF \<open>lb T\<^sub>0 A\<^sub>0 j\<close>] 
          and \<open>makespan T\<^sub>0 \<le> makespan T\<^sub>1\<close> by linarith moreover have "t (Suc j) \<le> makespan T\<^sub>1" using job_lower_bound_makespan[OF \<open>lb T\<^sub>1 A\<^sub>1 (Suc j)\<close>] by simp ultimately show ?thesis unfolding True by simp next case False show ?thesis using remove_small_job[OF False] IH by simp qed qed from inv\<^sub>1I[OF LB _ MK] show ?thesis using assms(2) by simp qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, hide_lams) inv1_def inv1_step.inv1_step_def min_def)
```</s></code></pre><br><br>
<hr><hr><hr><hr>
<h2>lemma simple_greedy_approximation:
"VARS T A i j
{True}
T := (\<lambda>_. 0);
A := (\<lambda>_. {});
j := 0;
WHILE j < n INV {inv\<^sub>1 T A j} DO
  i := min\<^sub>k T m;
  j := (Suc j);
  A := A (i := A(i) \<union> {j});
  T := T (i := T(i) + t j)
OD
{lb T A n \<and> (\<forall>T' A'. lb T' A' n \<longrightarrow> makespan T \<le> 2 * makespan T')}"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (vcg, goal_cases) case (1 T A i j) then show ?case by (simp add: lb_def inv\<^sub>1_def) next case (2 T A i j) then show ?case using inv\<^sub>1_step by simp next case (3 T A i j) then show ?case unfolding inv\<^sub>1_def by force qed definition sorted :: "nat \<Rightarrow> bool" where
  "sorted j = (\<forall>x \<in> {1..j}. \<forall>y \<in> {1..x}. t x \<le> t y)"</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume *: inv1_T_A_j
  have "i = min_k T m" by (simp add: *);
  have "j = Suc j" by simp;
  have "A = A (i := A(i) \<union> {j})" by (simp add: *);
  have "T = T (i := T(i) + t j)" by (simp add: *);
  hence "lb T A n \<and> (∀T' A'. lb T' A' n ⟹ makespan T ≤ 2 * makespan T')" by (simp add: *);
qed
```</s></code></pre><br><br>
<hr><hr><hr><hr>
<h2>lemma sorted_smaller [simp]: "\<lbrakk> sorted j; j \<ge> j' \<rbrakk> \<Longrightarrow> sorted j'"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding sorted_def by simp</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume sorted j; j >= j'
2. By definition of sorted, j is sorted and j >= j'
3. By definition of sorted, j' is sorted
4. Therefore, sorted j'

QED.

Proof:

1. Assume sorted j; j >= j'
2. By definition of sorted, j is sorted and j >= j'
3. By definition of sorted, j' is sorted
4. Therefore, sorted j'

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 405 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but keyword : (line 405 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 404 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:30 cpu time, factor 3.57
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (107%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma j_gt_m_pigeonhole:
  assumes "lb T A j" "j > m"
  shows "\<exists>x \<in> {1..j}. \<exists>y \<in> {1..j}. \<exists>z \<in> {1..m}. x \<noteq> y \<and> x \<in> A z \<and> y \<in> A z"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "\<forall>x \<in> {1..j}. \<exists>y \<in> {1..m}. x \<in> A y" using lbE(2)[OF assms(1)] by blast then have "\<exists>f. \<forall>x \<in> {1..j}. x \<in> A (f x) \<and> f x \<in> {1..m}" by metis then obtain f where f_def: "\<forall>x \<in> {1..j}. x \<in> A (f x) \<and> f x \<in> {1..m}" .. then have "card (f ` {1..j}) \<le> card {1..m}" by (meson card_mono finite_atLeastAtMost image_subset_iff) also have "... < card {1..j}" using assms(2) by simp finally have "card (f ` {1..j}) < card {1..j}" . then have "\<not> inj_on f {1..j}" using pigeonhole by blast then have "\<exists>x \<in> {1..j}. \<exists>y \<in> {1..j}. x \<noteq> y \<and> f x = f y" unfolding inj_on_def by blast then show ?thesis using f_def by metis qed text \<open>If \<open>T\<close> and \<open>A\<close> are a correct load balancing for \<open>j\<close> jobs and \<open>m\<close> machines with \<open>j > m\<close>,
      and the jobs are sorted in descending order, then there exists a machine \<open>x \<in> {1..m}\<close>
      whose load is at least twice as large as the processing time of job \<open>j\<close>.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma j_gt_m_pigeonhole:
  assumes "lb T A j" "j > m"
  shows "\<exists>x \<in> {1..j}. \<exists>y \<in> {1..j}. \<exists>z \<in> {1..m}. x \<noteq> y \<and> x \<in> A z \<and> y \<in> A z"
proof -
  from assms have "j > m" by auto
  then obtain x y z where "x \<in> {1..j}" "y \<in> {1..j}" "z \<in> {1..m}" "x \<noteq> y" "x \<in> A z" "y \<in> A z" by auto
  thus "\<exists>x \<in> {1..j}. \<exists>y \<in> {1..j}. \<exists>z \<in> {1..m}. x \<noteq> y \<and> x \<in> A z \<and> y \<in> A z" by auto
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:30 cpu time, factor 3.56
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (108%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sorted_job_lower_bound_machine:
  assumes "lb T A j" "j > m" "sorted j"
  shows "\<exists>x \<in> {1..m}. 2 * t j \<le> T x"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof -
  \<comment> \<open>Step 1: Obtaining the jobs\<close> note lbrules = lbE[OF assms(1)] obtain j\<^sub>1 j\<^sub>2 x where *:
    "j\<^sub>1 \<in> {1..j}" "j\<^sub>2 \<in> {1..j}" "x \<in> {1..m}" "j\<^sub>1 \<noteq> j\<^sub>2" "j\<^sub>1 \<in> A x" "j\<^sub>2 \<in> A x" using j_gt_m_pigeonhole[OF assms(1,2)] by blast

  \<comment> \<open>Step 2: Jobs contained in sum\<close> have "finite (A x)" using assms(1) *(3) by simp then have SUM: "(\<Sum>i \<in> A x. t i) = t j\<^sub>1 + t j\<^sub>2 + (\<Sum>i \<in> A x - {j\<^sub>1} - {j\<^sub>2}. t i)" using *(4-6) by (simp add: sum.remove)

  \<comment> \<open>Step 3: Proof of lower bound\<close> have "t j \<le> t j\<^sub>1" "t j \<le> t j\<^sub>2" using assms(3) *(1-2) unfolding sorted_def by auto then have "2 * t j \<le> t j\<^sub>1 + t j\<^sub>2" by simp also have "... \<le> (\<Sum>i \<in> A x. t i)" unfolding SUM by simp finally have "2 * t j \<le> T x" using lbrules(3) *(3) by simp then show ?thesis using *(3) by blast qed text \<open>Reasoning analogous to @{thm [source] job_lower_bound_makespan}.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma sorted_job_lower_bound_machine:
  assumes "lb T A j" "j > m" "sorted j"
  shows "\<exists>x \<in> {1..m}. 2 * t j \<le> T x"

proof -
  from assms have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j > m" "sorted j"
  then have "j</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.55
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (109%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sorted_job_lower_bound_makespan:
  assumes "lb T A j" "j > m" "sorted j"
  shows "2 * t j \<le> makespan T"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - obtain x where x_def: "x \<in> {1..m}" "2 * t j \<le> T x" using sorted_job_lower_bound_machine[OF assms] .. with makespan_correct(1) have "T x \<le> makespan T" by blast with x_def(2) show ?thesis by simp qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "lb T A j" "j > m" "sorted j"
  have "t j \<le> makespan T" by (fact lb)
  hence "2 * t j \<le> 2 * makespan T" by (rule mult_mono)
  moreover have "2 * makespan T \<le> makespan T" by (rule mult_mono)
  ultimately show "2 * t j \<le> makespan T" by (rule trans)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.62
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (110%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma min_zero:
  assumes "x \<in> {1..k}" "T x = 0"
  shows "T (min\<^sub>k T k) = 0"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms(1) proof (induction k) case (Suc k) show ?case proof (cases \<open>x = Suc k\<close>) case True then show ?thesis using assms(2) by (simp add: Let_def) next case False with Suc have "T (min\<^sub>k T k) = 0" by simp then show ?thesis by simp qed qed simp</code></pre>
<b>Generated proof:</b><pre><code>```
lemma min_zero:
  assumes "x \<in> {1..k}" "T x = 0"
  shows "T (min\<^sub>k T k) = 0"

proof -
  from assms have "min\<^sub>k T k \<in> {1..k}" by (rule min_def)
  moreover have "T (min\<^sub>k T k) = 0" by (rule min_def)
  ultimately show "T (min\<^sub>k T k) = 0" by blast
qed
```</s></code></pre><br><br>
<hr><hr><hr><hr>
<h2>lemma min_zero_index:
  assumes "x \<in> {1..k}" "T x = 0"
  shows "min\<^sub>k T k \<le> x"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms(1) proof (induction k) case (Suc k) show ?case proof (cases \<open>x = Suc k\<close>) case True then show ?thesis using min_in_range[of "Suc k"] by simp next case False with Suc.prems have "x \<in> {1..k}" by simp from min_zero[OF this, of T] assms(2) Suc.IH[OF this] show ?thesis by simp qed qed simp definition inv\<^sub>2 :: "(nat \<Rightarrow> nat) \<Rightarrow> (nat \<Rightarrow> nat set) \<Rightarrow> nat \<Rightarrow> bool" where
  "inv\<^sub>2 T A j = (lb T A j \<and> j \<le> n
                \<and> (\<forall>T' A'. lb T' A' j \<longrightarrow> makespan T \<le> 3 / 2 * makespan T') 
                \<and> (\<forall>x > j. T x = 0)
                \<and> (j \<le> m \<longrightarrow> makespan T = Max\<^sub>0 (t ` {1..j})))"</code></pre>
<b>Generated proof:</b><pre><code>```
lemma min_zero_index:
  assumes "x \<in> {1..k}" "T x = 0"
  shows "min\<^sub>k T k \<le> x"

proof -
  from assms have "x \<in> {1..k}" "T x = 0"
  then have "min\<^sub>k T k \<le> x" by (rule min_def)
  thus "min\<^sub>k T k \<le> x" by simp
qed
```</s></code></pre><br><br>
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>2E:
  assumes "inv\<^sub>2 T A j"
  shows "lb T A j" "j \<le> n"
        "lb T' A' j \<Longrightarrow> makespan T \<le> 3 / 2 * makespan T'"
        "\<forall>x > j. T x = 0" "j \<le> m \<Longrightarrow> makespan T = Max\<^sub>0 (t ` {1..j})"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms unfolding inv\<^sub>2_def by blast+</code></pre>
<b>Generated proof:</b><pre><code>```
lemma inv2E:
  assumes "inv2 T A j"
  shows "lb T A j" "j <= n"
        "lb T' A' j <Longrightarrow> makespan T <= 3 / 2 * makespan T'"
        "<forall>x > j. T x = 0" "j <= m <Longrightarrow> makespan T = Max0 (t ` {1..j})"
proof -
  assume "inv2 T A j"
  then have "lb T A j" "j <= n" by (rule inv2_def)
  assume "lb T' A' j"
  then have "makespan T <= 3 / 2 * makespan T'" by (rule inv2_def)
  assume "j <= m"
  then have "makespan T = Max0 (t ` {1..j})" by (rule inv2_def)
  assume "x > j"
  then have "T x = 0" by (rule inv2_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:30 cpu time, factor 3.52
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (111%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>2I:
  assumes "lb T A j" "j \<le> n"
          "\<forall>T' A'. lb T' A' j \<longrightarrow> makespan T \<le> 3 / 2 * makespan T'"
          "\<forall>x > j. T x = 0"
          "j \<le> m \<Longrightarrow> makespan T = Max\<^sub>0 (t ` {1..j})"
  shows "inv\<^sub>2 T A j"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding inv\<^sub>2_def using assms by blast</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, hide_lams) inv_2I.simps(1) inv_2I.simps(2) inv_2I.simps(3) inv_2I.simps(4))
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 42 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** At command "by" (line 34 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
*** Outer syntax error (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy"): command expected,
*** but back-quoted string `` (line 610 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy") was found
*** At command "<malformed>" (line 609 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_LB_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:31 cpu time, factor 3.61
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (112%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv\<^sub>2_step:
  assumes "sorted n" "inv\<^sub>2 T A j" "j < n"
  shows "inv\<^sub>2 (T (min\<^sub>k T m := T(min\<^sub>k T m) + t(Suc j)))
              (A (min\<^sub>k T m := A(min\<^sub>k T m) \<union> {Suc j})) (Suc j)"
    (is \<open>inv\<^sub>2 ?T ?A _\<close>)</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (cases \<open>Suc j > m\<close>) case True note invrules = inv\<^sub>2E[OF assms(2)]
  \<comment> \<open>Greedy is correct\<close> have LB: "lb ?T ?A (Suc j)" using add_job[OF invrules(1) min_in_range[OF m_gt_0]] by blast
  \<comment> \<open>Greedy maintains approximation factor\<close> have MK: "\<forall>T' A'. lb T' A' (Suc j) \<longrightarrow> makespan ?T \<le> 3 / 2 * makespan T'" proof rule+ fix T\<^sub>1 A\<^sub>1 assume "lb T\<^sub>1 A\<^sub>1 (Suc j)" from smaller_optimum[OF this] obtain T\<^sub>0 A\<^sub>0 where "lb T\<^sub>0 A\<^sub>0 j" "makespan T\<^sub>0 \<le> makespan T\<^sub>1" by blast then have IH: "makespan T \<le> 3 / 2 * makespan T\<^sub>1" using invrules(3) by force show "makespan ?T \<le> 3 / 2 * makespan T\<^sub>1" proof (cases \<open>makespan ?T = T (min\<^sub>k T m) + t (Suc j)\<close>) case True have "m * T (min\<^sub>k T m) \<le> (\<Sum>i \<in> {1..m}. T i)" by (rule min_avg) also have "... = (\<Sum>i \<in> {1..j}. t i)" by (rule lb_impl_job_sum[OF invrules(1)]) finally have "real m * T (min\<^sub>k T m) \<le> (\<Sum>i \<in> {1..j}. t i)" by (auto dest: of_nat_mono) with m_gt_0 have "T (min\<^sub>k T m) \<le> (\<Sum>i \<in> {1..j}. t i) / m" by (simp add: field_simps) then have "T (min\<^sub>k T m) \<le> makespan T\<^sub>1" using job_dist_lower_bound_makespan[OF \<open>lb T\<^sub>0 A\<^sub>0 j\<close>] 
          and \<open>makespan T\<^sub>0 \<le> makespan T\<^sub>1\<close> by linarith moreover have "2 * t (Suc j) \<le> makespan T\<^sub>1" using sorted_job_lower_bound_makespan[OF \<open>lb T\<^sub>1 A\<^sub>1 (Suc j)\<close> \<open>Suc j > m\<close>]
          and assms(1,3) by simp ultimately show ?thesis unfolding True by simp next case False show ?thesis using remove_small_job[OF False] IH by simp qed qed have "\<forall>x > Suc j. ?T x = 0" using invrules(4) min_in_range[OF m_gt_0, of T] True by simp with inv\<^sub>2I[OF LB _ MK] show ?thesis using assms(3) True by simp next case False then have IN_RANGE: "Suc j \<in> {1..m}" by simp note invrules = inv\<^sub>2E[OF assms(2)] then have "T (Suc j) = 0" by blast

  \<comment> \<open>Greedy is correct\<close> have LB: "lb ?T ?A (Suc j)" using add_job[OF invrules(1) min_in_range[OF m_gt_0]] by blast

  \<comment> \<open>Greedy is trivially optimal\<close> from IN_RANGE \<open>T (Suc j) = 0\<close> have "min\<^sub>k T m \<le> Suc j" using min_zero_index by blast with invrules(4) have EMPTY: "\<forall>x > Suc j. ?T x = 0" by simp from IN_RANGE \<open>T (Suc j) = 0\<close> have "T (min\<^sub>k T m) = 0" using min_zero by blast with fun_upd_f_Max\<^sub>0[OF min_in_range[OF m_gt_0]] invrules(5) False have TRIV: "makespan ?T = Max\<^sub>0 (t ` {1..Suc j})" unfolding f_Max\<^sub>0_equiv[symmetric] by simp have MK: "\<forall>T' A'. lb T' A' (Suc j) \<longrightarrow> makespan ?T \<le> 3 / 2 * makespan T'" by (auto simp: TRIV[folded f_Max\<^sub>0_equiv]
            dest!: max_job_lower_bound_makespan[folded f_Max\<^sub>0_equiv]) from inv\<^sub>2I[OF LB _ MK EMPTY TRIV] show ?thesis using assms(3) by simp qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis inv2_def sorted_def)
```</s></code></pre><br><br>
<hr><hr><hr><hr>
<h2>lemma sorted_greedy_approximation:
"sorted n \<Longrightarrow> VARS T A i j
{True}
T := (\<lambda>_. 0);
A := (\<lambda>_. {});
j := 0;
WHILE j < n INV {inv\<^sub>2 T A j} DO
  i := min\<^sub>k T m;
  j := (Suc j);
  A := A (i := A(i) \<union> {j});
  T := T (i := T(i) + t j)
OD
{lb T A n \<and> (\<forall>T' A'. lb T' A' n \<longrightarrow> makespan T \<le> 3 / 2 * makespan T')}"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (vcg, goal_cases) case (1 T A i j) then show ?case by (simp add: lb_def inv\<^sub>2_def) next case (2 T A i j) then show ?case using inv\<^sub>2_step by simp next case (3 T A i j) then show ?case unfolding inv\<^sub>2_def by force qed end (* LoadBalancing *) end (* Theory *)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume sorted: sorted n
  assume VARS T A i j
  assume {True}
  assume T := (\<lambda>_. 0);
  assume A := (\<lambda>_. {});
  assume j := 0;
  assume WHILE j < n INV {inv\<^sub>2 T A j} DO
    assume i := min\<^sub>k T m;
    assume j := (Suc j);
    assume A := A (i := A(i) \<union> {j});
    assume T := T (i := T(i) + t j)
  OD
  have "lb T A n" by (simp add: sorted)
  have "(\<forall>T' A'. lb T' A' n \<longrightarrow> makespan T \<le> 3 / 2 * makespan T')" by (simp add: sorted)
  qed
```</s></code></pre><br><br>
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/Approximation_Algorithms/_home_qj213_afp-2021-10-22_thys_Approximation_Algorithms_Approx_SC_Hoare_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma S_subset: "\<forall>i \<in> {1..m}. S i \<subseteq> U"</h2><br>
<b>Ground proof:</b> <br><pre><code>using U_def by blast</code></pre>
<b>Generated proof:</b><pre><code>```
by (induction i rule: nat.induct)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 30 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 30 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 29 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:34 cpu time, factor 3.80
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (113%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma U_finite: "finite U"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding U_def using S_finite by blast</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule finite_set_def)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 33 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 33 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 32 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:34 cpu time, factor 3.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (114%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma empty_cover: "m = 0 \<Longrightarrow> U = {}"</h2><br>
<b>Ground proof:</b> <br><pre><code>using U_def by simp definition sc :: "nat set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "sc C X \<longleftrightarrow> C \<subseteq> {1..m} \<and> (\<Union>i \<in> C. S i) = X" definition cost :: "'a set \<Rightarrow> nat \<Rightarrow> real" where
  "cost R i = w i / card (S i \<inter> R)"</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume m = 0
2. By definition of empty set, U = {}
3. Therefore, m =  proof (by contradiction)
4. Assume m ≠ 0
5. Then, by definition of non-empty set, U ≠ {}
6. This contradicts the assumption that U = {}
7. Therefore, m = 0
8. Hence, U = {}

QED

Proof:

1. Assume m = 0
2. By definition of empty set, U = {}
3. Therefore, m = 0
4. Hence, U = {}

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 36 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but keyword : (line 36 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 35 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:34 cpu time, factor 3.83
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (115%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cost_nonneg: "0 \<le> cost R i"</h2><br>
<b>Ground proof:</b> <br><pre><code>using w_nonneg by (simp add: cost_def) text \<open>\<open>cost R i = 0\<close> if \<open>card (S i \<inter> R) = 0\<close>! Needs to be accounted for separately in \<open>min_arg\<close>.\<close> fun min_arg :: "'a set \<Rightarrow> nat \<Rightarrow> nat" where
  "min_arg R 0 = 1"
| "min_arg R (Suc x) =
   (let j = min_arg R x
    in if S j \<inter> R = {} \<or> (S (Suc x) \<inter> R \<noteq> {} \<and> cost R (Suc x) < cost R j) then (Suc x) else j)"</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule cost_nonneg)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 45 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 45 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 44 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:34 cpu time, factor 3.80
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (116%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma min_in_range: "k > 0 \<Longrightarrow> min_arg R k \<in> {1..k}"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (induction k) (force simp: Let_def)+</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule min_arg_in_range)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 55 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 55 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 54 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:34 cpu time, factor 3.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (117%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma min_empty: "S (min_arg R k) \<inter> R = {} \<Longrightarrow> \<forall>i \<in> {1..k}. S i \<inter> R = {}"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (induction k) case (Suc k) from Suc.prems have prem: "S (min_arg R k) \<inter> R = {}" by (auto simp: Let_def split: if_splits) with Suc.IH have IH: "\<forall>i \<in> {1..k}. S i \<inter> R = {}" . show ?case proof fix i assume "i \<in> {1..Suc k}" show "S i \<inter> R = {}" proof (cases \<open>i = Suc k\<close>) case True with Suc.prems prem show ?thesis by simp next case False with IH \<open>i \<in> {1..Suc k}\<close> show ?thesis by simp qed qed qed simp</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume S (min_arg R k) \<inter> R = {}
2. By definition of min_arg, S (min_arg R k) is the set of all elements in S that are not in R
3. Therefore, S (min_arg R k) \<inter> R = {} implies that there are no elements in S that are not in R
4. Hence, all elements in S are in R
5. Now, consider any element i in {1..k}
6. By assumption, S i \<inter> R = {}
7. This means that there are no elements in S i that are in R
8. But we have already established that all elements in S are in R
9. Therefore, S i must be empty
10. Hence, for all i in {1..k}, S i \<inter> R = {}

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 58 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but keyword : (line 58 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 57 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:34 cpu time, factor 3.76
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (118%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma min_correct: "\<lbrakk> i \<in> {1..k}; S i \<inter> R \<noteq> {} \<rbrakk> \<Longrightarrow> cost R (min_arg R k) \<le> cost R i"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (induction k) case (Suc k) show ?case proof (cases \<open>i = Suc k\<close>) case True with Suc.prems show ?thesis by (auto simp: Let_def) next case False with Suc.prems Suc.IH have IH: "cost R (min_arg R k) \<le> cost R i" by simp from Suc.prems False min_empty[of R k] have "S (min_arg R k) \<inter> R \<noteq> {}" by force with IH show ?thesis by (auto simp: Let_def) qed qed simp text \<open>Correctness holds quite trivially for both m = 0 and m > 0
      (assuming a set cover can be found at all, otherwise algorithm would not terminate).\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma min_correct:
  assumes i: "i <in> {1..k}" and R: "S i inter R <noteq> {}"
  shows "cost R (min_arg R k) <= cost R i"
proof -
  from i have "i <= k" by auto
  from R have "S i inter R <noteq> {}" by auto
  then have "min_arg R k <= i" by (rule min_arg_correct)
  then have "cost R (min_arg R k) <= cost R i" by (rule cost_monotonic)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 72 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 72 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 71 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:34 cpu time, factor 3.72
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (119%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma set_cover_correct:
"VARS (R :: 'a set) (C :: nat set) (i :: nat)
  {True}
  R := U; C := {};
  WHILE R \<noteq> {} INV {R \<subseteq> U \<and> sc C (U - R)} DO
  i := min_arg R m;
  R := R - S i;
  C := C \<union> {i}
  OD
  {sc C U}"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (vcg, goal_cases) case 2 show ?case proof (cases m) case 0 from empty_cover[OF this] 2 show ?thesis by (auto simp: sc_def) next case Suc then have "m > 0" by simp from min_in_range[OF this] 2 show ?thesis using S_subset by (auto simp: sc_def) qed qed (auto simp: sc_def) definition c_exists :: "nat set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "c_exists C R = (\<exists>c. sum w C = sum c (U - R) \<and> (\<forall>i. 0 \<le> c i)
                \<and> (\<forall>k \<in> {1..m}. sum c (S k \<inter> (U - R))
                   \<le> (\<Sum>j = card (S k \<inter> R) + 1..card (S k). inverse j) * w k))" definition inv :: "nat set \<Rightarrow> 'a set \<Rightarrow> bool" where
  "inv C R \<longleftrightarrow> sc C (U - R) \<and> R \<subseteq> U \<and> c_exists C R"</code></pre>
<b>Generated proof:</b><pre><code>```
lemma set_cover_correct:
  "VARS (R :: 'a set) (C :: nat set) (i :: nat)
    {True}
    R := U; C := {};
    WHILE R \<noteq> {} INV {R \<subseteq> U \<and> sc C (U - R)} DO
    i := min_arg R m;
    R := R - S i;
    C := C \<union> {i}
    OD
    {sc C U}"
  apply (induct_tac "R C i" "R C i")
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)
  apply (simp_all add: set_cover_correct_def)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Malformed command syntax
*** At command "<malformed>" (line 368 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:33 cpu time, factor 3.69
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (120%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma invI:
  assumes "sc C (U - R)" "R \<subseteq> U"
          "\<exists>c. sum w C = sum c (U - R) \<and> (\<forall>i. 0 \<le> c i)
        \<and> (\<forall>k \<in> {1..m}. sum c (S k \<inter> (U - R))
                      \<le> (\<Sum>j = card (S k \<inter> R) + 1..card (S k). inverse j) * w k)"
    shows "inv C R"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms by (auto simp: inv_def c_exists_def)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma invI:
  assumes "sc C (U - R)" "R \<subseteq> U"
          "\<exists>c. sum w C = sum c (U - R) \<and> (\<forall>i. 0 \<le> c i)
        \<and> (\<forall>k \<in> {1..m}. sum c (S k \<inter> (U - R))
                      \<le> (\<Sum>j = card (S k \<inter> R) + 1..card (S k). inverse j) * w k)"
    shows "inv C R"
  proof -
    have "sum w C = sum c (U - R)" by assumption
    have "R \<subseteq> U" by assumption
    have "\<exists>c. sum w C = sum c (U - R) \<and> (\<forall>i. 0 \<le> c i)" by assumption
    have "(\<forall>k \<in> {1..m}. sum c (S k \<inter> (U - R))
                      \<le> (\<Sum>j = card (S k \<inter> R) + 1..card (S k). inverse j) * w k)" by assumption
    then show "inv C R" by (rule invI.intro)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 370 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 370 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 368 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:34 cpu time, factor 3.85
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (121%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma invD:
  assumes "inv C R"
  shows "sc C (U - R)" "R \<subseteq> U"
        "\<exists>c. sum w C = sum c (U - R) \<and> (\<forall>i. 0 \<le> c i)
      \<and> (\<forall>k \<in> {1..m}. sum c (S k \<inter> (U - R))
                    \<le> (\<Sum>j = card (S k \<inter> R) + 1..card (S k). inverse j) * w k)"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms by (auto simp: inv_def c_exists_def)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma invD:
  assumes "inv C R"
  shows "sc C (U - R)" "R \<subseteq> U"
        "\<exists>c. sum w C = sum c (U - R) \<and> (\<forall>i. 0 \<le> c i)
      \<and> (\<forall>k \<in> {1..m}. sum c (S k \<inter> (U - R))
                    \<le> (\<Sum>j = card (S k \<inter> R) + 1..card (S k). inverse j) * w k)"
proof -
  have "sc C (U - R)" "R \<subseteq> U"
    using assms by (auto simp: inv_def)
  have "\<exists>c. sum w C = sum c (U - R) \<and> (\<forall>i. 0 \<le> c i)"
    using assms by (auto simp: inv_def)
  have "\<forall>k \<in> {1..m}. sum c (S k \<inter> (U - R))
                    \<le> (\<Sum>j = card (S k \<inter> R) + 1..card (S k). inverse j) * w k"
    using assms by (auto simp: inv_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 370 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 370 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 368 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.76
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (122%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv_init: "inv {} U"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (rule invI, goal_cases) case 3 let ?c = "(\<lambda>_. 0) :: 'a \<Rightarrow> real" have "sum w {} = sum ?c (U - U)" by simp moreover { have "\<forall>k \<in> {1..m}. 0 \<le> (\<Sum>j = card (S k \<inter> U) + 1..card (S k). inverse j) * w k" by (simp add: sum_nonneg w_nonneg) then have "(\<forall>k\<in>{1..m}. sum ?c (S k \<inter> (U - U))
             \<le> (\<Sum>j = card (S k \<inter> U) + 1..card (S k). inverse j) * w k)" by simp } ultimately show ?case by blast qed (simp_all add: sc_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule inv_init)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 129 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 129 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.73
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (123%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv_step:
  assumes "inv C R" "R \<noteq> {}"
  defines [simp]: "i \<equiv> min_arg R m"
  shows "inv (C \<union> {i}) (R - (S i))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (cases m) case 0 from empty_cover[OF this] invD(2)[OF assms(1)] have "R = {}" by blast then show ?thesis using assms(2) by simp next case Suc then have "0 < m" by simp note hyp = invD[OF assms(1)] show ?thesis proof (rule invI, goal_cases)
      \<comment> \<open>Correctness\<close> case 1 have "i \<in> {1..m}" using min_in_range[OF \<open>0 < m\<close>] by simp with hyp(1) S_subset show ?case by (auto simp: sc_def) next case 2 from hyp(2) show ?case by auto next case 3
      \<comment> \<open>Set Cover grows\<close> have "\<exists>i \<in> {1..m}. S i \<inter> R \<noteq> {}" using assms(2) U_def hyp(2) by blast then have "S i \<inter> R \<noteq> {}" using min_empty by auto then have "0 < card (S i \<inter> R)" using S_finite min_in_range[OF \<open>0 < m\<close>] by auto

      \<comment> \<open>Proving properties of cost function\<close> from hyp(3) obtain c where "sum w C = sum c (U - R)" "\<forall>i. 0 \<le> c i" and
      SUM: "\<forall>k\<in>{1..m}. sum c (S k \<inter> (U - R))
        \<le> (\<Sum>j = card (S k \<inter> R) + 1..card (S k). inverse j) * w k" by blast let ?c = "(\<lambda>x. if x \<in> S i \<inter> R then cost R i else c x)"

      \<comment> \<open>Proof of Lemma 11.9\<close> have "finite (U - R)" "finite (S i \<inter> R)" "(U - R) \<inter> (S i \<inter> R) = {}" using U_finite S_finite min_in_range[OF \<open>0 < m\<close>] by auto then have "sum ?c (U - R \<union> (S i \<inter> R)) = sum ?c (U - R) + sum ?c (S i \<inter> R)" by (rule sum.union_disjoint) moreover have U_split: "U - (R - S i) = U - R \<union> (S i \<inter> R)" using hyp(2) by blast moreover { have "sum ?c (S i \<inter> R) = card (S i \<inter> R) * cost R i" by simp also have "... = w i" unfolding cost_def using \<open>0 < card (S i \<inter> R)\<close> by simp finally have "sum ?c (S i \<inter> R) = w i" . } ultimately have "sum ?c (U - (R - S i)) = sum ?c (U - R) + w i" by simp moreover { have "C \<inter> {i} = {}" using hyp(1) \<open>S i \<inter> R \<noteq> {}\<close> by (auto simp: sc_def) from sum.union_disjoint[OF _ _ this] have "sum w (C \<union> {i}) = sum w C + w i" using hyp(1) by (auto simp: sc_def intro: finite_subset) } ultimately have 1: "sum w (C \<union> {i}) = sum ?c (U - (R - S i))" \<comment> \<open>Lemma 11.9\<close> using \<open>sum w C = sum c (U - R)\<close> by simp have 2: "\<forall>i. 0 \<le> ?c i" using \<open>\<forall>i. 0 \<le> c i\<close> cost_nonneg by simp

      \<comment> \<open>Proof of Lemma 11.10\<close> have 3: "\<forall>k\<in>{1..m}. sum ?c (S k \<inter> (U - (R - S i)))
          \<le> (\<Sum>j = card (S k \<inter> (R - S i)) + 1..card (S k). inverse j) * w k" proof fix k assume "k \<in> {1..m}" let ?rem = "S k \<inter> R" \<comment> \<open>Remaining elements to be covered\<close> let ?add = "S k \<inter> S i \<inter> R" \<comment> \<open>Elements that will be covered in this step\<close> let ?cov = "S k \<inter> (U - R)" \<comment> \<open>Covered elements\<close>

      \<comment> \<open>Transforming left and right sides\<close> have "sum ?c (S k \<inter> (U - (R - S i))) = sum ?c (S k \<inter> (U - R \<union> (S i \<inter> R)))" unfolding U_split .. also have "... = sum ?c (?cov \<union> ?add)" by (simp add: Int_Un_distrib Int_assoc) also have "... = sum ?c ?cov + sum ?c ?add" by (rule sum.union_disjoint) (insert S_finite \<open>k \<in> _\<close>, auto) finally have lhs:
        "sum ?c (S k \<inter> (U - (R - S i))) = sum ?c ?cov + sum ?c ?add" . have "S k \<inter> (R - S i) = ?rem - ?add" by blast then have "card (S k \<inter> (R - S i)) = card (?rem - ?add)" by simp also have "... = card ?rem - card ?add" using S_finite \<open>k \<in> _\<close> by (auto intro: card_Diff_subset) finally have rhs:
        "card (S k \<inter> (R - S i)) + 1 = card ?rem - card ?add + 1" by simp
      
      \<comment> \<open>The apparent complexity of the remaining proof is deceiving. Much of this is just about
          convincing Isabelle that these sum transformations are allowed.\<close> have "sum ?c ?add = card ?add * cost R i" by simp also have "... \<le> card ?add * cost R k" proof (cases "?rem = {}") case True then have "card ?add = 0" by (auto simp: card_eq_0_iff) then show ?thesis by simp next case False from min_correct[OF \<open>k \<in> _\<close> this] have "cost R i \<le> cost R k" by simp then show ?thesis by (simp add: mult_left_mono) qed also have "... = card ?add * inverse (card ?rem) * w k" by (simp add: cost_def divide_inverse_commute) also have "... = (\<Sum>j \<in> {card ?rem - card ?add + 1 .. card ?rem}. inverse (card ?rem)) * w k" proof - have "card ?add \<le> card ?rem" using S_finite \<open>k \<in> _\<close> by (blast intro: card_mono) then show ?thesis by (simp add: sum_distrib_left) qed also have "... \<le> (\<Sum>j \<in> {card ?rem - card ?add + 1 .. card ?rem}. inverse j) * w k" proof - have "\<forall>j \<in> {card ?rem - card ?add + 1 .. card ?rem}. inverse (card ?rem) \<le> inverse j" by force then have "(\<Sum>j \<in> {card ?rem - card ?add + 1 .. card ?rem}. inverse (card ?rem))
                   \<le> (\<Sum>j \<in> {card ?rem - card ?add + 1 .. card ?rem}. inverse j)" by (blast intro: sum_mono) with w_nonneg show ?thesis by (blast intro: mult_right_mono) qed finally have "sum ?c ?add
                 \<le> (\<Sum>j \<in> {card ?rem - card ?add + 1 .. card ?rem}. inverse j) * w k" . moreover from SUM have "sum ?c ?cov 
                           \<le> (\<Sum>j \<in> {card ?rem + 1 .. card (S k)}. inverse j) * w k" using \<open>k \<in> {1..m}\<close> by simp ultimately have "sum ?c (S k \<inter> (U - (R - S i)))
                    \<le> ((\<Sum>j \<in> {card ?rem - card ?add + 1 .. card ?rem}. inverse j) +
                        (\<Sum>j \<in> {card ?rem + 1 .. card (S k)}. inverse j)) * w k" unfolding lhs by argo also have "... = (\<Sum>j \<in> {card ?rem - card ?add + 1 .. card (S k)}. inverse j) * w k" proof - have sum_split: "b \<in> {a .. c} \<Longrightarrow> sum f {a .. c} = sum f {a .. b} + sum f {Suc b .. c}"
            for f :: "nat \<Rightarrow> real" and a b c :: nat proof - assume "b \<in> {a .. c}" then have "{a .. b} \<union> {Suc b .. c} = {a .. c}" by force moreover have "{a .. b} \<inter> {Suc b .. c} = {}" using \<open>b \<in> {a .. c}\<close> by auto ultimately show ?thesis by (metis finite_atLeastAtMost sum.union_disjoint) qed have "(\<Sum>j \<in> {card ?rem - card ?add + 1 .. card (S k)}. inverse j)
              = (\<Sum>j \<in> {card ?rem - card ?add + 1 .. card ?rem}. inverse j)
              + (\<Sum>j \<in> {card ?rem + 1 .. card (S k)}. inverse j)" proof (cases \<open>?add = {}\<close>) case False then have "0 < card ?add" "0 < card ?rem" using S_finite \<open>k \<in> _\<close> by fastforce+ then have "Suc (card ?rem - card ?add) \<le> card ?rem" by simp moreover have "card ?rem \<le> card (S k)" using S_finite \<open>k \<in> _\<close> by (simp add: card_mono) ultimately show ?thesis by (auto intro: sum_split) qed simp then show ?thesis by algebra qed finally show "sum ?c (S k \<inter> (U - (R - S i)))
                 \<le> (\<Sum>j \<in> {card (S k \<inter> (R - S i)) + 1 .. card (S k)}. inverse j) * w k" unfolding rhs . qed from 1 2 3 show ?case by blast qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "inv C R" "R \<noteq> {}"
  define i where "i \<equiv> min_arg R m"
  hence "i \<in> R" by (simp add: i-def)
  moreover
  have "i \<notin> C" using i-def by (simp add: min_arg_def)
  hence "i \<notin> C \<union> {i}" by simp
  moreover
  have "R - (S i) = R - (S i)" by simp
  moreover
  have "inv (C \<union> {i}) (R - (S i))" using i-def by (simp add: inv_def)
  ultimately
  show "inv (C \<union> {i}) (R - (S i))" by simp
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 370 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 370 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 368 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.73
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (124%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cover_sum:
  fixes c :: "'a \<Rightarrow> real"
  assumes "sc C V" "\<forall>i. 0 \<le> c i"
  shows "sum c V \<le> (\<Sum>i \<in> C. sum c (S i))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - from assms(1) have "finite C" by (auto simp: sc_def finite_subset) then show ?thesis using assms(1) proof (induction C arbitrary: V rule: finite_induct) case (insert i C) have V_split: "(\<Union> (S ` insert i C)) = (\<Union> (S ` C)) \<union> S i" by auto have finite: "finite (\<Union> (S ` C))" "finite (S i)" using insert S_finite by (auto simp: sc_def) have "sum c (S i) - sum c (\<Union> (S ` C) \<inter> S i) \<le> sum c (S i)" using assms(2) by (simp add: sum_nonneg) then have "sum c (\<Union> (S ` insert i C)) \<le> sum c (\<Union> (S ` C)) + sum c (S i)" unfolding V_split using sum_Un[OF finite, of c] by linarith moreover have "(\<Sum>i\<in>insert i C. sum c (S i)) = (\<Sum>i \<in> C. sum c (S i)) + sum c (S i)" by (simp add: insert.hyps) ultimately show ?case using insert by (fastforce simp: sc_def) qed (simp add: sc_def) qed abbreviation H :: "nat \<Rightarrow> real" where "H \<equiv> harm" definition d_star :: nat ("d\<^sup>*") where "d\<^sup>* \<equiv> Max (card ` (S ` {1..m}))"</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "sum c V \<le> (\<Sum>i \<in> C. sum c (S i))"
  proof -
    have "sum c V = sum c (V \<inter> C)" by (simp add: cover_sum)
    have "V \<inter> C \<subseteq> C" by (simp add: cover_sum)
    hence "sum c (V \<inter> C) \<le> (\<Sum>i \<in> C. sum c (S i))" by (metis sum.mono)
    thus "sum c V \<le> (\<Sum>i \<in> C. sum c (S i))" by (simp add: cover_sum)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 370 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 370 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 368 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:34 cpu time, factor 3.81
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (125%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma set_cover_bound:
  assumes "inv C {}" "sc C' U"
  shows "sum w C \<le> H d\<^sup>* * sum w C'"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - from invD(3)[OF assms(1)] obtain c where
    "sum w C = sum c U" "\<forall>i. 0 \<le> c i" and H_bound:
    "\<forall>k \<in> {1..m}. sum c (S k) \<le> H (card (S k)) * w k" \<comment> \<open>Lemma 11.10\<close> by (auto simp: harm_def Int_absorb2 S_subset) have "\<forall>k \<in> {1..m}. card (S k) \<le> d\<^sup>*" by (auto simp: d_star_def) then have "\<forall>k \<in> {1..m}. H (card (S k)) \<le> H d\<^sup>*" by (auto simp: harm_def intro!: sum_mono2) with H_bound have "\<forall>k \<in> {1..m}. sum c (S k) \<le> H d\<^sup>* * w k" by (metis atLeastAtMost_iff atLeastatMost_empty_iff empty_iff mult_right_mono w_nonneg) moreover have "C' \<subseteq> {1..m}" using assms(2) by (simp add: sc_def) ultimately have "\<forall>i \<in> C'. sum c (S i) \<le> H d\<^sup>* * w i" by blast then have "(\<Sum>i \<in> C'. sum c (S i)) \<le> H d\<^sup>* * sum w C'" by (auto simp: sum_distrib_left intro: sum_mono) have "sum w C = sum c U" by fact \<comment> \<open>Lemma 11.9\<close> also have "... \<le> (\<Sum>i \<in> C'. sum c (S i))" by (rule cover_sum[OF assms(2)]) fact also have "... \<le> H d\<^sup>* * sum w C'" by fact finally show ?thesis . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma set_cover_bound:
  assumes "inv C {}" "sc C' U"
  shows "sum w C \<le> H d\<^sup>* * sum w C'"
proof -
  have "sum w C \<le> H d\<^sup>* * sum w C'" using assms by (metis inv_def sc_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 370 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy"): command expected,
*** but back-quoted string `` (line 370 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy") was found
*** At command "<malformed>" (line 368 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:34 cpu time, factor 3.84
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (126%)<br>
                                
<hr><hr><hr><hr>
<h2>theorem set_cover_approx:
"VARS (R :: 'a set) (C :: nat set) (i :: nat)
  {True}
  R := U; C := {};
  WHILE R \<noteq> {} INV {inv C R} DO
  i := min_arg R m;
  R := R - S i;
  C := C \<union> {i}
  OD
  {sc C U \<and> (\<forall>C'. sc C' U \<longrightarrow> sum w C \<le> H d\<^sup>* * sum w C')}"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (vcg, goal_cases) case 1 show ?case by (rule inv_init) next case 2 thus ?case using inv_step .. next case (3 R C i) then have "sc C U" unfolding inv_def by auto with 3 show ?case by (auto intro: set_cover_bound) qed end (* Set Cover *) end (* Theory *)</code></pre>
<b>Generated proof:</b><pre><code>```
theorem set_cover_approx:
"VARS (R :: 'a set) (C :: nat set) (i :: nat)
  {True}
  R := U; C := {};
  WHILE R \<noteq> {} INV {inv C R} DO
  i := min_arg R m;
  R := R - S i;
  C := C \<union> {i}
  OD
  {sc C U \<and> (\<forall>C'. sc C' U \<longrightarrow> sum w C \<le> H d\<^sup>* * sum w C')}"
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover_approx])
  apply (rule_tac[set_cover</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Malformed command syntax
*** At command "<malformed>" (line 368 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_SC_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:34 cpu time, factor 3.83
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (127%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/Approximation_Algorithms/_home_qj213_afp-2021-10-22_thys_Approximation_Algorithms_Approx_MIS_Hoare_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma finite_edges: "e \<in> E \<Longrightarrow> finite e"</h2><br>
<b>Ground proof:</b> <br><pre><code>using card_ge_0_finite and edges2 by force</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule finite_edges)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 47 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 47 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 46 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:34 cpu time, factor 3.75
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (128%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma finite_V: "finite V"</h2><br>
<b>Ground proof:</b> <br><pre><code>using finite_edges and finite_E by auto</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule finite_V)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 50 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 50 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 49 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:34 cpu time, factor 3.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (129%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma finite_neighbors: "finite (neighbors u)"</h2><br>
<b>Ground proof:</b> <br><pre><code>using finite_V and rev_finite_subset [of V "neighbors u"] by auto</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule finite_neighbors)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 53 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 53 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 52 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:33 cpu time, factor 3.75
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (130%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma independent_vertices_finite: "independent_vertices E S \<Longrightarrow> finite S"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (metis rev_finite_subset independent_vertices_def vertices.simps finite_V)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma independent_vertices_finite: "independent_vertices E S \<Longrightarrow> finite S"
proof
  assume "independent_vertices E S"
  then have "finite (independent_vertices E S)" by (rule finite_independent_vertices)
  hence "finite S" by (rule finite_subset)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 56 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 56 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 55 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:34 cpu time, factor 3.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (131%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma edge_ex_vertices: "e \<in> E \<Longrightarrow> \<exists>u v. u \<noteq> v \<and> e = {u, v}"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - assume "e \<in> E" then have "card e = Suc (Suc 0)" using edges2 by auto then show "\<exists>u v. u \<noteq> v \<and> e = {u, v}" by (metis card_eq_SucD insertI1) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma edge_ex_vertices: "e \<in> E \<Longrightarrow> \<exists>u v. u \<noteq> v \<and> e = {u, v}"
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule exE)
apply(rule exI)
apply(rule ex</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Malformed command syntax
*** At command "<malformed>" (line 58 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:33 cpu time, factor 3.77
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (132%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma \<Delta>_pos [simp]: "E = {} \<or> 0 < \<Delta>"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof cases assume "E = {}" then show "E = {} \<or> 0 < \<Delta>" by auto next assume 1: "E \<noteq> {}" then have "V \<noteq> {}" using edges2 by fastforce moreover have "finite {degree_vertex u |u. u \<in> V}" by (metis finite_V finite_imageI Setcompr_eq_image) ultimately have 2: "\<Delta> \<in> {degree_vertex u |u. u \<in> V}" using Max_in by auto have "\<Delta> \<noteq> 0" proof assume "\<Delta> = 0" with 2 obtain u where 3: "u \<in> V" and 4: "degree_vertex u = 0" by auto from 3 obtain e where 5: "e \<in> E" and "u \<in> e" by auto moreover with 4 have "\<forall>v. {u, v} \<noteq> e" using finite_neighbors insert_absorb by fastforce ultimately show False using edge_ex_vertices by auto qed then show "E = {} \<or> 0 < \<Delta>" by auto qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (cases E; simp)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 67 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 67 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 66 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.71
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (133%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma \<Delta>_max_degree: "u \<in> V \<Longrightarrow> degree_vertex u \<le> \<Delta>"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - assume H: "u \<in> V" have "finite {degree_vertex u |u. u \<in> V}" by (metis finite_V finite_imageI Setcompr_eq_image) with H show "degree_vertex u \<le> \<Delta>" using Max_ge by auto qed subsection \<open>Wei's algorithm: \<open>(\<Delta>+1)\<close>-approximation\<close> text \<open>The 'functional' part of the invariant, used to prove that the algorithm produces an independent set of vertices.\<close> definition inv_iv :: "'a set \<Rightarrow> 'a set \<Rightarrow> bool" where
"inv_iv S X \<longleftrightarrow> independent_vertices E S
            \<and> X \<subseteq> V
            \<and> (\<forall>v1 \<in> (V - X). \<forall>v2 \<in> S. {v1, v2} \<notin> E)
            \<and> S \<subseteq> X" text \<open>Strenghten the invariant with an approximation ratio \<open>r\<close>:\<close> definition inv_approx :: "'a set \<Rightarrow> 'a set \<Rightarrow> nat \<Rightarrow> bool" where
"inv_approx S X r \<longleftrightarrow> inv_iv S X \<and> card X \<le> card S * r" text \<open>Preservation of the functional invariant:\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (induction rule: degree_vertex_induct)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 88 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 88 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 87 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.85
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (134%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv_preserv:
  fixes S :: "'a set"
    and X :: "'a set"
    and x :: "'a"
  assumes inv: "inv_iv S X"
      and x_def: "x \<in> V - X"
    shows "inv_iv (insert x S) (X \<union> neighbors x \<union> {x})"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have inv1: "independent_vertices E S"
   and inv2: "X \<subseteq> V"
   and inv3: "S \<subseteq> X"
   and inv4: "\<forall>v1 v2. v1 \<in> (V - X) \<and> v2 \<in> S \<longrightarrow> {v1, v2} \<notin> E" using inv unfolding inv_iv_def by auto have finite_S: "finite S" using inv1 and independent_vertices_finite by auto have S1: "\<forall>y \<in> S. {x, y} \<notin> E" using inv4 and x_def by blast have S2: "\<forall>x \<in> S. \<forall>y \<in> S. {x, y} \<notin> E" using inv1 unfolding independent_vertices_def by metis have S3: "v1 \<in> insert x S \<Longrightarrow> v2 \<in> insert x S \<Longrightarrow> {v1, v2} \<notin> E" for v1 v2 proof - assume "v1 \<in> insert x S" and "v2 \<in> insert x S" then consider
          (a) "v1 = x" and "v2 = x"
        | (b) "v1 = x" and "v2 \<in> S"
        | (c) "v1 \<in> S" and "v2 = x"
        | (d) "v1 \<in> S" and "v2 \<in> S" by auto then show "{v1, v2} \<notin> E" proof cases case a then show ?thesis using edges2 by force next case b then show ?thesis using S1 by auto next case c then show ?thesis using S1 by (metis doubleton_eq_iff) next case d then show ?thesis using S2 by auto qed qed (* invariant conjunct 1 *) have "independent_vertices E (insert x S)" using S3 and inv1 and x_def unfolding independent_vertices_def by auto (* invariant conjunct 2 *) moreover have "X \<union> neighbors x \<union> {x} \<subseteq> V" proof fix xa assume "xa \<in> X \<union> neighbors x \<union> {x}" then consider (a) "xa \<in> X" | (b) "xa \<in> neighbors x" | (c) "xa = x" by auto then show "xa \<in> V" proof cases case a then show ?thesis using inv2 by blast next case b then show ?thesis by auto next case c then show ?thesis using x_def by blast qed qed (* invariant conjunct 3 *) moreover have "insert x S \<subseteq> X \<union> neighbors x \<union> {x}" using inv3 by auto (* invariant conjunct 4 *) moreover have "v1 \<in> V - (X \<union> neighbors x \<union> {x}) \<Longrightarrow> v2 \<in> insert x S \<Longrightarrow> {v1, v2} \<notin> E" for v1 v2 proof - assume H: "v1 \<in> V - (X \<union> neighbors x \<union> {x})" and "v2 \<in> insert x S" then consider (a) "v2 = x" | (b) "v2 \<in> S" by auto then show "{v1, v2} \<notin> E" proof cases case a with H have "v1 \<notin> neighbors v2" by blast then show ?thesis by auto next case b from H have "v1 \<in> V - X" by blast with b and inv4 show ?thesis by blast qed qed (* conclusion *) ultimately show "inv_iv (insert x S) (X \<union> neighbors x \<union> {x})" unfolding inv_iv_def by blast qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume inv: "inv_iv S X"
  and x_def: "x \<in> V - X"
  show "inv_iv (insert x S) (X \<union> neighbors x \<union> {x})"
  proof -
    from inv have "inv_iv S X" by (rule inv)
    from x_def have "x \<in> V - X" by (rule x_def)
    hence "x \<in> V" by (rule set_diff_subset)
    hence "x \<in> V" by (rule set_diff_subset)
    from inv and x_def have "inv_iv (insert x S) (X \<union> neighbors x \<union> {x})" by (rule inv_preserv)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 561 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.76
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (135%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv_approx_preserv:
  assumes inv: "inv_approx S X (\<Delta> + 1)"
      and x_def: "x \<in> V - X"
    shows "inv_approx (insert x S) (X \<union> neighbors x \<union> {x}) (\<Delta> + 1)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have finite_S: "finite S" using inv and independent_vertices_finite unfolding inv_approx_def inv_iv_def by auto have Sx: "x \<notin> S" using inv and x_def unfolding inv_approx_def inv_iv_def by blast (* main invariant is preserved *) from inv have "inv_iv S X" unfolding inv_approx_def by auto with x_def have "inv_iv (insert x S) (X \<union> neighbors x \<union> {x})" proof (intro inv_preserv, auto) qed (* the approximation ratio is preserved (at most \<Delta>+1 vertices are removed in any iteration) *) moreover have "card (X \<union> neighbors x \<union> {x}) \<le> card (insert x S) * (\<Delta> + 1)" proof - have "degree_vertex x \<le> \<Delta>" using \<Delta>_max_degree and x_def by auto then have "card (neighbors x \<union> {x}) \<le> \<Delta> + 1" using card_Un_le [of "neighbors x" "{x}"] by auto then have "card (X \<union> neighbors x \<union> {x}) \<le> card X + \<Delta> + 1" using card_Un_le [of X "neighbors x \<union> {x}"] by auto also have "... \<le> card S * (\<Delta> + 1) + \<Delta> + 1" using inv unfolding inv_approx_def by auto also have "... = card (insert x S) * (\<Delta> + 1)" using finite_S and Sx by auto finally show ?thesis . qed (* conclusion *) ultimately show "inv_approx (insert x S) (X \<union> neighbors x \<union> {x}) (\<Delta> + 1)" unfolding inv_approx_def by auto qed (* the antecedent combines inv_approx (for an arbitrary ratio r) and the negated post-condition *)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume inv: "inv_approx S X (\<Delta> + 1)"
  assume x_def: "x \<in> V - X"
  have "inv_approx (insert x S) (X \<union> neighbors x \<union> {x}) (\<Delta> + 1)"
  using inv x_def by (simp add: inv_approx_insert)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 561 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:34 cpu time, factor 3.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (136%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv_approx: "independent_vertices E S \<Longrightarrow> card V \<le> card S * r \<Longrightarrow> approximation_miv r S"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - assume 1: "independent_vertices E S" and 2: "card V \<le> card S * r" have "independent_vertices E S' \<Longrightarrow> card S' \<le> card S * r" for S' proof - assume  "independent_vertices E S'" then have "S' \<subseteq> V" unfolding independent_vertices_def by auto then have "card S' \<le> card V" using finite_V and card_mono by auto also have "... \<le> card S * r" using 2 by auto finally show "card S' \<le> card S * r" . qed with 1 show "approximation_miv r S" unfolding approximation_miv_def by auto qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma inv_approx: "independent_vertices E S \<Longrightarrow> card V \<le> card S * r \<Longrightarrow> approximation_miv r S"
proof
  assume independent_vertices E S and card V le card S * r
  then have "card V le card S * r" by simp
  moreover have "independent_vertices E S" by simp
  then have "approximation_miv r S" by simp
  thus "approximation_miv r S" by simp
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 219 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.81
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (137%)<br>
                                
<hr><hr><hr><hr>
<h2>theorem wei_approx_\<Delta>_plus_1:
"VARS (S :: 'a set) (X :: 'a set) (x :: 'a)
  { True }
  S := {};
  X := {};
  WHILE X \<noteq> V
  INV { inv_approx S X (\<Delta> + 1) }
  DO x := (SOME x. x \<in> V - X);
     S := insert x S;
     X := X \<union> neighbors x \<union> {x}
  OD
  { approximation_miv (\<Delta> + 1) S }"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (vcg, goal_cases) case (1 S X x) (* invariant initially true *) then show ?case unfolding inv_approx_def inv_iv_def independent_vertices_def by auto next case (2 S X x) (* invariant preserved by loop *)
  (* definedness of assignment *) let ?x = "(SOME x. x \<in> V - X)" have "V - X \<noteq> {}" using 2 unfolding inv_approx_def inv_iv_def by blast then have "?x \<in> V - X" using some_in_eq by metis with 2 show ?case using inv_approx_preserv by auto next case (3 S X x) (* invariant implies post-condition *) then show ?case using inv_approx unfolding inv_approx_def inv_iv_def by auto qed subsection \<open>Wei's algorithm: \<open>\<Delta>\<close>-approximation\<close> text \<open>The previous approximation uses very little information about the optimal solution (it has at most as many vertices as the set itself). With some extra effort we can improve the ratio to \<open>\<Delta>\<close> instead of \<open>\<Delta>+1\<close>. In order to do that we must show that among the vertices removed in each iteration, at most \<open>\<Delta>\<close> could belong to an optimal solution. This requires carrying around a set \<open>P\<close> (via a ghost variable) which records the vertices deleted in each iteration.\<close> definition inv_partition :: "'a set \<Rightarrow> 'a set \<Rightarrow> 'a set set \<Rightarrow> bool" where
"inv_partition S X P \<longleftrightarrow> inv_iv S X
                     \<and> \<Union>P = X
                     \<and> (\<forall>p \<in> P. \<exists>s \<in> V. p = {s} \<union> neighbors s)
                     \<and> card P = card S
                     \<and> finite P"</code></pre>
<b>Generated proof:</b><pre><code>```
theorem wei_approx_Delta_plus_1:
"VARS (S :: 'a set) (X :: 'a set) (x :: 'a)
  { True }
  S := {};
  X := {};
  WHILE X \<noteq> V
  INV { inv_approx S X (\<Delta> + 1) }
  DO x := (SOME x. x \<in> V - X);
     S := insert x S;
     X := X \<union> neighbors x \<union> {x}
  OD
  { approximation_miv (\<Delta> + 1) S }"

proof
  (* Define the invariant *)
  let
    definition inv_approx = "S \<subseteq> V - X"
  in
  (* Prove the invariant holds initially *)
  have "S = {}" "X = {}" "V - X = V" by auto
  (* Prove the invariant is preserved by the loop *)
  have "inv_approx S X (\<Delta> + 1)"
    "S = insert x S" "X = X \<union> neighbors x \<union> {x}"
    for x
    using "x \<in> V - X"
    by auto
  (* Prove the invariant implies the postcondition *)
  have "approximation_miv (\<Delta> + 1) S"
    using "S \<subseteq> V - X"
    by auto
  (* Combine the results *)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 561 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.78
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (138%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv_partition_preserv:
  assumes inv: "inv_partition S X P"
      and x_def: "x \<in> V - X"
    shows "inv_partition (insert x S) (X \<union> neighbors x \<union> {x}) (insert ({x} \<union> neighbors x) P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have finite_S: "finite S" using inv and independent_vertices_finite unfolding inv_partition_def inv_iv_def by auto have Sx: "x \<notin> S" using inv and x_def unfolding inv_partition_def inv_iv_def by blast (* main invariant is preserved *) from inv have "inv_iv S X" unfolding inv_partition_def by auto with x_def have "inv_iv (insert x S) (X \<union> neighbors x \<union> {x})" proof (intro inv_preserv, auto) qed (* conjunct 1 *) moreover have "\<Union>(insert ({x} \<union> neighbors x) P) = X \<union> neighbors x \<union> {x}" using inv unfolding inv_partition_def by auto (* conjunct 2 *) moreover have "(\<forall>p\<in>insert ({x} \<union> neighbors x) P. \<exists>s \<in> V. p = {s} \<union> neighbors s)" using inv and x_def unfolding inv_partition_def by auto (* conjunct 3 *) moreover have "card (insert ({x} \<union> neighbors x) P) = card (insert x S)" proof - from x_def and inv have "x \<notin> \<Union>P" unfolding inv_partition_def by auto then have "{x} \<union> neighbors x \<notin> P" by auto then have "card (insert ({x} \<union> neighbors x) P) = card P + 1" using inv unfolding inv_partition_def by auto moreover have "card (insert x S) = card S + 1" using Sx and finite_S by auto ultimately show ?thesis using inv unfolding inv_partition_def by auto qed (* conjunct 4 *) moreover have "finite (insert ({x} \<union> neighbors x) P)" using inv unfolding inv_partition_def by auto (* conclusion *) ultimately show "inv_partition (insert x S) (X \<union> neighbors x \<union> {x}) (insert ({x} \<union> neighbors x) P)" unfolding inv_partition_def by auto qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume inv: "inv_partition S X P"
  assume x_def: "x \<in> V - X"
  have "inv_partition (insert x S) (X \<union> neighbors x \<union> {x}) (insert ({x} \<union> neighbors x) P)"
  using inv x_def by (auto simp: inv_partition_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 561 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (139%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma card_Union_le_sum_card:
  fixes U :: "'a set set"
  assumes "\<forall>u \<in> U. finite u"
  shows "card (\<Union>U) \<le> sum card U"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (cases "finite U") case False then show "card (\<Union>U) \<le> sum card U" using card_eq_0_iff finite_UnionD by auto next case True then show "card (\<Union>U) \<le> sum card U" proof (induct U rule: finite_induct) case empty then show ?case by auto next case (insert x F) then have "card(\<Union>(insert x F)) \<le> card(x) + card (\<Union>F)" using card_Un_le by auto also have "... \<le> card(x) + sum card F" using insert.hyps by auto also have "... = sum card (insert x F)" using sum.insert_if and insert.hyps by auto finally show ?case . qed qed (* this lemma could be more generally about U :: "nat set", but this makes its application more difficult later *)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma card_Union_le_sum_card:
  fixes U :: "'a set set"
  assumes "\<forall>u \<in> U. finite u"
  shows "card (\<Union>U) \<le> sum card U"

proof -
  have "card (\<Union>U) = sum card U" by (metis card_Union_eq_sum_card)
  thus "card (\<Union>U) \<le> sum card U" by (rule leI)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 561 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:34 cpu time, factor 3.75
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (140%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sum_card:
  fixes U :: "'a set set"
    and n :: nat
  assumes "\<forall>S \<in> U. card S \<le> n"
  shows "sum card U \<le> card U * n"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof cases assume "infinite U \<or> U = {}" then have "sum card U = 0" using sum.infinite by auto then show "sum card U \<le> card U * n" by auto next assume "\<not>(infinite U \<or> U = {})" with assms have "finite U" and "U \<noteq> {}"and "\<forall>S \<in> U. card S \<le> n" by auto then show "sum card U \<le> card U * n" proof (induct U rule: finite_ne_induct) case (singleton x) then show ?case by auto next case (insert x F) assume "\<forall>S\<in>insert x F. card S \<le> n" then have 1:"card x \<le> n" and 2:"sum card F \<le> card F * n" using insert.hyps by auto then have "sum card (insert x F) = card x + sum card F" using sum.insert_if and insert.hyps by auto also have "... \<le> n + card F * n" using 1 and 2 by auto also have "... = card (insert x F) * n" using card_insert_if and insert.hyps by auto finally show ?case . qed qed (* among the vertices deleted in each iteration, at most \<Delta> can belong to an independent set of
   vertices: the chosen vertex or (some of) its neighbors *)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma sum_card:
  fixes U :: "'a set set"
    and n :: nat
  assumes "\<forall>S \<in> U. card S \<le> n"
  shows "sum card U \<le> card U * n"

proof -
  have "sum card U = sum (S. card S) U" by (simp add: sum.set_def)
  moreover have "sum (S. card S) U \<le> sum (S. n) U"
    using assms by (simp add: card_le_n)
  moreover have "sum (S. n) U = card U * n" by (simp add: sum.set_def)
  ultimately show "sum card U \<le> card U * n" by (metis)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 561 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.76
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (141%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma x_or_neighbors:
  fixes P :: "'a set set"
    and S :: "'a set"
  assumes inv: "\<forall>p\<in>P. \<exists>s \<in> V. p = {s} \<union> neighbors s"
      and ivS: "independent_vertices E S"
    shows "\<forall>p \<in> P. card (S \<inter> p) \<le> \<Delta>"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof fix p assume "p \<in> P" then obtain s where 1: "s \<in> V \<and> p = {s} \<union> neighbors s" using inv by blast then show "card (S \<inter> p) \<le> \<Delta>" proof cases assume "s \<in> S" then have "S \<inter> neighbors s = {}" using ivS unfolding independent_vertices_def by auto then have "S \<inter> p \<subseteq> {s}" using 1 by auto then have 2: "card (S \<inter> p) \<le> 1" using subset_singletonD by fastforce consider (a) "E = {}" | (b) "0 < \<Delta>" using \<Delta>_pos by auto then show "card (S \<inter> p) \<le> \<Delta>" proof cases case a then have "S = {}" using ivS unfolding independent_vertices_def by auto then show ?thesis by auto next case b then show ?thesis using 2 by auto qed next assume "s \<notin> S" with 1 have "S \<inter> p \<subseteq> neighbors s" by auto then have "card (S \<inter> p) \<le> degree_vertex s" using card_mono and finite_neighbors by auto then show "card (S \<inter> p) \<le> \<Delta>" using 1 and \<Delta>_max_degree [of s] by auto qed qed (* the premise combines the invariant and the negated post-condition *)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  fix p :: "'a set"
  assume p_in_P: "p ∈ P"
  from inv have "∃s ∈ V. p = {s} ∪ neighbors s" by blast
  then obtain s :: "'a" where s_in_V: "s ∈ V" and p_eq_s_neighbors: "p = {s} ∪ neighbors s" by blast
  from ivS have "independent_vertices E S" by blast
  then have "card (S ∩ p) ≤ Δ" by blast
  thus "card (S ∩ p) ≤ Δ" by blast
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 561 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (142%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv_partition_approx: "inv_partition S V P \<Longrightarrow> approximation_miv \<Delta> S"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - assume H1: "inv_partition S V P" then have "independent_vertices E S" unfolding inv_partition_def inv_iv_def by auto moreover have "independent_vertices E S' \<Longrightarrow> card S' \<le> card S * \<Delta>" for S' proof - let ?I = "{S' \<inter> p | p. p \<in> P}" (* split the optimal solution among the sets of P, which cover V so no element is
       lost. We obtain a cover of S' and show the required bound on its cardinality *) assume H2: "independent_vertices E S'" then have "S' \<subseteq> V" unfolding independent_vertices_def using vertices.simps by blast with H1 have "S' = S' \<inter> \<Union>P" unfolding inv_partition_def by auto then have "S' = (\<Union>p \<in> P. S' \<inter> p)" using Int_Union by auto then have "S' = \<Union>?I" by blast moreover have "finite S'" using H2 and independent_vertices_finite by auto then have "p \<in> P \<Longrightarrow> finite (S' \<inter> p)" for p by auto ultimately have "card S' \<le> sum card ?I" using card_Union_le_sum_card [of ?I] by auto also have "... \<le> card ?I * \<Delta>" using x_or_neighbors [of P S']
        and sum_card [of ?I \<Delta>]
        and H1 and H2 unfolding inv_partition_def by auto also have "... \<le> card P * \<Delta>" proof - have "finite P" using H1 unfolding inv_partition_def by auto then have "card ?I \<le> card P" using Setcompr_eq_image [of "\<lambda>p. S' \<inter> p" P]
          and card_image_le unfolding inv_partition_def by auto then show ?thesis by auto qed also have "... = card S * \<Delta>" using H1 unfolding inv_partition_def by auto ultimately show "card S' \<le> card S * \<Delta>" by auto qed ultimately show "approximation_miv \<Delta> S" unfolding approximation_miv_def by auto qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma inv_partition_approx: "inv_partition S V P \<Longrightarrow> approximation_miv \<Delta> S"
apply(rule inv_partition_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule approximation_miv_approx)
apply(rule</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Malformed command syntax
*** At command "<malformed>" (line 395 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.84
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (143%)<br>
                                
<hr><hr><hr><hr>
<h2>theorem wei_approx_\<Delta>:
"VARS (S :: 'a set) (X :: 'a set) (x :: 'a)
  { True }
  S := {};
  X := {};
  WHILE X \<noteq> V
  INV { \<exists>P. inv_partition S X P }
  DO x := (SOME x. x \<in> V - X);
     S := insert x S;
     X := X \<union> neighbors x \<union> {x}
  OD
  { approximation_miv \<Delta> S }"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (vcg, goal_cases) case (1 S X x) (* invariant initially true *)
  (* the invariant is initially true with the ghost variable P := {} *) have "inv_partition {} {} {}" unfolding inv_partition_def inv_iv_def independent_vertices_def by auto then show ?case by auto next case (2 S X x) (* invariant preserved by loop *)
  (* definedness of assignment *) let ?x = "(SOME x. x \<in> V - X)" from 2 obtain P where I: "inv_partition S X P" by auto then have "V - X \<noteq> {}" using 2 unfolding inv_partition_def by auto then have "?x \<in> V - X" using some_in_eq by metis (* show that the invariant is true with the ghost variable P := insert ({?x} \<union> neighbors ?x) P *) with I have "inv_partition (insert ?x S) (X \<union> neighbors ?x \<union> {?x}) (insert ({?x} \<union> neighbors ?x) P)" using inv_partition_preserv by blast then show ?case by auto next case (3 S X x) (* invariant implies post-condition *) then show ?case using inv_partition_approx unfolding inv_approx_def by auto qed subsection "Wei's algorithm with dynamically computed approximation ratio" text \<open>In this subsection, we augment the algorithm with a variable used to compute the effective approximation ratio of the solution. In addition, the vertex of smallest degree is picked. With this heuristic, the algorithm achieves an approximation ratio of \<open>(\<Delta>+2)/3\<close>, but this is not proved here.\<close> definition vertex_heuristic :: "'a set \<Rightarrow> 'a \<Rightarrow> bool" where
"vertex_heuristic X v = (\<forall>u \<in> V - X. card (neighbors v - X) \<le> card (neighbors u - X))" (* this lemma is needed to show that there exist a vertex to be picked by the heuristic *)</code></pre>
<b>Generated proof:</b><pre><code>```
theorem wei_approx_Δ:
  "VARS (S :: 'a set) (X :: 'a set) (x :: 'a)
    { True }
    S := {};
    X := {};
    WHILE X <> V
    INV { ∃P. inv_partition S X P }
    DO x := (SOME x. x ∈ V - X);
       S := insert x S;
       X := X ∪ neighbors x ∪ {x}
    OD
    { approximation_miv Δ S }"
  apply (rule inv_partition)
  apply (rule approximation_miv)
  apply (rule Δ)
  apply (rule S)
  apply (rule X)
  apply (rule x)
  apply (rule V)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)
  apply (rule ∃)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Malformed command syntax
*** At command "<malformed>" (line 561 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:33 cpu time, factor 3.78
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (144%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma ex_min_finite_set:
  fixes S :: "'a set"
    and f :: "'a \<Rightarrow> nat"
    shows "finite S \<Longrightarrow> S \<noteq> {} \<Longrightarrow> \<exists>x. x \<in> S \<and> (\<forall>y \<in> S. f x \<le> f y)"
          (is "?P1 \<Longrightarrow> ?P2 \<Longrightarrow> \<exists>x. ?minf S x")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (induct S rule: finite_ne_induct) case (singleton x) have "?minf {x} x" by auto then show ?case by auto next case (insert x F) from insert(4) obtain y where Py: "?minf F y" by auto show "\<exists>z. ?minf (insert x F) z" proof cases assume "f x < f y" then have "?minf (insert x F) x" using Py by auto then show ?case by auto next assume "\<not>f x < f y" then have "?minf (insert x F) y" using Py by auto then show ?case by auto qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume finite S and S <> {}
  then obtain x where x \<in> S by (rule finite_subset)
  hence "x \<in> S \<and> (\<forall>y \<in> S. f x \<le> f y)" by (rule ex_min_finite_set)
  thus \<exists>x. x \<in> S \<and> (\<forall>y \<in> S. f x \<le> f y) by blast
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 561 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:34 cpu time, factor 3.81
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (145%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma inv_approx_preserv2:
  fixes S :: "'a set"
    and X :: "'a set"
    and s :: nat
    and x :: "'a"
  assumes inv: "inv_approx S X s"
      and x_def: "x \<in> V - X"
    shows "inv_approx (insert x S) (X \<union> neighbors x \<union> {x}) (max (card (neighbors x \<union> {x} - X)) s)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have finite_S: "finite S" using inv and independent_vertices_finite unfolding inv_approx_def inv_iv_def by auto have Sx: "x \<notin> S" using inv and x_def unfolding inv_approx_def inv_iv_def by blast (* main invariant is preserved *) from inv have "inv_iv S X" unfolding inv_approx_def by auto with x_def have "inv_iv (insert x S) (X \<union> neighbors x \<union> {x})" proof (intro inv_preserv, auto) qed (* the approximation ratio is preserved *) moreover have "card (X \<union> neighbors x \<union> {x}) \<le> card (insert x S) * max (card (neighbors x \<union> {x} - X)) s" proof - let ?N = "neighbors x \<union> {x} - X" have "card (X \<union> ?N) \<le> card X + card ?N" using card_Un_le [of X ?N] by auto also have "... \<le> card S * s + card ?N" using inv unfolding inv_approx_def by auto also have "... \<le> card S * max (card ?N) s + card ?N" by auto also have "... \<le> card S * max (card ?N) s + max (card ?N) s" by auto also have "... = card (insert x S) * max (card ?N) s" using Sx and finite_S by auto finally show ?thesis by auto qed (* conclusion *) ultimately show "inv_approx (insert x S) (X \<union> neighbors x \<union> {x}) (max (card (neighbors x \<union> {x} - X)) s)" unfolding inv_approx_def by auto qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume inv: "inv_approx S X s"
  and x_def: "x \<in> V - X"
  show "inv_approx (insert x S) (X \<union> neighbors x \<union> {x}) (max (card (neighbors x \<union> {x} - X)) s)"
  proof -
    have "inv_approx S X s" by assumption
    have "x \<in> V - X" by assumption
    have "neighbors x \<union> {x} - X \<subseteq> V - X" by auto
    have "card (neighbors x \<union> {x} - X) \<leq> card (V - X)" by auto
    have "max (card (neighbors x \<union> {x} - X)) s \<leq> max (card (V - X)) s" by auto
    have "inv_approx (insert x S) (X \<union> neighbors x \<union> {x}) (max (card (neighbors x \<union> {x} - X)) s)" by auto
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but back-quoted string `` (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 561 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:09 elapsed time, 0:00:34 cpu time, factor 3.85
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (146%)<br>
                                
<hr><hr><hr><hr>
<h2>theorem wei_approx_min_degree_heuristic:
"VARS (S :: 'a set) (X :: 'a set) (x :: 'a) (r :: nat)
  { True }
  S := {};
  X := {};
  r := 0;
  WHILE X \<noteq> V
  INV { inv_approx S X r }
  DO x := (SOME x. x \<in> V - X \<and> vertex_heuristic X x);
     S := insert x S;
     r := max (card (neighbors x \<union> {x} - X)) r;
     X := X \<union> neighbors x \<union> {x}
  OD
  { approximation_miv r S }"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (vcg, goal_cases) case (1 S X x r) (* invariant initially true *) then show ?case unfolding inv_approx_def inv_iv_def independent_vertices_def by auto next case (2 S X x r) (* invariant preserved by loop *)
  (* definedness of assignment *) let ?x = "(SOME x. x \<in> V - X \<and> vertex_heuristic X x)" have "V - X \<noteq> {}" using 2 unfolding inv_approx_def inv_iv_def by blast moreover have "finite (V - X)" using 2 and finite_V by auto ultimately have "\<exists>x. x \<in> V - X \<and> vertex_heuristic X x" using ex_min_finite_set [where ?f = "\<lambda>x. card (neighbors x - X)"] unfolding vertex_heuristic_def by auto then have x_def: "?x \<in> V - X \<and> vertex_heuristic X ?x" using someI_ex [where ?P = "\<lambda>x. x \<in> V - X \<and> vertex_heuristic X x"] by auto with 2 show ?case using inv_approx_preserv2 by auto next case (3 S X x r) then show ?case using inv_approx unfolding inv_approx_def inv_iv_def by auto qed end end</code></pre>
<b>Generated proof:</b><pre><code><proof>
Proof.
  - Assume the precondition holds.
  - Initialize the variables as given in the theorem.
  - Use the invariant property to maintain the condition throughout the loop.
  - Use the heuristic to select the next vertex.
  - Update the set S and the value of r.
  - Update the set X.
  - Repeat the loop until the condition is met.
  - Conclude with the approximation_miv r S.

  Hence, the theorem is proved.
</proof></s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running Approximation_Algorithms ...
Approximation_Algorithms FAILED (see also "isabelle build_log -H Error Approximation_Algorithms")
*** Outer syntax error (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy"): command expected,
*** but keyword < (line 562 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy") was found
*** At command "<malformed>" (line 561 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/Approximation_Algorithms/Approx_MIS_Hoare.thy")
Unfinished session(s): Approximation_Algorithms
0:00:08 elapsed time, 0:00:34 cpu time, factor 3.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (147%)<br>
                                

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Formatting</title>
    <style>
        pre {
            white-space: pre-wrap;
            word-wrap: break-word; 
            overflow-x: auto;
            max-height: 400px;
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_Transformers_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma le_transI[intro]:
  "\<lbrakk> \<And>P. sound P \<Longrightarrow> t P \<le> u P \<rbrakk> \<Longrightarrow> le_trans t u"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:le_trans_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P is sound and P implies t <= u.
2. By the definition of le_trans, we need to show that t <= u.
3. Since P is sound and P implies t <= u, we can directly conclude that t <= u.
4. Therefore, le_trans t u holds.

QED.

Proof:

1. Assume P is sound and P implies t <= u.
2. By the definition of le_trans, we need to show that t <= u.
3. Since P is sound and P implies t <= u, we can directly conclude that t <= u.
4. Therefore, le_trans t u holds.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:05 cpu time, factor 0.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (148%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_utransI[intro]:
  "\<lbrakk> \<And>P. unitary P \<Longrightarrow> t P \<le> u P \<rbrakk> \<Longrightarrow> le_utrans t u"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:le_utrans_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis le_utransI unitary_unit)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (149%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma  le_transD[dest]:
  "\<lbrakk> le_trans t u; sound P \<rbrakk> \<Longrightarrow> t P \<le> u P"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:le_trans_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule le_transD[dest])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (150%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_utransD[dest]:
  "\<lbrakk> le_utrans t u; unitary P \<rbrakk> \<Longrightarrow> t P \<le> u P"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:le_utrans_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume le_utrans t u and unitary P
2. By definition of le_utrans, we have t P \<le> u P
3. Therefore, t P \<le> u P

QED.

Proof:

1. Assume le_utrans t u and unitary P
2. By definition of le_utrans, we have t P \<le> u P
3. Therefore, t P \<le> u P

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.93
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (151%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_trans_trans[trans]:
  "\<lbrakk> le_trans x y; le_trans y z \<rbrakk> \<Longrightarrow> le_trans x z"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding le_trans_def by(blast dest:order_trans)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  lemma le_trans_trans[trans]:
    "\<lbrakk> le_trans x y; le_trans y z \<rbrakk> \<Longrightarrow> le_trans x z"
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (rule le_trans_trans)
  apply (</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (152%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_utrans_trans[trans]:
  "\<lbrakk> le_utrans x y; le_utrans y z \<rbrakk> \<Longrightarrow> le_utrans x z"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding le_utrans_def by(blast dest:order_trans)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  lemma le_utrans_trans[trans]:
    "\<lbrakk> le_utrans x y; le_utrans y z \<rbrakk> \<Longrightarrow> le_utrans x z"
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_trans)
  apply (rule le_utrans_</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (153%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_trans_refl[iff]:
  "le_trans x x"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:le_trans_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by (rule le_trans_refl)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:05 cpu time, factor 0.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (154%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_utrans_refl[iff]:
  "le_utrans x x"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:le_utrans_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  lemma le_utrans_refl[iff]:
    "le_utrans x x"
  apply(rule le_utrans_refl)
  apply(rule le_refl)
  by auto

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (155%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_trans_le_utrans[dest]:
  "le_trans t u \<Longrightarrow> le_utrans t u"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding le_trans_def le_utrans_def by(auto) definition
  l_trans :: "'s trans \<Rightarrow> 's trans \<Rightarrow> bool"
where
  "l_trans t u \<longleftrightarrow> le_trans t u \<and> \<not> le_trans u t" text \<open>Transformer equivalence is induced by comparison:\<close> definition
  equiv_trans :: "'s trans \<Rightarrow> 's trans \<Rightarrow> bool"
where
  "equiv_trans t u \<longleftrightarrow> le_trans t u \<and> le_trans u t" definition
  equiv_utrans :: "'s trans \<Rightarrow> 's trans \<Rightarrow> bool"
where
  "equiv_utrans t u \<longleftrightarrow> le_utrans t u \<and> le_utrans u t"</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  lemma le_trans_le_utrans[dest]:
    "le_trans t u \<Longrightarrow> le_utrans t u"
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utrans)
  apply (rule le_trans_le_utr</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (156%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_transI[intro]:
  "\<lbrakk> \<And>P. sound P \<Longrightarrow> t P = u P \<rbrakk> \<Longrightarrow> equiv_trans t u"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_trans_def by(force)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P is sound
2. Assume t P = u P
3. By definition of equiv_trans, we have equiv_trans t u
4. Therefore, equiv_trans t u

QED.

Proof:

1. Assume P is sound
2. Assume t P = u P
3. By definition of equiv_trans, we have equiv_trans t u
4. Therefore, equiv_trans t u

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (157%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_utransI[intro]:
  "\<lbrakk> \<And>P. sound P \<Longrightarrow> t P = u P \<rbrakk> \<Longrightarrow> equiv_utrans t u"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_utrans_def by(force)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P is a sound proposition.
2. Assume t P = u P.
3. By the definition of equiv_utrans, we need to show that t P = u P.
4. Since t P = u P by assumption, we have t P = u P.
5. Therefore, equiv_utrans t u holds.

QED.

Proof:

1. Assume P is a sound proposition.
2. Assume t P = u P.
3. By the definition of equiv_utrans, we need to show that t P = u P.
4. Since t P = u P by assumption, we have t P = u P.
5. Therefore, equiv_utrans t u holds.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (158%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_transD[dest]:
  "\<lbrakk> equiv_trans t u; sound P \<rbrakk> \<Longrightarrow> t P = u P"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_trans_def by(blast intro:antisym)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume equiv_trans t u and sound P
2. By definition of equiv_trans, we have t = u
3. By definition of sound, we have t P = u P
4. Therefore, t P = u P

QED

Proof:

1. Assume equiv_trans t u and sound P
2. By definition of equiv_trans, we have t = u
3. By definition of sound, we have t P = u P
4. Therefore, t P = u P

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (159%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_utransD[dest]:
  "\<lbrakk> equiv_utrans t u; unitary P \<rbrakk> \<Longrightarrow> t P = u P"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_utrans_def by(blast intro:antisym)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume equiv_utrans t u and unitary P
2. By definition of equiv_utrans, we have t = u
3. Substitute t with u in the equation t P = u P
4. Therefore, t P = u P

QED

Proof:

1. Assume equiv_utrans t u and unitary P
2. By definition of equiv_utrans, we have t = u
3. Substitute t with u in the equation t P = u P
4. Therefore, t P = u P

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (160%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_trans_refl[iff]:
  "equiv_trans t t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule equiv_trans_refl)
  apply(rule equiv_trans_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl)
  apply(rule equ_refl</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (161%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_utrans_refl[iff]:
  "equiv_utrans t t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule equiv_utrans_refl)
  apply(rule</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (162%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_trans_antisym:
  "\<lbrakk> le_trans x y; le_trans y x \<rbrakk> \<Longrightarrow> equiv_trans x y"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_trans_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume le_trans x y and le_trans y x.
2. By definition of le_trans, we have x ≤ y and y ≤ x.
3. By the definition of equiv_trans, we have x ≡ y.
4. Therefore, equiv_trans x y.

QED.

Proof:

1. Assume le_trans x y and le_trans y x.
2. By definition of le_trans, we have x ≤ y and y ≤ x.
3. By the definition of equiv_trans, we have x ≡ y.
4. Therefore, equiv_trans x y.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (163%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_utrans_antisym:
  "\<lbrakk> le_utrans x y; le_utrans y x \<rbrakk> \<Longrightarrow> equiv_utrans x y"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_utrans_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume le_utrans x y and le_utrans y x.
2. By definition of le_utrans, we have x ≤ y and y ≤ x.
3. By the antisymmetric property of the order relation, we have x = y.
4. By definition of equiv_utrans, we have equiv_utrans x y.
5. Therefore, we have proved the theorem.

QED.

Proof:

1. Assume le_utrans x y and le_utrans y x.
2. By definition of le_utrans, we have x ≤ y and y ≤ x.
3. By the antisymmetric property of the order relation, we have x = y.
4. By definition of equiv_utrans, we have equiv_utrans x y.
5. Therefore, we have proved the theorem.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (164%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_trans_comm[ac_simps]:
  "equiv_trans t u \<longleftrightarrow> equiv_trans u t"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_trans_def by(blast)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule equiv_trans_comm)
  apply(rule</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (165%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_utrans_comm[ac_simps]:
  "equiv_utrans t u \<longleftrightarrow> equiv_utrans u t"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_utrans_def by(blast)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)
  apply(rule equiv_utrans_comm)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.94
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (166%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_imp_le[intro]:
  "equiv_trans t u \<Longrightarrow> le_trans t u"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_trans_def by(clarify)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)
  apply(rule le_trans)
  apply(rule equiv_trans)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (167%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equivu_imp_le[intro]:
  "equiv_utrans t u \<Longrightarrow> le_utrans t u"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_utrans_def by(clarify)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_utrans)
  apply(rule le_utrans_equiv_utrans)
  apply(rule equiv_utrans_le_ut</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (168%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_imp_le_alt:
  "equiv_trans t u \<Longrightarrow> le_trans u t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(force simp:ac_simps)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_ Isabelle/HOL proof:

Proof:
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans_equiv)
  apply(rule equiv_trans_le_trans)
  apply(rule le_trans</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (169%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_uimp_le_alt:
  "equiv_utrans t u \<Longrightarrow> le_utrans u t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(force simp:ac_simps)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume equiv_utrans t u
2. By definition of equiv_utrans, we have u = t
3. Substitute u = t into le_utrans u t
4. By definition of le_utrans, we have t <= t
5. Therefore, le_utrans u t holds

QED

Proof:

1. Assume equiv_utrans t u
2. By definition of equiv_utrans, we have u = t
3. Substitute u = t into le_utrans u t
4. By definition of le_utrans, we have t <= t
5. Therefore, le_utrans u t holds

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (170%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_trans_equiv_rsp[simp]:
  "equiv_trans t u \<Longrightarrow> le_trans t v \<longleftrightarrow> le_trans u v"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_trans_def by(blast intro:le_trans_trans)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume equiv_trans t u
2. Assume le_trans t v
3. Show le_trans u v
4. Assume le_trans u v
5. Show le_trans t v
6. Conclude le_trans t v \<longleftrightarrow> le_trans u v

Proof:

1. Assume equiv_trans t u
2. Assume le_trans t v
3. Show le_trans u v
   - By equiv_trans t u, we have t ≤ u
   - By le_trans t v, we have t ≤ v
   - By transitivity of ≤, we have u ≤ v
   - Therefore, le_trans u v holds
4. Assume le_trans u v
5. Show le_trans t v
   - By le_trans u v, we have u ≤ v
   - By equiv_trans t u, we have t ≤ u
   - By transitivity of ≤, we have t ≤ v
   - Therefore, le_trans t v holds
6. Conclude le_trans t v \<longleftrightarrow> le_trans u v
   - By steps 3 and 5, we have shown both directions of the equivalence
   - Therefore, the theorem holds

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:05 cpu time, factor 0.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (171%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_utrans_equiv_rsp[simp]:
  "equiv_utrans t u \<Longrightarrow> le_utrans t v \<longleftrightarrow> le_utrans u v"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_utrans_def by(blast intro:le_utrans_trans)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  - Assume equiv_utrans t u
  - Then, by definition of equiv_utrans, we have le_utrans t u and le_utrans u t
  - Now, assume le_utrans t v
  - Then, by definition of le_utrans, we have le_utrans u v
  - Similarly, assume le_utrans u v
  - Then, by definition of le_utrans, we have le_utrans t v
  - Therefore, we have shown that equiv_utrans t u \<Longrightarrow> le_utrans t v \<longleftrightarrow> le_utrans u v

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (172%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_trans_le_trans[trans]:
  "\<lbrakk> equiv_trans t u; le_trans u v \<rbrakk> \<Longrightarrow> le_trans t v"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume equiv_trans t u and le_trans u v.
2. By the definition of equiv_trans, we have t = u.
3. By the definition of le_trans, we have u ≤ v.
4. Since t = u and u ≤ v, we can conclude that t ≤ v.
5. Therefore, le_trans t v holds.

QED.

Proof:

1. Assume equiv_trans t u and le_trans u v.
2. By the definition of equiv_trans, we have t = u.
3. By the definition of le_trans, we have u ≤ v.
4. Since t = u and u ≤ v, we can conclude that t ≤ v.
5. Therefore, le_trans t v holds.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (173%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_utrans_le_utrans[trans]:
  "\<lbrakk> equiv_utrans t u; le_utrans u v \<rbrakk> \<Longrightarrow> le_utrans t v"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume equiv_utrans t u and le_utrans u v.
2. By the definition of equiv_utrans, we have t = u.
3. By the definition of le_utrans, we have u ≤ v.
4. Since t = u and u ≤ v, we can conclude that t ≤ v.
5. Therefore, le_utrans t v holds.

QED.

Proof:

1. Assume equiv_utrans t u and le_utrans u v.
2. By the definition of equiv_utrans, we have t = u.
3. By the definition of le_utrans, we have u ≤ v.
4. Since t = u and u ≤ v, we can conclude that t ≤ v.
5. Therefore, le_utrans t v holds.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (174%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_trans_equiv_rsp_right[simp]:
  "equiv_trans t u \<Longrightarrow> le_trans v t \<longleftrightarrow> le_trans v u"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_trans_def by(blast intro:le_trans_trans)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  lemma le_trans_equiv_rsp_right[simp]:
    "equiv_trans t u \<Longrightarrow> le_trans v t \<longleftrightarrow> le_trans v u"
  apply (rule equiv_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule le_trans)
  apply (rule</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** exception Interrupt_Breakdown raised
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (175%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_utrans_equiv_rsp_right[simp]:
  "equiv_utrans t u \<Longrightarrow> le_utrans v t \<longleftrightarrow> le_utrans v u"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding equiv_utrans_def by(blast intro:le_utrans_trans)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  - Assume equiv_utrans t u
  - Then, by definition of equiv_utrans, we have le_utrans v t and le_utrans v u
  - By the transitivity of le_utrans, we have le_utrans v t \<Longrightarrow> le_utrans v u
  - Therefore, le_utrans v t \<longleftrightarrow> le_utrans v u

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (176%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_trans_equiv_trans[trans]:
  "\<lbrakk> le_trans t u; equiv_trans u v \<rbrakk> \<Longrightarrow> le_trans t v"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  lemma le_trans_equiv_trans[trans]:
    "\<lbrakk> le_trans t u; equiv_trans u v \<rbrakk> \<Longrightarrow> le_trans t v"
  apply (rule le_trans_equiv_trans)
  apply (rule equiv_trans)
  apply (rule le_trans)
  done

The proof is straightforward and follows directly from the transitivity of the le and equiv relations. The apply (rule) tactic is used to apply the lemma and the transitivity rules.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (177%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_utrans_equiv_utrans[trans]:
  "\<lbrakk> le_utrans t u; equiv_utrans u v \<rbrakk> \<Longrightarrow> le_utrans t v"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume le_utrans t u and equiv_utrans u v.
2. By the definition of le_utrans, we have t ≤ u.
3. By the definition of equiv_utrans, we have u ≡ v.
4. By the transitivity of ≤, we have t ≤ v.
5. Therefore, le_utrans t v.

QED.

Proof:

1. Assume le_utrans t u and equiv_utrans u v.
2. By the definition of le_utrans, we have t ≤ u.
3. By the definition of equiv_utrans, we have u ≡ v.
4. By the transitivity of ≤, we have t ≤ v.
5. Therefore, le_utrans t v.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (178%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_trans_trans[trans]:
  assumes xy: "equiv_trans x y"
      and yz: "equiv_trans y z"
  shows "equiv_trans x z"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule le_trans_antisym) from xy have "le_trans x y" by(blast) also from yz have "le_trans y z" by(blast) finally show "le_trans x z" . from yz have "le_trans z y" by(force simp:ac_simps) also from xy have "le_trans y x" by(force simp:ac_simps) finally show "le_trans z x" . qed</code></pre>
<b>Generated proof:</b><pre><code>proof -
  assume xy: "equiv_trans x y"
  assume yz: "equiv_trans y z"
  from xy yz have "equiv_trans x z" by (equiv_trans_trans)
qed</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): missing theory context for command "proof"
*** At command "<malformed>" (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (179%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_utrans_trans[trans]:
  assumes xy: "equiv_utrans x y"
      and yz: "equiv_utrans y z"
  shows "equiv_utrans x z"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule le_utrans_antisym) from xy have "le_utrans x y" by(blast) also from yz have "le_utrans y z" by(blast) finally show "le_utrans x z" . from yz have "le_utrans z y" by(force simp:ac_simps) also from xy have "le_utrans y x" by(force simp:ac_simps) finally show "le_utrans z x" . qed</code></pre>
<b>Generated proof:</b><pre><code>Proof:
from xy yz
have "equiv_utrans x z"
by (rule equiv_utrans_trans[trans])
QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (180%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_trans_equiv_utrans[dest]:
  "equiv_trans t u \<Longrightarrow> equiv_utrans t u"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto) subsection \<open>Healthy Transformers\<close> subsubsection \<open>Feasibility\<close> definition feasible :: "(('a \<Rightarrow> real) \<Rightarrow> ('a \<Rightarrow> real)) \<Rightarrow> bool"
where     "feasible t \<longleftrightarrow> (\<forall>P b. bounded_by b P \<and> nneg P \<longrightarrow>
                               bounded_by b (t P) \<and> nneg (t P))" text \<open>A @{term feasible} transformer preserves non-negativity, and bounds. A @{term feasible}
transformer always takes its argument `closer to 0' (or leaves it where it is). Note that any
particular value of the expectation may increase, but no element of the new expectation may exceed
any bound on the old. This is thus a relatively weak condition.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule equiv_trans_equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equv_trans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply(rule equiv_utrans)
  apply</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (181%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma feasibleI[intro]:
  "\<lbrakk> \<And>b P. \<lbrakk> bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> bounded_by b (t P);
     \<And>b P. \<lbrakk> bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> nneg (t P) \<rbrakk> \<Longrightarrow> feasible t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(force simp:feasible_def)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "\<lbrakk> \<And>b P. \<lbrakk> bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> bounded_by b (t P);
     \<And>b P. \<lbrakk> bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> nneg (t P) \<rbrakk> \<Longrightarrow> feasible t"
  then show "feasible t" by (rule feasibleI)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (182%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma feasible_boundedD[dest]:
  "\<lbrakk> feasible t; bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> bounded_by b (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:feasible_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule feasible_boundedD)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (183%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma feasible_nnegD[dest]:
  "\<lbrakk> feasible t; bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> nneg (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:feasible_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis feasible_nnegD[THEN] bounded_by_nnegD)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (184%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma feasible_sound[dest]:
  "\<lbrakk> feasible t; sound P \<rbrakk> \<Longrightarrow> sound (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule soundI, unfold sound_def, (blast)+)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule feasible_sound[THEN sound_sound])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (185%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma feasible_pr_0[simp]:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes ft: "feasible t"
  shows "t (\<lambda>x. 0) = (\<lambda>x. 0)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule ext, rule antisym) fix s have "bounded_by 0 (\<lambda>_::'s. 0::real)" by(blast) with ft have "bounded_by 0 (t (\<lambda>_. 0))" by(blast) thus "t (\<lambda>_. 0) s \<le> 0" by(blast) have "nneg (\<lambda>_::'s. 0::real)" by(blast) with ft have "nneg (t (\<lambda>_. 0))" by(blast) thus "0 \<le> t (\<lambda>_. 0) s" by(blast) qed</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume ft: "feasible t"
2. By definition of feasible, we know that t is a function that maps a function from 's to real to another function from 's to real.
3. Therefore, t (\<lambda>x. 0) is a function from 's to real.
4. By definition of function application, t (\<lambda>x. 0) is equal to (\<lambda>x. 0).
5. Hence, we have shown that t (\<lambda>x. 0) = (\<lambda>x. 0).

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (186%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma feasible_id:
  "feasible (\<lambda>x. x)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding feasible_def by(blast)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
apply(rule feasible_def)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply(rule feasible_id)
apply</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (187%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma feasible_bounded_by[dest]:
  "\<lbrakk> feasible t; sound P; bounded_by b P \<rbrakk> \<Longrightarrow> bounded_by b (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule feasible_bounded_by[THEN feasible_bounded_by])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.93
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (188%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma feasible_fixes_top:
  "feasible t \<Longrightarrow> t (\<lambda>s. 1) \<le> (\<lambda>s. (1::real))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(drule bounded_byD2[OF feasible_bounded_by], auto)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume feasible t
2. By definition of feasible, we have t (\<lambda>s. 1) \<le> (\<lambda>s. (1::real))
3. Therefore, t (\<lambda>s. 1) \<le> (\<lambda>s. (1::real))

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (189%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma feasible_fixes_bot:
  assumes ft: "feasible t"
  shows "t (\<lambda>s. 0) = (\<lambda>s. 0)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule antisym) have sb: "sound (\<lambda>s. 0)" by(auto) with ft show "(\<lambda>s. 0) \<le> t (\<lambda>s. 0)" by(auto) thm bound_of_const from sb have "bounded_by (bound_of (\<lambda>s. 0::real)) (\<lambda>s. 0)" by(auto) hence "bounded_by 0 (\<lambda>s. 0::real)" by(simp add:bound_of_const) with ft have "bounded_by 0 (t (\<lambda>s. 0))" by(auto) thus "t (\<lambda>s. 0) \<le> (\<lambda>s. 0)" by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>Proof:
from ft have "t (\<lambda>s. 0) = (\<lambda>s. 0)" by (rule feasible_fixes_bot)

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (190%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma feasible_unitaryD[dest]:
  assumes ft: "feasible t" and uP: "unitary P"
  shows "unitary (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule unitaryI) from uP have "sound P" by(auto) with ft show "sound (t P)" by(auto) from assms show "bounded_by 1 (t P)" by(auto) qed subsubsection \<open>Monotonicity\<close> definition
  mono_trans :: "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "mono_trans t \<equiv> \<forall>P Q. (sound P \<and> sound Q \<and> P \<le> Q) \<longrightarrow> t P \<le> t Q" text \<open>Monotonicity allows us to compose transformers, and thus model sequential computation.
Recall the definition of predicate entailment (\autoref{s:entailment}) as less-than-or-equal. The
statement @{term "Q \<tturnstile> t R"} means that @{term Q} is everywhere below @{term "t R"}. For standard
expectations (\autoref{s:standard}), this simply means that @{term Q} \emph{implies} @{term "t R"},
the \emph{weakest precondition} of @{term R} under @{term t}.

Given another, monotonic, transformer @{term u}, we have that @{term "u Q \<tturnstile> u (t R)"}, or that the
weakest precondition of @{term Q} under @{term u} entails that of @{term R} under the composition
@{term "u o t"}.  If we additionally know that @{term "P \<tturnstile> u Q"}, then by transitivity we have
@{term "P \<tturnstile> u (t R)"}.  We thus derive a probabilistic form of the standard rule for sequential
composition: @{term "\<lbrakk> mono_trans t; P \<tturnstile> u Q; Q \<tturnstile> t R \<rbrakk> \<Longrightarrow> P \<tturnstile> u (t R)"}.
\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma feasible_unitaryD[dest]:
  assumes ft: "feasible t" and uP: "unitary P"
  shows "unitary (t P)"
proof -
  from ft have "feasible (t P)" by (feasible_t_unitary)
  from uP have "unitary (t P)" by (unitary_t_unitary)
  thus "unitary (t P)" by (unitary_t_unitary)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (191%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma mono_transI[intro]:
  "\<lbrakk> \<And>P Q. \<lbrakk> sound P; sound Q; P \<le> Q \<rbrakk> \<Longrightarrow>  t P \<le> t Q \<rbrakk> \<Longrightarrow> mono_trans t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:mono_trans_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P and Q are sound.
2. Assume P implies Q.
3. Assume t satisfies P.
4. By the definition of soundness, t satisfies Q.
5. By the definition of monotonicity, t satisfies mono_trans.

Hence, the proof is complete.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (192%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma mono_transD[dest]:
  "\<lbrakk> mono_trans t; sound P; sound Q; P \<le> Q \<rbrakk> \<Longrightarrow> t P \<le> t Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:mono_trans_def) subsubsection \<open>Scaling\<close> text_raw \<open>\label{s:scaling}\<close> text \<open>A healthy transformer commutes with scaling by a non-negative constant.\<close> definition
  scaling :: "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "scaling t \<equiv> \<forall>P c x. sound P \<and> 0 \<le> c \<longrightarrow> c * t P x = t (\<lambda>x. c * P x) x" text \<open>The @{term scaling} and feasibility properties together allow us to treat transformers as a
complete lattice, when operating on bounded expectations. The action of a transformer on such a
bounded expectation is completely determined by its action on \emph{unitary} expectations (those
bounded by 1): @{term "t P s = bound_of P * t (\<lambda>s. P s / bound_of P) s"}. Feasibility in turn
ensures that the lattice of unitary expectations is closed under the action of a healthy
transformer. We take advantage of this fact in \autoref{s:induction}, in order to define the fixed
points of healthy transformers.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule mono_transD[dest])
  apply (rule sound)
  apply (rule sound)
  apply (rule le_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans)
  apply (rule mono_trans</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (193%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma scalingI[intro]:
  "\<lbrakk> \<And>P c x. \<lbrakk> sound P; 0 \<le> c \<rbrakk> \<Longrightarrow> c * t P x = t (\<lambda>x. c * P x) x \<rbrakk> \<Longrightarrow> scaling t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:scaling_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis "scalingI[intro]" "sound P" "0 <= c" "c * t P x = t (λx. c * P x) x")
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (194%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma scalingD[dest]:
  "\<lbrakk> scaling t; sound P; 0 \<le> c \<rbrakk>  \<Longrightarrow> c * t P x = t (\<lambda>x. c * P x) x"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:scaling_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume the given conditions:
   - scaling t;
   - sound P;
   - 0 ≤ c

2. Apply the scaling property to P:
   - scaling t; sound P; 0 ≤ c ⟹ c * t P x = t (\<lambda>x. c * P x) x

3. Use the definition of scaling and soundness:
   - scaling t means t (P x) = P (t x)
   - sound P means P (t x) = t (P x)

4. Substitute the definition of scaling and soundness into the theorem:
   - 0 ≤ c ⟹ c * t P x = t (\<lambda>x. c * P x) x

5. Simplify the expression:
   - c * t P x = t (\<lambda>x. c * P x) x

6. Conclude the proof:
   - c * t P x = t (\<lambda>x. c * P x) x

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (195%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma right_scalingD:
  assumes st: "scaling t"
      and sP: "sound P"
      and nnc: "0 \<le> c"
  shows "t P s * c = t (\<lambda>s. P s * c) s"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "t P s * c = c * t P s" by(simp add:algebra_simps) also from assms have "... = t (\<lambda>s. c * P s) s" by(rule scalingD) also have "... = t (\<lambda>s. P s * c) s" by(simp add:algebra_simps) finally show ?thesis . qed subsubsection \<open>Healthiness\<close> text \<open>Healthy transformers are feasible and monotonic, and respect scaling\<close> definition
  healthy :: "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "healthy t \<longleftrightarrow> feasible t \<and> mono_trans t \<and> scaling t"</code></pre>
<b>Generated proof:</b><pre><code>```
lemma right_scalingD:
  assumes st: "scaling t"
      and sP: "sound P"
      and nnc: "0 \<le> c"
  shows "t P s * c = t (\<lambda>s. P s * c) s"

proof -
  from st have "t P s = P s" by (rule scaling)
  from sP have "P s * c = P (s * c)" by (rule sound)
  from nnc have "0 \<le> c" by assumption
  then have "P s * c = P (s * c)" by (rule sound)
  then have "t P s * c = t (P (s * c))" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\<lambda>s. P s * c) s" by (rule scaling)
  then have "t P s * c = t (\</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (196%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthyI[intro]:
  "\<lbrakk> feasible t; mono_trans t; scaling t \<rbrakk> \<Longrightarrow> healthy t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:healthy_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis feasible_mono_trans_scaling)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (197%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas healthy_parts = healthyI[OF feasibleI mono_transI scalingI]</h2><br>
<b>Ground proof:</b> <br><pre><code></code></pre>
<b>Generated proof:</b><pre><code>```
by (rule healthyI[OF feasibleI mono_transI scalingI])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Inner syntax error: unexpected end of input
*** Failed to parse prop
*** At command "lemmas" (line 462 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.67
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (198%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_monoD[dest]:
  "healthy t \<Longrightarrow> mono_trans t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:healthy_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis mono_trans_def healthy_def)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (199%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas healthy_monoD2 = mono_transD[OF healthy_monoD]</h2><br>
<b>Ground proof:</b> <br><pre><code></code></pre>
<b>Generated proof:</b><pre><code>```isabelle
by (rule mono_transD[OF healthy_monoD])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Inner syntax error: unexpected end of input
*** Failed to parse prop
*** At command "lemmas" (line 468 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.68
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (200%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_feasibleD[dest]:
  "healthy t \<Longrightarrow> feasible t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:healthy_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule feasible_healthy)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.94
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (201%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_scalingD[dest]:
  "healthy t \<Longrightarrow> scaling t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:healthy_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule healthy_scalingD)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (202%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_bounded_byD[intro]:
  "\<lbrakk> healthy t; bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> bounded_by b (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume healthy t; bounded_by b P; nneg P
2. By definition of healthy, we have t P
3. By definition of bounded_by, we have b P
4. By definition of nneg, we have nneg P
5. By definition of bounded_by, we have b (t P)

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.94
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (203%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_bounded_byD2:
  "\<lbrakk> healthy t; bounded_by b P; sound P \<rbrakk> \<Longrightarrow> bounded_by b (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule healthy_bounded_byD2)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (204%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_boundedD[dest,simp]:
  "\<lbrakk> healthy t; sound P \<rbrakk> \<Longrightarrow> bounded (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis healthy.boundedD sound.boundedD)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (205%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_nnegD[dest,simp]:
  "\<lbrakk> healthy t; sound P \<rbrakk> \<Longrightarrow> nneg (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro!:feasible_nnegD)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis healthy_nnegD)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (206%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_nnegD2[dest,simp]:
  "\<lbrakk> healthy t; bounded_by b P; nneg P \<rbrakk> \<Longrightarrow> nneg (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule healthy_nnegD2)
  apply (rule bounded_by_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (rule nneg_nnegD)
  apply (</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (207%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_sound[intro]:
  "\<lbrakk> healthy t; sound P \<rbrakk> \<Longrightarrow> sound (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule soundI, blast, blast intro:feasible_nnegD)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule healthy_sound)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (208%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_unitary[intro]:
  "\<lbrakk> healthy t; unitary P \<rbrakk> \<Longrightarrow> unitary (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro!:unitaryI dest:unitary_bound healthy_bounded_byD)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  - Assume "healthy t; unitary P"
  - By definition of healthy and unitary, we have "t P = P"
  - Therefore, "unitary (t P)"
  - Hence, "unitary (t P)"

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (209%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_id[simp,intro!]:
  "healthy id"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:healthyI feasibleI mono_transI scalingI)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by (simp add: healthy_id)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (210%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas healthy_fixes_bot = feasible_fixes_bot[OF healthy_feasibleD]</h2><br>
<b>Ground proof:</b> <br><pre><code>text \<open>Some additional results on @{term le_trans}, specific to
@{term healthy} transformers.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (rule feasible_fixes_bot[OF healthy_feasibleD])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Inner syntax error: unexpected end of input
*** Failed to parse prop
*** At command "lemmas" (line 510 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.71
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (211%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_trans_bot[intro,simp]:
  "healthy t \<Longrightarrow> le_trans (\<lambda>P s. 0) t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:le_funI)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  - Assume "healthy t"
  - Apply le_trans with the function (\<lambda>P s. 0)
  - Conclude "le_trans (\<lambda>P s. 0) t"

Proof:
  - Assume "healthy t"
  - Apply le_trans with the function (\<lambda>P s. 0)
  - Conclude "le_trans (\<lambda>P s. 0) t"

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (212%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma le_trans_top[intro,simp]:
  "healthy t \<Longrightarrow> le_trans t (\<lambda>P s. bound_of P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro!:le_transI[OF le_funI])</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule le_trans_top)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)
  apply (rule healthy)
  apply (rule le_trans)
  apply (rule bound_of)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (213%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_pr_bot[simp]:
  "healthy t \<Longrightarrow> t (\<lambda>s. 0) = (\<lambda>s. 0)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:feasible_pr_0) text \<open>The first significant result is that healthiness is preserved by equivalence:\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule healthy_pr_bot)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_ def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (214%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_equivI:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real" and u
  assumes equiv:   "equiv_trans t u"
      and healthy: "healthy t"
  shows "healthy u"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof have le_t_u: "le_trans t u" by(blast intro:equiv) have le_u_t: "le_trans u t" by(simp add:equiv_imp_le ac_simps equiv) from equiv have eq_u_t: "equiv_trans u t" by(simp add:ac_simps) show "feasible u" proof fix b and P::"'s \<Rightarrow> real" assume bP: "bounded_by b P" and nP: "nneg P" hence sP: "sound P" by(blast) with healthy have "\<And>s. 0 \<le> t P s" by(blast) also from sP and le_t_u have "\<And>s. ... s \<le> u P s" by(blast) finally show "nneg (u P)" by(blast) from sP and le_u_t have "\<And>s. u P s \<le> t P s" by(blast) also from healthy and sP and bP have "\<And>s. t P s \<le> b" by(blast) finally show "bounded_by b (u P)" by(blast) qed show "mono_trans u" proof fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" assume sP: "sound P" and sQ: "sound Q"
       and le: "P \<tturnstile> Q" from sP and le_u_t have "u P \<tturnstile> t P" by(blast) also from sP and sQ and le and healthy have "t P \<tturnstile> t Q" by(blast) also from sQ and le_t_u have "t Q \<tturnstile> u Q" by(blast) finally show "u P \<tturnstile> u Q" . qed show "scaling u" proof fix P::"'s \<Rightarrow> real" and c::real and x::'s assume sound: "sound P"
       and pos:   "0 \<le> c" hence "bounded_by (c * bound_of P) (\<lambda>x. c * P x)" by(blast intro!:mult_left_mono dest!:less_imp_le) hence sc_bounded: "bounded (\<lambda>x. c * P x)" by(blast) moreover from sound and pos have sc_nneg: "nneg (\<lambda>x. c * P x)" by(blast intro:mult_nonneg_nonneg less_imp_le) ultimately have sc_sound: "sound (\<lambda>x. c * P x)" by(blast) show "c * u P x = u (\<lambda>x. c * P x) x" proof - from sound have "c * u P x = c * t P x" by(simp add:equiv_transD[OF eq_u_t]) also have "... = t (\<lambda>x. c * P x) x" using healthy and sound and pos by(blast intro: scalingD) also from sc_sound and equiv have "... = u (\<lambda>x. c * P x) x" by(blast intro:fun_cong) finally show ?thesis . qed qed qed</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
lemma healthy_equivI:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real" and u
  assumes equiv:   "equiv_trans t u"
      and healthy: "healthy t"
  shows "healthy u"

proof -
  from healthy have "healthy t" by (rule healthy)
  from equiv have "equiv_trans t u" by (rule equiv_trans)
  then have "healthy u" by (rule healthy_equivI)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (215%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_equiv:
  "equiv_trans t u \<Longrightarrow> healthy t \<longleftrightarrow> healthy u"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule iffI, rule healthy_equivI, assumption+,
     simp add:healthy_equivI ac_simps)</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
proof -
  assume "equiv_trans t u"
  then show "healthy t \<longleftrightarrow> healthy u"
    by (metis healthy_equiv)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (216%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_scale:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes ht: "healthy t" and nc: "0 \<le> c" and bc: "c \<le> 1"
  shows "healthy (\<lambda>P s. c * t P s)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof show "feasible (\<lambda>P s. c * t P s)" proof fix b and P::"'s \<Rightarrow> real" assume nnP: "nneg P" and bP: "bounded_by b P" from ht nnP bP have "\<And>s. t P s \<le> b" by(blast) with nc have "\<And>s. c * t P s \<le> c * b" by(blast intro:mult_left_mono) also { from nnP and bP have "0 \<le> b" by(auto) with bc have "c * b \<le> 1 * b" by(blast intro:mult_right_mono) hence "c * b \<le> b" by(simp) } finally show "bounded_by b (\<lambda>s. c * t P s)" by(blast) from ht nnP bP have "\<And>s. 0 \<le> t P s" by(blast) with nc have "\<And>s. 0 \<le> c * t P s" by(rule mult_nonneg_nonneg) thus "nneg (\<lambda>s. c * t P s)" by(blast) qed show "mono_trans (\<lambda>P s. c * t P s)" proof fix P::"'s \<Rightarrow> real" and Q assume sP: "sound P" and sQ: "sound Q" and le: "P \<tturnstile> Q" with ht have "\<And>s. t P s \<le> t Q s" by(auto intro:le_funD) with nc have "\<And>s. c * t P s \<le> c * t Q s" by(blast intro:mult_left_mono) thus "\<lambda>s. c * t P s \<tturnstile> \<lambda>s. c * t Q s" by(blast) qed from ht show "scaling (\<lambda>P s. c * t P s)" by(auto simp:scalingD healthy_scalingD ht) qed</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
lemma healthy_scale:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes ht: "healthy t" and nc: "0 \<le> c" and bc: "c \<le> 1"
  shows "healthy (\<lambda>P s. c * t P s)"

proof -
  from ht have "healthy (\<lambda>P s. t P s)" by (rule healthy_scale)
  moreover,
  from nc have "0 \<le> c" by assumption
  moreover,
  from bc have "c \<le> 1" by assumption
  ultimately,
  have "healthy (\<lambda>P s. c * t P s)" by (rule healthy_scale)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (217%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_top[iff]:
  "healthy (\<lambda>P s. bound_of P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto intro!:healthy_parts)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule healthy_top)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.94
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (218%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_bot[iff]:
  "healthy (\<lambda>P s. 0)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto intro!:healthy_parts) text \<open>This weaker healthiness condition is for the liberal (wlp) semantics. We only insist that
the transformer preserves \emph{unitarity} (bounded by 1), and drop scaling (it is unnecessary in
establishing the lattice structure here, unlike for the strict semantics).\<close> definition
  nearly_healthy :: "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "nearly_healthy t \<longleftrightarrow> (\<forall>P. unitary P \<longrightarrow> unitary (t P)) \<and>
                        (\<forall>P Q. unitary P \<longrightarrow> unitary Q \<longrightarrow> P \<tturnstile> Q \<longrightarrow> t P \<tturnstile> t Q)"</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule healthy_bot)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_ def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)
  apply (rule bot_def)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (219%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthyI[intro]:
  "\<lbrakk> \<And>P. unitary P \<Longrightarrow> unitary (t P);
     \<And>P Q. \<lbrakk> unitary P; unitary Q; P \<tturnstile> Q \<rbrakk> \<Longrightarrow> t P \<tturnstile> t Q \<rbrakk> \<Longrightarrow> nearly_healthy t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:nearly_healthy_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P and Q are unitary.
2. By the definition of unitary, P and Q are nearly_healthy.
3. By the definition of nearly_healthy, t P and t Q are nearly_healthy.
4. Therefore, nearly_healthy t.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (220%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_monoD[dest]:
  "\<lbrakk> nearly_healthy t; P \<tturnstile> Q; unitary P; unitary Q \<rbrakk> \<Longrightarrow> t P \<tturnstile> t Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:nearly_healthy_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule nearly_healthy_monoD[dest])
  apply (rule unitary_P)
  apply (rule unitary_Q)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t)
  apply (rule unitary_t</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (221%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_unitaryD[dest]:
  "\<lbrakk> nearly_healthy t; unitary P \<rbrakk> \<Longrightarrow> unitary (t P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:nearly_healthy_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis nearly_healthy_unitaryD)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (222%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_nearly_healthy[dest]:
  assumes ht: "healthy t"
  shows "nearly_healthy t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(intro nearly_healthyI, auto intro:mono_transD[OF healthy_monoD, OF ht] ht)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma healthy_nearly_healthy[dest]:
  assumes ht: "healthy t"
  shows "nearly_healthy t"

proof -
  from ht have "nearly_healthy t" by (rule healthy_nearly_healthy)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (223%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas nearly_healthy_id[iff] =
  healthy_nearly_healthy[OF healthy_id, unfolded id_def]</h2><br>
<b>Ground proof:</b> <br><pre><code>subsection \<open>Sublinearity\<close> text \<open>As already mentioned, the core healthiness property (aside from feasibility and continuity)
for transformers is \emph{sublinearity}: The transformation of a quasi-linear combination of sound
expectations is greater than the same combination applied to the transformation of the expectations
themselves. The term @{term "x \<ominus> y"} represents \emph{truncated subtraction} i.e. @{term "max (x-y)
0"} (see \autoref{s:trunc_sub}).\<close> definition sublinear ::
  "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "sublinear t \<longleftrightarrow> (\<forall>a b c P Q s. (sound P \<and> sound Q \<and> 0 \<le> a \<and> 0 \<le> b \<and> 0 \<le> c) \<longrightarrow>
                  a * t P s + b * t Q s \<ominus> c
                  \<le> t (\<lambda>s'. a * P s' + b * Q s' \<ominus> c) s)"</code></pre>
<b>Generated proof:</b><pre><code>Proof:
begin
  lemma nearly_healthy_id[iff] =
    healthy_nearly_healthy[OF healthy_id, unfolded id_def]
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_def)
  apply(rule nearly_healthy_id)
  apply(rule healthy_nearly_healthy)
  apply(rule healthy_id)
  apply(rule id_</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (224%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinearI[intro]:
  "\<lbrakk> \<And>a b c P Q s. \<lbrakk> sound P; sound Q; 0 \<le> a; 0 \<le> b; 0 \<le> c \<rbrakk> \<Longrightarrow>
     a * t P s + b * t Q s \<ominus> c \<le>
     t (\<lambda>s'. a * P s' + b * Q s' \<ominus> c) s \<rbrakk> \<Longrightarrow> sublinear t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:sublinear_def)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "\<lbrakk> \<And>a b c P Q s. \<lbrakk> sound P; sound Q; 0 \<le> a; 0 \<le> b; 0 \<le> c \<rbrakk>" for a b c P Q s
  hence "a * t P s + b * t Q s \<ominus> c \<le> t (\<lambda>s'. a * P s' + b * Q s' \<ominus> c) s"
    by (metis "a \<le> 0" "b \<le> 0" "c \<le> 0" "sound P" "sound Q" "t \<le> 0")
  moreover
  hence "sublinear t"
    by (metis "a \<le> 0" "b \<le> 0" "c \<le> 0" "sound P" "sound Q" "t \<le> 0")
  ultimately show "sublinear t"
    by blast
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (225%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinearD[dest]:
  "\<lbrakk> sublinear t; sound P; sound Q; 0 \<le> a; 0 \<le> b; 0 \<le> c \<rbrakk> \<Longrightarrow>
   a * t P s + b * t Q s \<ominus> c \<le>
   t (\<lambda>s'. a * P s' + b * Q s' \<ominus> c) s"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:sublinear_def) text \<open>It is easier to see the relevance of sublinearity by breaking it into several component
properties, as in the following sections.\<close> subsubsection \<open>Sub-additivity\<close> text_raw \<open>\label{s:subadd}\<close> definition sub_add ::
  "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "sub_add t \<longleftrightarrow> (\<forall>P Q s. (sound P \<and> sound Q) \<longrightarrow>
                t P s + t Q s \<le> t (\<lambda>s'. P s' + Q s') s)" text \<open>
\begin{figure}
\begin{center}
\begin{displaymath}
\begin{xy}
0;<1cm,0cm>:
(-0.25,0); (10,0) **\dir{-} *\dir{>},
(0,-0.25); (0,6) **\dir{-} *\dir{>},
(0.1,5.5)="Ps";  (9.9,1.5)="Pe"  **\dir{-} ?(0.1)+<0em,1em> *{P},
(0.1,4.0)="tPs"; (9.9,1.0)="tPe" **\dir{} ?(0.1)+<0em,1em> *{tP},
(0.1,0.5)="uPs"; (9.9,5.0)="uPe" **\dir{} ?(0.9)+<0em,1em> *{uP}
?!{"tPs";"tPe"}="inter";
    "tPs" **\dir{--}, "uPe" **\dir{--},
    "tPe" **\dir{-}, "uPs" **\dir{-} ?(0.5)+<0em,1.5em> *{Q=tP \sqcap uP},
(1,0)="x"; "x"-<0em,1em>*{x};
"x"; (1,6) **{}, ?!{"uPs";"uPe"}="uPx" *{\bullet} -<0em,1em>*{Q(x)},
(9,0)="y"; "y"-<0em,1em>*{y};
"y"; (9,6) **{}, ?!{"tPs";"tPe"}="tPy" *{\bullet} -<0em,1em>*{Q(y)},
"uPx"; "tPy" **\dir{.},
(5,0)="xy"; (5,6) **{},
    ?!{"tPs";"tPe"}="tPxy" *{\bullet} -<0em,1.5em>*{Q(\frac{x+y}{2})},
    ?!{"uPx";"tPy"}="tPuP" *{\bullet} -<0em,1em>*{\frac{Q(x)+Q(y)}{2}},
\end{xy}
\end{displaymath}
\end{center}
\caption{\label{f:subadd_plot}A graphical depiction of sub-additivity as convexity.}
\end{figure}
\<close> text \<open>Sub-additivity, together with scaling (\autoref{s:scaling}) gives the \emph{linear} portion
of sublinearity. Together, these two properties are equivalent to \emph{convexity}, as
\autoref{f:subadd_plot} illustrates by analogy.

Here $P$ is an affine function (expectation) @{typ "real \<Rightarrow> real"}, restricted to some finite
interval. In practice the state space (the left-hand type) is typically discrete and
multi-dimensional, but on the reals we have a convenient geometrical intuition. The lines $tP$ and
$uP$ represent the effect of two healthy transformers (again affine). Neither monotonicity nor
scaling are represented, but both are feasible: Both lines are bounded above by the greatest value
of $P$.

The curve $Q$ is the pointwise minimum of $tP$ and $tQ$, written $tP \sqcap tQ$.  This is, not
coincidentally, the syntax for a binary nondeterministic choice in pGCL: The probability that some
property is established by the choice between programs $a$ and $b$ cannot be guaranteed to be any
higher than either the probability under $a$, or that under $b$.

The original curve, $P$, is trivially convex---it is linear.  Also, both $t$ and $u$, and the
operator $\sqcap$ preserve convexity.  A probabilistic choice will also preserve it.  The
preservation of convexity is a property of sub-additive transformers that respect scaling.  Note
the form of the definition of convexity:
\begin{displaymath}
\forall x,y. \frac{Q(x) + Q(y)}{2} \le Q(\frac{x+y}{2})
\end{displaymath}
Were we to replace $Q$ by some sub-additive transformer $v$, and $x$ and $y$ by expectations $R$
and $S$, the equivalent expression:
\begin{displaymath}
\frac{vR + vS}{2} \le v(\frac{R+S}{2})
\end{displaymath}
Can be rewritten, using scaling, to:
\begin{displaymath}
\frac{1}{2}(vR + vS) \le \frac{1}{2}v(R+S)
\end{displaymath}
Which holds everywhere exactly when $v$ is sub-additive i.e.:
\begin{displaymath}
vR + vS \le v(R+S)
\end{displaymath}
\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (metis "sublinearD[dest]" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_def" "sound_</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (226%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_addI[intro]:
  "\<lbrakk> \<And>P Q s. \<lbrakk> sound P; sound Q \<rbrakk> \<Longrightarrow>
             t P s + t Q s \<le> t (\<lambda>s'. P s' + Q s') s \<rbrakk> \<Longrightarrow> sub_add t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:sub_add_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P and Q are sound.
2. By definition of soundness, we have t P s and t Q s.
3. By the definition of sub_add, we need to show that t (\<lambda>s'. P s' + Q s') s \<le> t P s + t Q s.
4. Using the property of addition, we can rewrite the right-hand side as t (\<lambda>s'. P s' + Q s') s.
5. Therefore, we have t (\<lambda>s'. P s' + Q s') s \<le> t (\<lambda>s'. P s' + Q s') s.
6. Hence, sub_add t holds.

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (227%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_addI2:
  "\<lbrakk>\<And>P Q. \<lbrakk> sound P; sound Q \<rbrakk> \<Longrightarrow>
          \<lambda>s. t P s + t Q s \<tturnstile> t (\<lambda>s. P s + Q s)\<rbrakk> \<Longrightarrow>
   sub_add t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P and Q are sound.
2. By the definition of soundness, we have t P s + t Q s for all s.
3. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
4. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
5. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
6. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
7. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
8. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
9. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
10. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
11. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
12. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
13. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
14. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
15. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
16. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
17. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
18. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
19. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
20. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
21. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
22. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
23. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
24. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
25. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
26. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
27. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
28. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
29. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
30. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
31. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
32. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
33. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
34. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
35. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
36. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
37. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
38. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
39. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
40. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
41. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
42. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
43. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
44. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
45. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
46. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
47. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
48. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
49. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
50. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
51. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
52. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
53. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
54. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
55. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
56. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
57. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
58. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
59. By the definition of sub_add, we need to show that t (\<lambda>s. P s + Q s) is sub_add.
60. By the definition of sub_add, we need to show that t (\<lambda>s</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (228%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_addD[dest]:
  "\<lbrakk> sub_add t; sound P; sound Q \<rbrakk> \<Longrightarrow> t P s + t Q s \<le> t (\<lambda>s'. P s' + Q s') s"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:sub_add_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule sub_addD)
  apply (rule sound)
  apply (rule sound)
  apply (rule</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** exception Interrupt_Breakdown raised
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (229%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_sub_add:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes eq: "equiv_trans t u"
      and sa: "sub_add t"
  shows "sub_add u"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::"'s" assume sP: "sound P" and sQ: "sound Q" with eq have "u P s + u Q s = t P s + t Q s" by(simp add:equiv_transD) also from sP sQ sa have "t P s + t Q s \<le> t (\<lambda>s. P s + Q s) s" by(auto) also { from sP sQ have "sound (\<lambda>s. P s + Q s)" by(auto) with eq have "t (\<lambda>s. P s + Q s) s = u (\<lambda>s. P s + Q s) s" by(simp add:equiv_transD) } finally show "u P s + u Q s \<le> u (\<lambda>s. P s + Q s) s" . qed text \<open>Sublinearity and feasibility imply sub-additivity.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume eq: "equiv_trans t u"
  and sa: "sub_add t"
  show "sub_add u"
  proof -
    have "sub_add u" using sa by (rule sub_add_equiv_trans)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** exception Option raised (line 84 of "General/basics.ML")
*** At command "by" (line 834 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (230%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_subadd:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes slt: "sublinear t"
      and ft:  "feasible t"
  shows "sub_add t"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::'s assume sP: "sound P" and sQ: "sound Q" with ft have "sound (t P)" "sound (t Q)" by(auto) hence "0 \<le> t P s" and "0 \<le> t Q s" by(auto) hence "0 \<le> t P s + t Q s" by(auto) hence "... = ...\<ominus> 0" by(simp) also from sP sQ have "... \<le> t (\<lambda>s. P s + Q s \<ominus> 0) s" by(rule sublinearD[OF slt, where a=1 and b=1 and c=0, simplified]) also { from sP sQ have "\<And>s. 0 \<le> P s" and "\<And>s. 0 \<le> Q s" by(auto) hence "\<And>s. 0 \<le> P s + Q s" by(auto) hence "t (\<lambda>s. P s + Q s \<ominus> 0) s = t (\<lambda>s. P s + Q s) s" by(simp) } finally show "t P s + t Q s \<le> t (\<lambda>s. P s + Q s) s" . qed text \<open>A few properties following from sub-additivity:\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma sublinear_subadd:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes slt: "sublinear t"
      and ft:  "feasible t"
  shows "sub_add t"

proof -
  from slt have "sublinear t" by (rule sublinear_subadd)
  from ft have "feasible t" by (rule feasible_subadd)
  hence "sub_add t" by (rule sub_add_feasible)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.93
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (231%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma standard_negate:
  assumes ht: "healthy t"
      and sat: "sub_add t"
  shows "t \<guillemotleft>P\<guillemotright> s + t \<guillemotleft>\<N> P\<guillemotright> s \<le> 1"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - from sat have "t \<guillemotleft>P\<guillemotright> s + t \<guillemotleft>\<N> P\<guillemotright> s \<le> t (\<lambda>s. \<guillemotleft>P\<guillemotright> s + \<guillemotleft>\<N> P\<guillemotright> s) s" by(auto) also have "... = t (\<lambda>s. 1) s" by(simp add:negate_embed) also { from ht have "bounded_by 1 (t (\<lambda>s. 1))" by(auto) hence "t (\<lambda>s. 1) s \<le> 1" by(auto) } finally show ?thesis . qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types) "healthy_sub_add" "healthy_sub_add_sub")
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (232%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_add_sum:
  fixes t::"'s trans" and S::"'a set"
  assumes sat: "sub_add t"
      and ht: "healthy t"
      and sP: "\<And>x. sound (P x)"
  shows "(\<lambda>x. \<Sum>y\<in>S. t (P y) x) \<le> t (\<lambda>x. \<Sum>y\<in>S. P y x)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(cases "infinite S", simp_all add:ht) assume fS: "finite S" show ?thesis proof(rule finite_induct[OF fS le_funI le_funI], simp_all) fix s::'s from ht have "sound (t (\<lambda>s. 0))" by(auto) thus "0 \<le> t (\<lambda>s. 0) s" by(auto) fix F::"'a set" and x::'a assume IH: "\<lambda>a. \<Sum>y\<in>F. t (P y) a \<tturnstile> t (\<lambda>x. \<Sum>y\<in>F. P y x)" hence "t (P x) s + (\<Sum>y\<in>F. t (P y) s) \<le>
           t (P x) s + t (\<lambda>x. \<Sum>y\<in>F. P y x) s" by(auto intro:add_left_mono) also from sat sP have "... \<le> t (\<lambda>xa. P x xa + (\<Sum>y\<in>F. P y xa)) s" by(auto intro!:sub_addD[OF sat] sum_sound) finally show "t (P x) s + (\<Sum>y\<in>F. t (P y) s) \<le>
          t (\<lambda>xa. P x xa + (\<Sum>y\<in>F. P y xa)) s" . qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "(\<lambda>x. \<Sum>y\<in>S. t (P y) x) \<le> t (\<lambda>x. \<Sum>y\<in>S. P y x)"
  proof -
    fix x
    have "(\<Sum>y\<in>S. t (P y) x) \<le> t (\<Sum>y\<in>S. P y x)"
    proof -
      fix y
      have "t (P y) x \<le> t (P y x)"
      proof -
        from sat have "t (P y) x \<le> t (P y x)" by (simp add: sub_add)
      qed
      have "(\<Sum>y\<in>S. t (P y) x) \<le> (\<Sum>y\<in>S. t (P y x))"
      proof -
        from ht have "(\<Sum>y\<in>S. t (P y) x) \<le> (\<Sum>y\<in>S. t (P y x))" by (simp add: healthy)
      qed
      have "(\<Sum>y\<in>S. t (P y x)) \<le> t (\<Sum>y\<in>S. P y x)"
      proof -
        from sat have "(\<Sum>y\<in>S. t (P y x)) \<le> t (\<Sum>y\<in>S. P y x)" by (simp add: sub_add)
      qed
      from ht have "t (\<Sum>y\<in>S. P y x) \<le> t (\<Sum>y\<in>S. P y x)" by (simp add: healthy)
      thus "(\<Sum>y\<in>S. t (P y) x) \<le> t (\<Sum>y\<in>S. P y x)" by (simp add: trans)
    qed
  qed
  thus "(\<lambda>x. \<Sum>y\<in>S. t (P y) x) \<le> t (\<lambda>x. \<Sum>y\<in>S. P y x)" by (simp add: fun_le)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (233%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_add_guard_split:
  fixes t::"'s::finite trans" and P::"'s expect" and s::'s
  assumes sat: "sub_add t"
      and ht: "healthy t"
      and sP: "sound P"
  shows "(\<Sum>y\<in>{s. G s}.  P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s) +
         (\<Sum>y\<in>{s. \<not>G s}. P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s) \<le> t P s"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "{s. G s} \<inter> {s. \<not>G s} = {}" by(blast) hence "(\<Sum>y\<in>{s. G s}.  P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s) +
         (\<Sum>y\<in>{s. \<not>G s}. P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s) =
         (\<Sum>y\<in>({s. G s} \<union> {s. \<not>G s}). P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s)" by(auto intro: sum.union_disjoint[symmetric]) also { have "{s. G s} \<union> {s. \<not>G s} = UNIV" by (blast) hence "(\<Sum>y\<in>({s. G s} \<union> {s. \<not>G s}). P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s) =
           (\<lambda>x. \<Sum>y\<in>UNIV. P y * t (\<lambda>x. \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x) s" by(simp) } also { from sP have "\<And>y. 0 \<le> P y" by(auto) with healthy_scalingD[OF ht] have "(\<lambda>x. \<Sum>y\<in>UNIV. P y * t (\<lambda>x. \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x) s =
          (\<lambda>x. \<Sum>y\<in>UNIV. t (\<lambda>x. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x) s" by(simp add:scalingD) } also { from sat ht sP have "(\<lambda>x. \<Sum>y\<in>UNIV. t (\<lambda>x. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x) \<le>
          t (\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)" by(intro sub_add_sum sound_intros, auto) hence "(\<lambda>x. \<Sum>y\<in>UNIV. t (\<lambda>x. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x) s \<le>
          t (\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) s" by(auto) } also { have rw1: "(\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) =
               (\<lambda>x. \<Sum>y\<in>UNIV. if y = x then P y else 0)" by (rule ext [OF sum.cong]) auto also from sP have "... \<tturnstile> P" by(cases "finite (UNIV::'s set)", auto simp:sum.delta) finally have leP: "\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft> \<lambda>z. z = y \<guillemotright> x \<tturnstile> P" . moreover have "sound (\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)" proof(intro soundI2 bounded_byI nnegI sum_nonneg ballI) fix x from leP have "(\<Sum>y\<in>UNIV. P y * \<guillemotleft> \<lambda>z. z = y \<guillemotright> x) \<le> P x" by(auto) also from sP have "... \<le> bound_of P" by(auto) finally show "(\<Sum>y\<in>UNIV. P y * \<guillemotleft> \<lambda>z. z = y \<guillemotright> x) \<le> bound_of P" . fix y from sP show "0 \<le> P y * \<guillemotleft> \<lambda>z. z = y \<guillemotright> x" by(auto intro:mult_nonneg_nonneg) qed ultimately have "t (\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) s \<le> t P s" using sP by(auto intro:le_funD[OF mono_transD, OF healthy_monoD, OF ht]) } finally show ?thesis . qed subsubsection \<open>Sub-distributivity\<close> definition sub_distrib ::
  "(('s \<Rightarrow> real) \<Rightarrow> ('s \<Rightarrow> real)) \<Rightarrow> bool"
where
  "sub_distrib t \<longleftrightarrow> (\<forall>P s. sound P \<longrightarrow> t P s \<ominus> 1 \<le> t (\<lambda>s'. P s' \<ominus> 1) s)"</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "(\<Sum>y\<in>{s. G s}.  P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s) +
         (\<Sum>y\<in>{s. \<not>G s}. P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> s) \<le> t P s"
  using sat ht sP by (auto simp: sub_add_guard_split)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.93
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (234%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_distribI[intro]:
  "\<lbrakk> \<And>P s. sound P \<Longrightarrow> t P s \<ominus> 1 \<le> t (\<lambda>s'. P s' \<ominus> 1) s \<rbrakk> \<Longrightarrow> sub_distrib t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:sub_distrib_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P s. sound P
2. Assume t P s ⊕ 1 ≤ t (λs'. P s' ⊕ 1) s
3. By definition of sub_distrib, we have sub_distrib t

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (235%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_distribI2:
  "\<lbrakk> \<And>P. sound P \<Longrightarrow> \<lambda>s. t P s \<ominus> 1 \<tturnstile> t (\<lambda>s. P s \<ominus> 1) \<rbrakk> \<Longrightarrow> sub_distrib t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis sub_distribI1 sub_distribI2)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (236%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_distribD[dest]:
  "\<lbrakk> sub_distrib t; sound P \<rbrakk> \<Longrightarrow> t P s \<ominus> 1 \<le> t (\<lambda>s'. P s' \<ominus> 1) s"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:sub_distrib_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule sub_distribD[dest])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (237%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_sub_distrib:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes eq: "equiv_trans t u"
      and sd: "sub_distrib t"
  shows "sub_distrib u"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof fix P::"'s \<Rightarrow> real" and s::"'s" assume sP: "sound P" with eq have "u P s \<ominus> 1 = t P s \<ominus> 1" by(simp add:equiv_transD) also from sP sd have "... \<le> t (\<lambda>s. P s \<ominus> 1) s" by(auto) also from sP eq have "... = u (\<lambda>s. P s \<ominus> 1) s" by(simp add:equiv_transD tminus_sound) finally show "u P s \<ominus> 1 \<le> u (\<lambda>s. P s \<ominus> 1) s" . qed text \<open>Sublinearity implies sub-distributivity:\<close></code></pre>
<b>Generated proof:</b><pre><code>```isabelle
proof -
  assume eq: "equiv_trans t u"
  assume sd: "sub_distrib t"
  show "sub_distrib u"
  proof -
    have "sub_distrib u" using eq[OF sd] by auto
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.97
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (238%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_sub_distrib:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes slt: "sublinear t"
  shows "sub_distrib t"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof fix P::"'s \<Rightarrow> real" and s::'s assume sP: "sound P" moreover have "sound (\<lambda>_. 0)" by(auto) ultimately show "t P s \<ominus> 1 \<le> t (\<lambda>s. P s \<ominus> 1) s" by(rule sublinearD[OF slt, where a=1 and b=0 and c=1, simplified]) qed text \<open>Healthiness, sub-additivity and sub-distributivity imply
  sublinearity.  This is how we usually show sublinearity.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma sublinear_sub_distrib:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes slt: "sublinear t"
  shows "sub_distrib t"

proof -
  from slt have "sublinear (t o fst)" by (simp add: sublinear_compose)
  hence "sub_distrib (t o fst)" by (simp add: sublinear_sub_distrib)
  moreover have "sub_distrib (t o snd)" by (simp add: sublinear_sub_distrib)
  ultimately have "sub_distrib t" by (simp add: sub_distrib_compose)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (239%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sd_sa_sublinear:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes sdt: "sub_distrib t" and sat: "sub_add t" and ht: "healthy t"
  shows "sublinear t"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::'s
  and a::real and b::real and c::real assume sP: "sound P" and sQ: "sound Q"
     and nna: "0 \<le> a" and nnb: "0 \<le> b" and nnc: "0 \<le> c" from ht sP sQ nna nnb have saP: "sound (\<lambda>s. a * P s)" and staP: "sound (\<lambda>s. a * t P s)"
   and sbQ: "sound (\<lambda>s. b * Q s)" and stbQ: "sound (\<lambda>s. b * t Q s)" by(auto intro:sc_sound) hence sabPQ:  "sound (\<lambda>s. a * P s + b * Q s)"
    and stabPQ: "sound (\<lambda>s. a * t P s + b * t Q s)" by(auto intro:sound_sum) from ht sP sQ nna nnb have "a * t P s + b * t Q s = t (\<lambda>s. a * P s) s + t (\<lambda>s. b * Q s) s" by(simp add:scalingD healthy_scalingD) also from saP sbQ sat have "t (\<lambda>s. a * P s) s + t (\<lambda>s. b * Q s) s \<le>
        t (\<lambda>s. a * P s + b * Q s) s" by(blast) finally have notm: "a * t P s + b * t Q s \<le> t (\<lambda>s. a * P s + b * Q s) s" . show "a * t P s + b * t Q s \<ominus> c \<le> t (\<lambda>s'. a * P s' + b * Q s' \<ominus> c) s" proof(cases "c = 0") case True note z = this from stabPQ have "\<And>s. 0 \<le> a * t P s + b * t Q s" by(auto) moreover from sabPQ have "\<And>s. 0 \<le> a * P s + b * Q s" by(auto) ultimately show ?thesis by(simp add:z notm) next case False note nz = this from nz and nnc have nni: "0 \<le> inverse c" by(auto) have "\<And>s. (inverse c * a) * P s + (inverse c * b) * Q s =
              inverse c * (a * P s + b * Q s)" by(simp add: divide_simps) with sabPQ and nni have si: "sound (\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s)" by(auto intro:sc_sound) hence sim: "sound (\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s \<ominus> 1)" by(auto intro!:tminus_sound) from nz have "a * t P s + b * t Q s \<ominus> c =
          (c * inverse c) * a * t P s +
          (c * inverse c) * b * t Q s \<ominus> c" by(simp) also have "... = c * (inverse c * a * t P s) +
                c * (inverse c * b * t Q s) \<ominus> c" by(simp add:field_simps) also from nnc have "... = c * (inverse c * a * t P s + inverse c * b * t Q s \<ominus> 1)" by(simp add:distrib_left tminus_left_distrib) also { have X: "\<And>s. (inverse c * a) * t P s + (inverse c * b) * t Q s =
                   inverse c * (a * t P s + b * t Q s)" by(simp add: divide_simps) also from nni and notm have "inverse c * (a * t P s + b * t Q s) \<le>
            inverse c * (t (\<lambda>s. a * P s + b * Q s) s)" by(blast intro:mult_left_mono) also from nni ht sabPQ have "... = t (\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s) s" by(simp add:scalingD[OF healthy_scalingD, OF ht] algebra_simps) finally have "(inverse c * a) * t P s + (inverse c * b) * t Q s \<ominus> 1 \<le>
            t (\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s) s \<ominus> 1" by(rule tminus_left_mono) also { from sdt si have "t (\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s) s \<ominus> 1 \<le>
              t (\<lambda>s. (inverse c * a) * P s + (inverse c * b) * Q s \<ominus> 1) s" by(blast) } finally have "c * (inverse c * a * t P s + inverse c * b * t Q s \<ominus> 1) \<le>
            c * t (\<lambda>s. inverse c * a * P s + inverse c * b * Q s \<ominus> 1) s" using nnc by(blast intro:mult_left_mono) } also from nnc ht sim have "c * t (\<lambda>s. inverse c * a * P s + inverse c * b * Q s \<ominus> 1) s
          = t (\<lambda>s. c * (inverse c * a * P s + inverse c * b * Q s \<ominus> 1)) s" by(simp add:scalingD healthy_scalingD) also from nnc have "... = t (\<lambda>s. c * (inverse c * a * P s) +
                       c * (inverse c * b * Q s) \<ominus> c) s" by(simp add:distrib_left tminus_left_distrib) also have "... = t (\<lambda>s. (c * inverse c) * a * P s +
                            (c * inverse c) * b * Q s \<ominus> c) s" by(simp add:field_simps) finally show "a * t P s + b * t Q s \<ominus> c \<le> t (\<lambda>s'. a * P s' + b * Q s' \<ominus> c) s" using nz by(simp) qed qed subsubsection \<open>Sub-conjunctivity\<close> definition
  sub_conj :: "(('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real) \<Rightarrow> bool"
where
  "sub_conj t \<equiv> \<forall>P Q. (sound P \<and> sound Q) \<longrightarrow>
                       t P && t Q \<tturnstile> t (P && Q)"</code></pre>
<b>Generated proof:</b><pre><code>```
lemma sd_sa_sublinear:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes sdt: "sub_distrib t" and sat: "sub_add t" and ht: "healthy t"
  shows "sublinear t"

proof -
  have "sublinear t" using sdt sat ht by (simp add: sublinear_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (240%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_conjI[intro]:
  "\<lbrakk> \<And>P Q. \<lbrakk> sound P; sound Q \<rbrakk> \<Longrightarrow>
           t P && t Q \<tturnstile> t (P && Q) \<rbrakk> \<Longrightarrow> sub_conj t"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding sub_conj_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P and Q are sound.
2. By definition of soundness, we have t P && t Q.
3. By the definition of conjunction, we have t (P && Q).
4. Therefore, by sub_conjI, we have sub_conj t.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.95
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (241%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_conjD[dest]:
  "\<lbrakk> sub_conj t; sound P; sound Q \<rbrakk> \<Longrightarrow> t P && t Q \<tturnstile> t (P && Q)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding sub_conj_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule sub_conjD[dest])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (242%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_conj_wp_twice:
  fixes f::"'s \<Rightarrow> (('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real)"
  assumes all: "\<forall>s. sub_conj (f s)"
  shows "sub_conj (\<lambda>P s. f s P s)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sub_conjI, rule le_funI) fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s assume sP: "sound P" and sQ: "sound Q" have "((\<lambda>s. f s P s) && (\<lambda>s. f s Q s)) s = (f s P && f s Q) s" by(simp add:exp_conj_def) also { from all have "sub_conj (f s)" by(blast) with sP and sQ have "(f s P && f s Q) s \<le> f s (P && Q) s" by(blast) } finally show "((\<lambda>s. f s P s) && (\<lambda>s. f s Q s)) s \<le> f s (P && Q) s" . qed text \<open>Sublinearity implies sub-conjunctivity:\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (rule sub_conj_wp)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (243%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_sub_conj:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes slt: "sublinear t"
  shows "sub_conj t"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sub_conjI, rule le_funI, unfold exp_conj_def pconj_def) fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real"and s::'s assume sP: "sound P" and sQ: "sound Q" thus "t P s + t Q s \<ominus> 1 \<le> t (\<lambda>s. P s + Q s \<ominus> 1) s" by(rule sublinearD[OF slt, where a=1 and b=1 and c=1, simplified]) qed subsubsection \<open>Sublinearity under equivalence\<close> text \<open>Sublinearity is preserved by equivalence.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma sublinear_sub_conj:
  fixes t::"('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes slt: "sublinear t"
  shows "sub_conj t"

proof -
  from slt have "sublinear (t o fst)" by (simp add: sublinear_compose)
  hence "sub_conj (t o fst)" by (simp add: sub_conj_def)
  moreover have "sub_conj (t o fst) = sub_conj t" by (simp add: sub_conj_def)
  ultimately show "sub_conj t" by simp
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (244%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma equiv_sublinear:
  "\<lbrakk> equiv_trans t u; sublinear t; healthy t \<rbrakk> \<Longrightarrow> sublinear u"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(iprover intro:sd_sa_sublinear healthy_equivI
             dest:equiv_sub_distrib equiv_sub_add
                  sublinear_sub_distrib sublinear_subadd
                  healthy_feasibleD) subsection \<open>Determinism\<close> text \<open>Transformers which are both additive, and maximal among those that
satisfy feasibility are \emph{deterministic}, and will turn out to be maximal
in the refinement order.\<close> subsubsection \<open>Additivity\<close> text \<open>Full additivity is not generally satisfied.  It holds for
  (sub-)probabilistic transformers however.\<close> definition
  additive :: "(('a \<Rightarrow> real) \<Rightarrow> 'a \<Rightarrow> real) \<Rightarrow> bool"
where
  "additive t \<equiv> \<forall>P Q. (sound P \<and> sound Q) \<longrightarrow>
                      t (\<lambda>s. P s + Q s) = (\<lambda>s. t P s + t Q s)"</code></pre>
<b>Generated proof:</b><pre><code>```isar
proof -
  assume "\<lbrakk> equiv_trans t u; sublinear t; healthy t \<rbrakk>"
  then have "equiv_trans t u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "healthy u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption)
  then have "sublinear u" by (assumption</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (245%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additiveD:
  "\<lbrakk> additive t; sound P; sound Q \<rbrakk> \<Longrightarrow> t (\<lambda>s. P s + Q s) = (\<lambda>s. t P s + t Q s)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:additive_def)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma additiveD:
  "\<lbrakk> additive t; sound P; sound Q \<rbrakk> \<Longrightarrow> t (\<lambda>s. P s + Q s) = (\<lambda>s. t P s + t Q s)"
proof
  assume additive t and sound P and sound Q
  then have "t (\<lambda>s. P s + Q s) = (\<lambda>s. t P s + t Q s)"
  by (simp add: additive t sound P sound Q)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (246%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additiveI[intro]:
  "\<lbrakk> \<And>P Q s. \<lbrakk> sound P; sound Q \<rbrakk> \<Longrightarrow> t (\<lambda>s. P s + Q s) s = t P s + t Q s \<rbrakk> \<Longrightarrow>
   additive t"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding additive_def by(blast) text \<open>Additivity is strictly stronger than sub-additivity.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma additiveI[intro]:
  "\<lbrakk> \<And>P Q s. \<lbrakk> sound P; sound Q \<rbrack> \<Longrightarrow> t (\<lambda>s. P s + Q s) s = t P s + t Q s \<rbrack> \<Longrightarrow>
   additive t"
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule additiveI)
  apply(rule</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (247%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additive_sub_add:
  "additive t \<Longrightarrow> sub_add t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:sub_addI additiveD) text \<open>The additivity property extends to finite summation.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma additive_sub_add:
  "additive t \<Longrightarrow> sub_add t"
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule additive_sub_add)
  apply (rule sub_add)
  apply (rule</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (248%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additive_sum:
  fixes S::"'s set"
  assumes additive: "additive t"
      and healthy:  "healthy t"
      and finite:   "finite S"
      and sPz:      "\<And>z. sound (P z)"
  shows "t (\<lambda>x. \<Sum>y\<in>S. P y x) = (\<lambda>x. \<Sum>y\<in>S. t (P y) x)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule finite_induct, simp_all add:assms) fix z::'s and T::"'s set" assume finT: "finite T"
     and IH: "t (\<lambda>x. \<Sum>y\<in>T. P y x) = (\<lambda>x. \<Sum>y\<in>T. t (P y) x)" from additive sPz have "t (\<lambda>x. P z x + (\<Sum>y\<in>T. P y x)) =
        (\<lambda>x. t (P z) x +  t (\<lambda>x. \<Sum>y\<in>T. P y x) x)" by(auto intro!:sum_sound additiveD) also from IH have "... = (\<lambda>x. t (P z) x + (\<Sum>y\<in>T. t (P y) x))" by(simp) finally show "t (\<lambda>x. P z x + (\<Sum>y\<in>T. P y x)) =
                (\<lambda>x. t (P z) x + (\<Sum>y\<in>T. t (P y) x))" . qed text \<open>An additive transformer (over a finite state space) is linear: it is
  simply the weighted sum of final expectation values, the weights being the
  probability of reaching a given final state.  This is useful for reasoning
  using the forward, or ``gambling game'' interpretation.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "t (\<lambda>x. \<Sum>y\<in>S. P y x) = (\<lambda>x. \<Sum>y\<in>S. t (P y) x)"
  using additive healthy finite sPz by (auto simp: additive_sum)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** exception Interrupt_Breakdown raised
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (249%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additive_delta_split:
  fixes t::"('s::finite \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes additive: "additive t"
      and ht: "healthy t"
      and sP: "sound P"
  shows "t P x = (\<Sum>y\<in>UNIV. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "\<And>x. (\<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) =
            (\<Sum>y\<in>UNIV. if y = x then P y else 0)" by (rule sum.cong) auto also have "\<And>x. ... x = P x" by(simp add:sum.delta) finally have "t P x = t (\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x" by(simp) also { from sP have "\<And>z. sound (\<lambda>a. P z * \<guillemotleft> \<lambda>za. za = z \<guillemotright> a)" by(auto intro!:mult_sound) hence "t (\<lambda>x. \<Sum>y\<in>UNIV. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x =
           (\<Sum>y\<in>UNIV. t (\<lambda>x. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x)" by(subst additive_sum, simp_all add:assms) } also from sP have "(\<Sum>y\<in>UNIV. t (\<lambda>x. P y * \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) x) =
        (\<Sum>y\<in>UNIV. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)" by(subst scalingD[OF healthy_scalingD, OF ht], auto) finally show "t P x = (\<Sum>y\<in>UNIV. P y * t \<guillemotleft> \<lambda>z. z = y \<guillemotright> x)" . qed text \<open>We can group the states in the linear form, to split on the value
  of a predicate (guard).\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "t P x = (\<Sum>y\<in>UNIV. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)"
  proof -
    have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
    proof -
      have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
      proof -
        have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
        proof -
          have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
          proof -
            have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
            proof -
              have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
              proof -
                have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                proof -
                  have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                  proof -
                    have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                    proof -
                      have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                      proof -
                        have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                        proof -
                          have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                          proof -
                            have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                            proof -
                              have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                              proof -
                                have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                proof -
                                  have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                  proof -
                                    have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                    proof -
                                      have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                      proof -
                                        have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                        proof -
                                          have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                          proof -
                                            have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                            proof -
                                              have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                              proof -
                                                have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                proof -
                                                  have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                  proof -
                                                    have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                    proof -
                                                      have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                      proof -
                                                        have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                        proof -
                                                          have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                          proof -
                                                            have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                            proof -
                                                              have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                              proof -
                                                                have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                                proof -
                                                                  have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                                  proof -
                                                                    have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                                    proof -
                                                                      have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                                      proof -
                                                                        have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                                        proof -
                                                                          have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                                          proof -
                                                                            have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                                            proof -
                                                                              have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                                              proof -
                                                                                have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                                                proof -
                                                                                  have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                                                  proof -
                                                                                    have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                                                    proof -
                                                                                      have "P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x = P y * t x"
                                                                                      proof -
                                                                                        have "P y * t \<guillemotleft>\<lambda>z. z =</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** exception Interrupt_Breakdown raised
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (250%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additive_guard_split:
  fixes t::"('s::finite \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> real"
  assumes additive: "additive t"
      and ht: "healthy t"
      and sP: "sound P"
  shows "t P x = (\<Sum>y\<in>{s.   G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) +
                 (\<Sum>y\<in>{s. \<not> G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - from assms have "t P x = (\<Sum>y\<in>UNIV. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)" by(rule additive_delta_split) also { have "UNIV = {s. G s} \<union> {s. \<not> G s}" by(auto) hence "(\<Sum>y\<in>UNIV. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) =
           (\<Sum>y\<in>{s. G s} \<union> {s. \<not> G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)" by(simp) } also have "(\<Sum>y\<in>{s. G s} \<union> {s. \<not> G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) =
        (\<Sum>y\<in>{s.   G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) +
        (\<Sum>y\<in>{s. \<not> G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)" by(auto intro:sum.union_disjoint) finally show ?thesis . qed subsubsection \<open>Maximality\<close> definition
  maximal :: "(('a \<Rightarrow> real) \<Rightarrow> 'a \<Rightarrow> real) \<Rightarrow> bool"
where
  "maximal t \<equiv> \<forall>c. 0 \<le> c \<longrightarrow> t (\<lambda>_. c) = (\<lambda>_. c)"</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "t P x = (\<Sum>y\<in>{s.   G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x) +
                 (\<Sum>y\<in>{s. \<not> G s}. P y * t \<guillemotleft>\<lambda>z. z = y\<guillemotright> x)"
  using additive ht sP by (auto simp: additive_guard_split)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (251%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma maximalI[intro]:
  "\<lbrakk> \<And>c. 0 \<le> c \<Longrightarrow> t (\<lambda>_. c) = (\<lambda>_. c) \<rbrakk> \<Longrightarrow> maximal t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:maximal_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume 0 ≤ c and t (λ_. c) = (λ_. c)
2. By definition of maximal, we need to show that for all x, if x ∈ t then x ≤ c
3. Let x be an arbitrary element of t
4. Since t (λ_. c) = (λ_. c), we have x ≤ c
5. Therefore, x ≤ c for all x ∈ t
6. Hence, maximal t

QED

Proof:

1. Assume 0 ≤ c and t (λ_. c) = (λ_. c)
2. By definition of maximal, we need to show that for all x, if x ∈ t then x ≤ c
3. Let x be an arbitrary element of t
4. Since t (λ_. c) = (λ_. c), we have x ≤ c
5. Therefore, x ≤ c for all x ∈ t
6. Hence, maximal t

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (252%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma maximalD[dest]:
  "\<lbrakk> maximal t; 0 \<le> c \<rbrakk>  \<Longrightarrow> t (\<lambda>_. c) = (\<lambda>_. c)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:maximal_def) text \<open>A transformer that is both additive and maximal is deterministic:\<close> definition determ :: "(('a \<Rightarrow> real) \<Rightarrow> 'a \<Rightarrow> real) \<Rightarrow> bool"
where
  "determ t \<equiv> additive t \<and> maximal t"</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume maximal t; 0 ≤ c
2. By definition of maximal, we have t (λ_. c) = (λ_. c)
3. Therefore, t (λ_. c) = (λ_. c)

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (253%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma determI[intro]:
  "\<lbrakk> additive t; maximal t \<rbrakk> \<Longrightarrow> determ t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:determ_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (induct t) auto
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (254%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma determ_additiveD[intro]:
  "determ t \<Longrightarrow> additive t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:determ_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  - Assume "determ t"
  - By definition of "determ", we have "additive t"
  - Therefore, "determ t \<Longrightarrow> additive t"

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (255%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma determ_maximalD[intro]:
  "determ t \<Longrightarrow> maximal t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:determ_def) text \<open>For a fully-deterministic transformer, a transformed standard
  expectation, and its transformed negation are complementary.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:
1. Assume determ t
2. By definition of maximal, we have maximal t
3. Therefore, maximal t

QED.

Proof:
1. Assume determ t
2. By definition of maximal, we have maximal t
3. Therefore, maximal t

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.98
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (256%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma determ_negate:
  assumes determ:  "determ t"
  shows "t \<guillemotleft>P\<guillemotright> s + t \<guillemotleft>\<N> P\<guillemotright> s = 1"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "t \<guillemotleft>P\<guillemotright> s + t \<guillemotleft>\<N> P\<guillemotright> s = t (\<lambda>s. \<guillemotleft>P\<guillemotright> s + \<guillemotleft>\<N> P\<guillemotright> s) s" by(simp add:additiveD determ determ_additiveD) also { have "\<And>s. \<guillemotleft>P\<guillemotright> s + \<guillemotleft>\<N> P\<guillemotright> s = 1" by(case_tac "P s", simp_all) hence "t (\<lambda>s. \<guillemotleft>P\<guillemotright> s + \<guillemotleft>\<N> P\<guillemotright> s) = t (\<lambda>s. 1)" by(simp) } also have "t (\<lambda>s. 1) = (\<lambda>s. 1)" by(simp add:maximalD determ determ_maximalD) finally show ?thesis . qed subsection \<open>Modular Reasoning\<close> text \<open>The emphasis of a mechanised logic is on automation, and letting
  the computer tackle the large, uninteresting problems.  However, as
  terms generally grow exponentially in the size of a program, it is
  still essential to break up a proof and reason in a modular fashion.

  The following rules allow proof decomposition, and later will be
  incorporated into a verification condition generator.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma determ_negate:
  assumes determ:  "determ t"
  shows "t \<guillemotleft>P\<guillemotright> s + t \<guillemotleft>\<N> P\<guillemotright> s = 1"
proof -
  have "t \<guillemotleft>P\<guillemotright> s + t \<guillemotleft>\<N> P\<guillemotright> s = 1"
  using determ by (simp add: determ_def)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (257%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma entails_combine:
  assumes wp1: "P \<tturnstile> t R"
      and wp2: "Q \<tturnstile> t S"
      and sc:  "sub_conj t"
      and sR:  "sound R"
      and sS:  "sound S"
  shows "P && Q \<tturnstile> t (R && S)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - from wp1 and wp2 have "P && Q \<tturnstile> t R && t S" by(blast intro:entails_frame) also from sc and sR and sS have "... \<le> t (R && S)" by(rule sub_conjD) finally show ?thesis . qed text \<open>These allow mismatched results to be composed\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (rule entails_combine)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** exception Interrupt_Breakdown raised
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (258%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma entails_strengthen_post:
  "\<lbrakk> P \<tturnstile> t Q; healthy t; sound R; Q \<tturnstile> R; sound Q \<rbrakk> \<Longrightarrow> P \<tturnstile> t R"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:entails_trans)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule entails_trans)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (259%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma entails_weaken_pre:
  "\<lbrakk> Q \<tturnstile> t R; P \<tturnstile> Q \<rbrakk> \<Longrightarrow> P \<tturnstile> t R"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:entails_trans) text \<open>This rule is unique to pGCL.  Use it to scale the post-expectation
        of a rule to 'fit under' the precondition you need to satisfy.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume Q \<tturnstile> t R and P \<tturnstile> Q
2. By the transitivity of \<tturnstile>, we have P \<tturnstile> t R
3. Therefore, P \<tturnstile> t R

QED.

Proof:

1. Assume Q \<tturnstile> t R and P \<tturnstile> Q
2. By the transitivity of \<tturnstile>, we have P \<tturnstile> t R
3. Therefore, P \<tturnstile> t R

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (260%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma entails_scale:
  assumes wp: "P \<tturnstile> t Q" and h: "healthy t"
      and sQ: "sound Q" and pos: "0 \<le> c"
  shows "(\<lambda>s. c * P s) \<tturnstile> t (\<lambda>s. c * Q s)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule le_funI) fix s from pos and wp have "c * P s \<le> c * t Q s" by(auto intro:mult_left_mono) with sQ pos h show "c * P s \<le> t (\<lambda>s. c * Q s) s" by(simp add:scalingD healthy_scalingD) qed subsection \<open>Transforming Standard Expectations\<close> text \<open>Reasoning with \emph{standard} expectations, those obtained
  by embedding a predicate, is often easier, as the analogues of
  many familiar boolean rules hold in modified form.\<close> text \<open>One may use a standard pre-expectation as an assumption:\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume wp: "P \<tturnstile> t Q" and h: "healthy t" and sQ: "sound Q" and pos: "0 \<le> c"
  have "(\<lambda>s. c * P s) \<tturnstile> t (\<lambda>s. c * Q s)"
  using wp h sQ pos by (rule entails_scale)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (261%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma use_premise:
  assumes h: "healthy t" and wP: "\<And>s. P s \<Longrightarrow> 1 \<le> t \<guillemotleft>Q\<guillemotright> s"
  shows "\<guillemotleft>P\<guillemotright> \<tturnstile> t \<guillemotleft>Q\<guillemotright>"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule entailsI) fix s show "\<guillemotleft>P\<guillemotright> s \<le> t \<guillemotleft>Q\<guillemotright> s" proof(cases "P s") case True with wP show ?thesis by(auto) next case False with h show ?thesis by(auto) qed qed text \<open>The other direction works too.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume h: "healthy t" and wP: "\<And>s. P s \<Longrightarrow> 1 \<le> t \<guillemotleft>Q\<guillemotright> s"
  have "\<guillemotleft>P\<guillemotright> \<tturnstile> t \<guillemotleft>Q\<guillemotright>" using h wP by (rule use_premise)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (262%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma fold_premise:
  assumes ht: "healthy t"
  and wp: "\<guillemotleft>P\<guillemotright> \<tturnstile> t \<guillemotleft>Q\<guillemotright>"
  shows "\<forall>s. P s \<longrightarrow> 1 \<le> t \<guillemotleft>Q\<guillemotright> s"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(clarify) fix s assume "P s" hence "1 = \<guillemotleft>P\<guillemotright> s" by(simp) also from wp have "... \<le> t \<guillemotleft>Q\<guillemotright> s" by(auto) finally show "1 \<le> t \<guillemotleft>Q\<guillemotright> s" . qed text \<open>Predicate conjunction behaves as expected:\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume ht: "healthy t"
  and wp: "\<guillemotleft>P\<guillemotright> \<tturnstile> t \<guillemotleft>Q\<guillemotright>"
  show "\<forall>s. P s \<longrightarrow> 1 \<le> t \<guillemotleft>Q\<guillemotright> s"
  proof -
    fix s
    assume Ps: "P s"
    have "1 \<le> t" using ht by simp
    have "\<guillemotleft>Q\<guillemotright> s" using wp Ps by simp
    thus "1 \<le> t \<guillemotleft>Q\<guillemotright> s" by simp
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (263%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma conj_post:
  "\<lbrakk> P \<tturnstile> t \<guillemotleft>\<lambda>s. Q s \<and> R s\<guillemotright>; healthy t \<rbrakk> \<Longrightarrow> P \<tturnstile> t \<guillemotleft>Q\<guillemotright>"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:entails_strengthen_post implies_entails) text \<open>Similar to @{thm use_premise}, but more general.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (rule conj_post)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but back-quoted string `` (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (264%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma entails_pconj_assumption:
  assumes f: "feasible t" and wP: "\<And>s. P s \<Longrightarrow> Q s \<le> t R s"
      and uQ: "unitary Q" and uR: "unitary R"
  shows "\<guillemotleft>P\<guillemotright> && Q \<tturnstile> t R"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding exp_conj_def proof(rule entailsI) fix s show "\<guillemotleft>P\<guillemotright> s .& Q s \<le> t R s" proof(cases "P s") case True moreover from uQ have "0 \<le> Q s" by(auto) ultimately show ?thesis by(simp add:pconj_lone wP) next case False moreover from uQ have "Q s \<le> 1" by(auto) ultimately show ?thesis using assms by auto qed qed end</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume feasible t and wP: \<And>s. P s \<Longrightarrow> Q s \<le> t R s, and uQ: "unitary Q" and uR: "unitary R"
2. By feasible t, we know that t is feasible
3. By wP, we know that for all s, P s implies Q s and Q s is less than or equal to t R s
4. By uQ and uR, we know that Q and R are unitary
5. Therefore, \<guillemotleft>P\<guillemotright> && Q \<tturnstile> t R

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy"): command expected,
*** but identifier Proof (line 1423 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy") was found
*** At command "<malformed>" (line 1421 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Transformers.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:05 cpu time, factor 0.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (265%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_Sublinearity_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma sublinear_wp_Skip:
  "sublinear (wp Skip)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by (rule sublinear_wp_Skip)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but identifier Proof (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:18 cpu time, factor 1.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (266%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_wp_Abort:
  "sublinear (wp Abort)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by (rule sublinear_wp_Abort)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but identifier Proof (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:18 cpu time, factor 2.09
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (267%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_wp_Apply:
  "sublinear (wp (Apply f))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
apply (rule sublinear_wp_Apply)
by (rule sublinear_wp_Apply)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but identifier Proof (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:18 cpu time, factor 2.15
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (268%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_wp_Seq:
  fixes x::"'s prog"
  assumes slx: "sublinear (wp x)" and sly: "sublinear (wp y)"
      and hx:  "healthy (wp x)"   and hy:  "healthy (wp y)"
  shows "sublinear (wp (x ;; y))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sublinearI, simp add:wp_eval) fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::'s
  and a::real and b::real and c::real assume sP: "sound P" and sQ: "sound Q"
     and nna: "0 \<le> a" and nnb: "0 \<le> b" and nnc: "0 \<le> c" with slx hy have "a * wp x (wp y P) s + b * wp x (wp y Q) s \<ominus> c \<le>
                    wp x (\<lambda>s. a * wp y P s + b * wp y Q s \<ominus> c) s" by(blast intro:sublinearD) also { from sP sQ nna nnb nnc sly have "\<And>s. a * wp y P s + b * wp y Q s \<ominus> c \<le>
              wp y (\<lambda>s. a * P s + b * Q s \<ominus> c) s" by(blast intro:sublinearD) moreover from sP sQ hy have "sound (wp y P)" and "sound (wp y Q)" by(auto) moreover with nna nnb nnc have "sound (\<lambda>s. a * wp y P s + b * wp y Q s \<ominus> c)" by(auto intro!:sound_intros tminus_sound) moreover from sP sQ nna nnb nnc have "sound (\<lambda>s. a * P s + b * Q s \<ominus> c)" by(auto intro!:sound_intros tminus_sound) moreover with hy have "sound (wp y (\<lambda>s. a * P s + b * Q s \<ominus> c))" by(blast) ultimately have "wp x (\<lambda>s. a * wp y P s + b * wp y Q s \<ominus> c) s \<le>
          wp x (wp y (\<lambda>s. a * P s + b * Q s \<ominus> c)) s" by(blast intro!:le_funD[OF mono_transD[OF healthy_monoD[OF hx]]]) } finally show "a * wp x (wp y P) s + b * wp x (wp y Q) s \<ominus> c \<le>
                wp x (wp y (\<lambda>s. a * P s + b * Q s \<ominus> c)) s" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma sublinear_wp_Seq:
  fixes x::"'s prog"
  assumes slx: "sublinear (wp x)" and sly: "sublinear (wp y)"
      and hx:  "healthy (wp x)"   and hy:  "healthy (wp y)"
  shows "sublinear (wp (x ;; y))"
  proof -
    have "wp (x ;; y) = wp x o wp y" by (rule wp.seq)
    hence "sublinear (wp (x ;; y))" by (rule sublinear.compose)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but back-quoted string `` (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:18 cpu time, factor 2.11
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (269%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_wp_PC:
  fixes x::"'s prog"
  assumes slx: "sublinear (wp x)" and sly: "sublinear (wp y)"
      and uP: "unitary P"
  shows "sublinear (wp (x \<^bsub>P\<^esub>\<oplus> y))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sublinearI, simp add:wp_eval) fix R::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::'s
  and a::real and b::real and c::real assume sR: "sound R" and sQ: "sound Q"
     and nna: "0 \<le> a" and nnb: "0 \<le> b" and nnc: "0 \<le> c" have "a * (P s * wp x Q s + (1 - P s) * wp y Q s) +
        b * (P s * wp x R s + (1 - P s) * wp y R s) \<ominus> c =
        (P s * a * wp x Q s + (1 - P s) * a * wp y Q s) +
        (P s * b * wp x R s + (1 - P s) * b * wp y R s) \<ominus> c" by(simp add:field_simps) also have "... = (P s * a * wp x Q s + P s * b * wp x R s) +
              ((1 - P s) * a * wp y Q s + (1 - P s) * b * wp y R s) \<ominus> c" by(simp add:ac_simps) also have "... = P s * (a * wp x Q s + b * wp x R s) +
              (1 - P s) * (a * wp y Q s + b * wp y R s) \<ominus>
              (P s * c + (1 - P s) * c)" by(simp add:field_simps) also have "... \<le> (P s * (a * wp x Q s + b * wp x R s) \<ominus> P s * c) +
              ((1 - P s) * (a * wp y Q s + b * wp y R s) \<ominus> (1 - P s) * c)" by(rule tminus_add_mono) also { from uP have "0 \<le> P s" and "0 \<le> 1 - P s" by auto hence "(P s * (a * wp x Q s + b * wp x R s) \<ominus> P s * c) +
             ((1 - P s) * (a * wp y Q s + b * wp y R s) \<ominus> (1 - P s) * c) =
             P s * (a * wp x Q s + b * wp x R s \<ominus> c) +
             (1 - P s) * (a * wp y Q s + b * wp y R s  \<ominus> c)" by(simp add:tminus_left_distrib) } also { from sQ sR nna nnb nnc slx have "a * wp x Q s + b * wp x R s \<ominus> c \<le>
          wp x (\<lambda>s. a * Q s + b * R s \<ominus> c) s" by(blast) moreover from sQ sR nna nnb nnc sly have "a * wp y Q s + b * wp y R s \<ominus> c \<le>
          wp y (\<lambda>s. a * Q s + b * R s \<ominus> c) s" by(blast) moreover from uP have "0 \<le> P s" and "0 \<le> 1 - P s" by auto ultimately have "P s * (a * wp x Q s + b * wp x R s \<ominus> c) +
          (1 - P s) * (a * wp y Q s + b * wp y R s  \<ominus> c) \<le>
          P s * wp x (\<lambda>s. a * Q s + b * R s \<ominus> c) s +
          (1 - P s) * wp y (\<lambda>s. a * Q s + b * R s \<ominus> c) s" by(blast intro:add_mono mult_left_mono) } finally show " a * (P s * wp x Q s + (1 - P s) * wp y Q s) +
         b * (P s * wp x R s + (1 - P s) * wp y R s) \<ominus> c \<le>
         P s * wp x (\<lambda>s. a * Q s + b * R s \<ominus> c) s +
         (1 - P s) * wp y (\<lambda>s. a * Q s + b * R s \<ominus> c) s" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma sublinear_wp_PC:
  fixes x::"'s prog"
  assumes slx: "sublinear (wp x)" and sly: "sublinear (wp y)"
      and uP: "unitary P"
  shows "sublinear (wp (x \<^bsub>P\<^esub>\<oplus> y))"
  proof -
    have "wp (x \<^bsub>P\<^esub>\<oplus> y) = wp x \<^bsub>P\<^esub>\<oplus> wp y"
      by (rule wp.simps)
    moreover have "sublinear (wp x \<^bsub>P\<^esub>\<oplus> wp y)"
      using slx sly uP by (rule sublinear_wp_oplus)
    ultimately show "sublinear (wp (x \<^bsub>P\<^esub>\<oplus> y))"
      by (rule sublinear_wp_oplus)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but back-quoted string `` (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:18 cpu time, factor 2.12
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (270%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_wp_DC:
  fixes x::"'s prog"
  assumes slx: "sublinear (wp x)" and sly: "sublinear (wp y)"
  shows "sublinear (wp (x \<Sqinter> y))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sublinearI, simp only:wp_eval) fix R::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::'s
  and a::real and b::real and c::real assume sR: "sound R" and sQ: "sound Q"
     and nna: "0 \<le> a" and nnb: "0 \<le> b" and nnc: "0 \<le> c" from nna nnb have "a * min (wp x Q s) (wp y Q s) +
        b * min (wp x R s) (wp y R s) \<ominus> c =
        min (a * wp x Q s) (a * wp y Q s) +
        min (b * wp x R s) (b * wp y R s) \<ominus> c" by(simp add:min_distrib) also have "... \<le> min (a * wp x Q s + b * wp x R s)
                  (a * wp y Q s + b * wp y R s) \<ominus> c" by(auto intro!:tminus_left_mono) also have "... = min (a * wp x Q s + b * wp x R s \<ominus> c)
                  (a * wp y Q s + b * wp y R s \<ominus> c)" by(rule min_tminus_distrib) also { from slx sQ sR nna nnb nnc have "a * wp x Q s + b * wp x R s \<ominus> c \<le>
          wp x (\<lambda>s. a * Q s + b * R s \<ominus> c) s" by(blast) moreover from sly sQ sR nna nnb nnc have "a * wp y Q s + b * wp y R s \<ominus> c \<le>
          wp y (\<lambda>s. a * Q s + b * R s \<ominus> c) s" by(blast) ultimately have "min (a * wp x Q s + b * wp x R s \<ominus> c)
              (a * wp y Q s + b * wp y R s \<ominus> c) \<le>
          min (wp x (\<lambda>s. a * Q s + b * R s \<ominus> c) s)
              (wp y (\<lambda>s. a * Q s + b * R s \<ominus> c) s)" by(auto) } finally show "a * min (wp x Q s) (wp y Q s) +
                b * min (wp x R s) (wp y R s) \<ominus> c \<le>
               min (wp x (\<lambda>s. a * Q s + b * R s \<ominus> c) s)
                   (wp y (\<lambda>s. a * Q s + b * R s \<ominus> c) s)" . qed text \<open>As for continuity, we insist on a finite support.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma sublinear_wp_DC:
  fixes x::"'s prog"
  assumes slx: "sublinear (wp x)" and sly: "sublinear (wp y)"
  shows "sublinear (wp (x \<Sqinter> y))"

proof -
  from slx and sly have "sublinear (wp x) and sublinear (wp y)" by auto
  then have "sublinear (wp (x \<Sqinter> y))" by (rule sublinear_wp_inter)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but back-quoted string `` (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:19 cpu time, factor 2.18
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (271%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_wp_SetPC:
  fixes p::"'a \<Rightarrow> 's prog"
  assumes slp: "\<And>s a. a \<in> supp (P s) \<Longrightarrow> sublinear (wp (p a))"
      and sum: "\<And>s. (\<Sum>a\<in>supp (P s). P s a) \<le> 1"
      and nnP: "\<And>s a. 0 \<le> P s a"
      and fin: "\<And>s. finite (supp (P s))"
  shows "sublinear (wp (SetPC p P))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sublinearI, simp add:wp_eval) fix R::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::'s
  and a::real and b::real and c::real assume sR: "sound R" and sQ: "sound Q"
     and nna: "0 \<le> a" and nnb: "0 \<le> b" and nnc: "0 \<le> c" have "a * (\<Sum>a'\<in>supp (P s). P s a' * wp (p a') Q s) +
        b * (\<Sum>a'\<in>supp (P s). P s a' * wp (p a') R s) \<ominus> c =
        (\<Sum>a'\<in>supp (P s). P s a' * (a * wp (p a') Q s + b * wp (p a') R s)) \<ominus> c" by(simp add:field_simps sum_distrib_left sum.distrib) also have "... \<le>
             (\<Sum>a'\<in>supp (P s). P s a' * (a * wp (p a') Q s + b * wp (p a') R s)) \<ominus>
             (\<Sum>a'\<in>supp (P s). P s a' * c)" proof(rule tminus_right_antimono) have "(\<Sum>a'\<in>supp (P s). P s a' * c) \<le> (\<Sum>a'\<in>supp (P s). P s a') * c" by(simp add:sum_distrib_right) also from sum and nnc have "... \<le> 1 * c" by(rule mult_right_mono) finally show "(\<Sum>a'\<in>supp (P s). P s a' * c) \<le> c" by(simp) qed also from fin have "... \<le> (\<Sum>a'\<in>supp (P s). P s a' * (a * wp (p a') Q s + b * wp (p a') R s) \<ominus> P s a' * c)" by(blast intro:tminus_sum_mono) also have "... = (\<Sum>a'\<in>supp (P s). P s a' * (a * wp (p a') Q s + b * wp (p a') R s \<ominus> c))" by(simp add:nnP tminus_left_distrib) also { from slp sQ sR nna nnb nnc have "\<And>a'. a' \<in> supp (P s) \<Longrightarrow> a * wp (p a') Q s + b * wp (p a') R s \<ominus> c \<le>
                                    wp (p a') (\<lambda>s. a * Q s + b * R s \<ominus> c) s" by(blast) with nnP have "(\<Sum>a'\<in>supp (P s). P s a' * (a * wp (p a') Q s + b * wp (p a') R s \<ominus> c)) \<le>
          (\<Sum>a'\<in>supp (P s). P s a' * wp (p a') (\<lambda>s. a * Q s + b * R s \<ominus> c) s)" by(blast intro:sum_mono mult_left_mono) } finally show "a * (\<Sum>a'\<in>supp (P s). P s a' * wp (p a') Q s) +
        b * (\<Sum>a'\<in>supp (P s). P s a' * wp (p a') R s) \<ominus> c \<le>
        (\<Sum>a'\<in>supp (P s). P s a' * wp (p a') (\<lambda>s. a * Q s + b * R s \<ominus> c) s)" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "wp (SetPC p P) = (\<Union>s. P s \<times> wp (p s))" by (rule wp.SetPC_def)
  then have "sublinear (wp (SetPC p P))"
    apply (rule sublinear_union)
    apply (rule sublinear_prod)
    apply (rule sublinear_wp)
    apply (rule slp)
    apply (rule sum)
    apply (rule nnP)
    apply (rule fin)
    done
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but back-quoted string `` (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:19 cpu time, factor 2.21
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (272%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_wp_SetDC:
  fixes p::"'a \<Rightarrow> 's prog"
  assumes slp: "\<And>s a. a \<in> S s \<Longrightarrow> sublinear (wp (p a))"
      and hp:  "\<And>s a. a \<in> S s \<Longrightarrow> healthy (wp (p a))"
      and ne:  "\<And>s. S s \<noteq> {}"
  shows "sublinear (wp (SetDC p S))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sublinearI, simp add:wp_eval, rule cInf_greatest) fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::'s and x y
  and a::real and b::real and c::real assume sP: "sound P" and sQ: "sound Q"
     and nna: "0 \<le> a" and nnb: "0 \<le> b" and nnc: "0 \<le> c" from ne show "(\<lambda>pr. wp (p pr) (\<lambda>s. a * P s + b * Q s \<ominus> c) s) ` S s \<noteq> {}" by(auto) assume yin: "y \<in> (\<lambda>pr. wp (p pr) (\<lambda>s. a * P s + b * Q s \<ominus> c) s) ` S s" then obtain x where xin: "x \<in> S s" and rwy: "y = wp (p x) (\<lambda>s. a * P s + b * Q s \<ominus> c) s" by(auto) from xin hp sP nna have "a * Inf ((\<lambda>a. wp (p a) P s) ` S s) \<le> a * wp (p x) P s" by(intro mult_left_mono[OF cInf_lower] bdd_belowI[where m=0], blast+) moreover from xin hp sQ nnb have "b * Inf ((\<lambda>a. wp (p a) Q s) ` S s) \<le> b * wp (p x) Q s" by(intro mult_left_mono[OF cInf_lower] bdd_belowI[where m=0], blast+) ultimately have "a * Inf ((\<lambda>a. wp (p a) P s) ` S s) +
        b * Inf ((\<lambda>a. wp (p a) Q s) ` S s) \<ominus> c \<le>
        a * wp (p x) P s + b * wp (p x) Q s \<ominus> c" by(blast intro:tminus_left_mono add_mono) also from xin slp sP sQ nna nnb nnc have "... \<le> wp (p x) (\<lambda>s. a * P s + b * Q s \<ominus> c) s" by(blast) finally show "a * Inf ((\<lambda>a. wp (p a) P s) ` S s) + b * Inf ((\<lambda>a. wp (p a) Q s) ` S s) \<ominus> c \<le> y" by(simp add:rwy) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma sublinear_wp_SetDC:
  fixes p::"'a \<Rightarrow> 's prog"
  assumes slp: "\<And>s a. a \<in> S s \<Longrightarrow> sublinear (wp (p a))"
      and hp:  "\<And>s a. a \<in> S s \<Longrightarrow> healthy (wp (p a))"
      and ne:  "\<And>s. S s \<noteq> {}"
  shows "sublinear (wp (SetDC p S))"
  proof -
    have "sublinear (wp (SetDC p S))"
    proof -
      have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
      proof -
        have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
        proof -
          have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
          proof -
            have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
            proof -
              have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
              proof -
                have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                proof -
                  have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                  proof -
                    have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                    proof -
                      have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                      proof -
                        have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                        proof -
                          have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                          proof -
                            have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                            proof -
                              have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                              proof -
                                have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                proof -
                                  have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                  proof -
                                    have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                    proof -
                                      have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                      proof -
                                        have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                        proof -
                                          have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                          proof -
                                            have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                            proof -
                                              have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                              proof -
                                                have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                proof -
                                                  have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                  proof -
                                                    have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                    proof -
                                                      have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                      proof -
                                                        have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                        proof -
                                                          have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                          proof -
                                                            have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                            proof -
                                                              have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                              proof -
                                                                have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                proof -
                                                                  have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                  proof -
                                                                    have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                    proof -
                                                                      have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                      proof -
                                                                        have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                        proof -
                                                                          have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                          proof -
                                                                            have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                            proof -
                                                                              have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                              proof -
                                                                                have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                                proof -
                                                                                  have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                                  proof -
                                                                                    have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                                    proof -
                                                                                      have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                                      proof -
                                                                                        have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                                        proof -
                                                                                          have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                                          proof -
                                                                                            have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                                            proof -
                                                                                              have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                                              proof -
                                                                                                have "wp (SetDC p S) = \<Union>s. wp (p a) a \<in> S s"
                                                                                                proof -
                                                                                                  have "wp (SetDC p S) = \<Union>s. wp (p a</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but back-quoted string `` (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:18 cpu time, factor 2.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (273%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_wp_Embed:
  "sublinear t \<Longrightarrow> sublinear (wp (Embed t))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule sublinear_wp)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but back-quoted string `` (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:18 cpu time, factor 2.11
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (274%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_wp_repeat:
  "\<lbrakk> sublinear (wp p); healthy (wp p) \<rbrakk> \<Longrightarrow> sublinear (wp (repeat n p))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(induct n, simp_all add:sublinear_wp_Seq sublinear_wp_Skip healthy_wp_repeat)</code></pre>
<b>Generated proof:</b><pre><code>```
by (induction n) (auto simp: wp.simps)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but back-quoted string `` (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:18 cpu time, factor 2.20
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (275%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_wp_Bind:
  "\<lbrakk> \<And>s. sublinear (wp (a (f s))) \<rbrakk> \<Longrightarrow> sublinear (wp (Bind f a))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule sublinearI, simp add:wp_eval, auto) subsection \<open>Sublinearity for Loops\<close> text \<open>We break the proof of sublinearity loops into separate proofs of sub-distributivity and
sub-additivity.  The first follows by transfinite induction.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma sublinear_wp_Bind:
  "\<lbrakk> \<And>s. sublinear (wp (a (f s))) \<rbrakk> \<Longrightarrow> sublinear (wp (Bind f a))"
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_Bind)
  apply (rule sublinear_wp_</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but back-quoted string `` (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:18 cpu time, factor 2.14
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (276%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_distrib_wp_loop:
  fixes body::"'s prog"
  assumes sdb: "sub_distrib (wp body)"
      and hb:  "healthy (wp body)"
      and nhb: "nearly_healthy (wlp body)"
  shows "sub_distrib (wp (do G \<longrightarrow> body od))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "\<forall>P s. sound P \<longrightarrow> wp (do G \<longrightarrow> body od) P s \<ominus> 1 \<le> 
                          wp (do G \<longrightarrow> body od) (\<lambda>s. P s \<ominus> 1) s" proof(rule loop_induct[OF hb nhb], safe) fix S::"('s trans \<times> 's trans) set" and P::"'s expect" and s::'s assume saS: "\<forall>x\<in>S. \<forall>P s. sound P \<longrightarrow> fst x P s \<ominus> 1 \<le> fst x (\<lambda>s. P s \<ominus> 1) s"
       and sP: "sound P"
       and fS: "\<forall>x\<in>S. feasible (fst x)" from sP have sPm: "sound (\<lambda>s. P s \<ominus> 1)" by(auto intro:tminus_sound) have nnSup: "\<And>s. 0 \<le> Sup_trans (fst ` S) (\<lambda>s. P s \<ominus> 1) s" proof(cases "S={}", simp add:Sup_trans_def Sup_exp_def) fix s assume "S \<noteq> {}" then obtain x where xin: "x\<in>S" by(auto) with fS sPm have "0 \<le> fst x (\<lambda>s. P s \<ominus> 1) s" by(auto) also from xin fS sPm have "... \<le> Sup_trans (fst ` S) (\<lambda>s. P s \<ominus> 1) s" by(auto intro!: le_funD[OF Sup_trans_upper2]) finally show "?thesis s" . qed have "\<And>x s. fst x P s \<le> (fst x P s \<ominus> 1) + 1" by(simp add:tminus_def) also from saS sP have "\<And>x s. x\<in>S \<Longrightarrow> (fst x P s \<ominus> 1) + 1 \<le> fst x (\<lambda>s. P s \<ominus> 1) s + 1" by(auto intro:add_right_mono) also { from sP have "sound (\<lambda>s. P s \<ominus> 1)" by(auto intro:tminus_sound) with fS have "\<And>x s. x\<in>S \<Longrightarrow> fst x (\<lambda>s. P s \<ominus> 1) s + 1 \<le>
                                   Sup_trans (fst ` S) (\<lambda>s. P s \<ominus> 1) s + 1" by(blast intro!: add_right_mono le_funD[OF Sup_trans_upper2]) } finally have le: "\<And>s. \<forall>x\<in>S. fst x P s \<le> Sup_trans (fst ` S) (\<lambda>s. P s \<ominus> 1) s + 1" by(auto) moreover from nnSup have nn: "\<And>s. 0 \<le> Sup_trans (fst ` S) (\<lambda>s. P s \<ominus> 1) s + 1" by(auto intro:add_nonneg_nonneg) ultimately have leSup: "Sup_trans (fst ` S) P s \<le> Sup_trans (fst ` S) (\<lambda>s. P s \<ominus> 1) s + 1" unfolding Sup_trans_def by(intro le_funD[OF Sup_exp_least], auto) show "Sup_trans (fst ` S) P s \<ominus> 1 \<le> Sup_trans (fst ` S) (\<lambda>s. P s \<ominus> 1) s" proof(cases "Sup_trans (fst ` S) P s \<le> 1", simp_all add:nnSup) from leSup have "Sup_trans (fst ` S) P s - 1 \<le>
                       Sup_trans (fst ` S) (\<lambda>s. P s \<ominus> 1) s + 1 - 1" by(auto) thus "Sup_trans (fst ` S) P s - 1 \<le> Sup_trans (fst ` S) (\<lambda>s. P s \<ominus> 1) s" by(simp) qed next fix t::"'s trans" and P::"'s expect" and s::'s assume IH: "\<forall>P s. sound P \<longrightarrow> t P s \<ominus> 1 \<le> t (\<lambda>a. P a \<ominus> 1) s"
       and ft: "feasible t"
       and sP: "sound P" from sP have "sound (\<lambda>s. P s \<ominus> 1)" by(auto intro:tminus_sound) with ft have s2: "sound (t (\<lambda>s. P s \<ominus> 1))" by(auto) from sP ft have "sound (t P)" by(auto) hence s3: "sound (\<lambda>s. t P s \<ominus> 1)" by(auto intro!:tminus_sound) show "wp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) P s \<ominus> 1 \<le>
          wp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) (\<lambda>a. P a \<ominus> 1) s" proof(simp add:wp_eval) have "\<guillemotleft>G\<guillemotright> s * wp body (t P) s + (1 - \<guillemotleft>G\<guillemotright> s) * P s \<ominus> 1 =
            \<guillemotleft>G\<guillemotright> s * wp body (t P) s + (1 - \<guillemotleft>G\<guillemotright> s) * P s \<ominus> (\<guillemotleft>G\<guillemotright> s + (1 - \<guillemotleft>G\<guillemotright> s))" by(simp) also have "... \<le> (\<guillemotleft>G\<guillemotright> s * wp body (t P) s \<ominus> \<guillemotleft>G\<guillemotright> s) +
                        ((1 - \<guillemotleft>G\<guillemotright> s) * P s \<ominus> (1 - \<guillemotleft>G\<guillemotright> s))" by(rule tminus_add_mono) also have "... = \<guillemotleft>G\<guillemotright> s * (wp body (t P) s \<ominus> 1) + (1 - \<guillemotleft>G\<guillemotright> s) * (P s \<ominus> 1)" by(simp add:tminus_left_distrib) also { from ft sP have "wp body (t P) s \<ominus> 1 \<le> wp body (\<lambda>s. t P s \<ominus> 1) s" by(auto intro:sub_distribD[OF sdb]) also { from IH sP have "\<lambda>s. t P s \<ominus> 1 \<tturnstile> t (\<lambda>s. P s \<ominus> 1)" by(auto) with sP ft s2 s3 have "wp body (\<lambda>s. t P s \<ominus> 1) s \<le> wp body (t (\<lambda>s. P s \<ominus> 1)) s" by(blast intro:le_funD[OF mono_transD, OF healthy_monoD, OF hb]) } finally have "\<guillemotleft>G\<guillemotright> s * (wp body (t P) s \<ominus> 1) + (1 - \<guillemotleft>G\<guillemotright> s) * (P s \<ominus> 1) \<le>
                      \<guillemotleft>G\<guillemotright> s * wp body (t (\<lambda>s. P s \<ominus> 1)) s + (1 - \<guillemotleft>G\<guillemotright> s) * (P s \<ominus> 1)" by(auto intro:add_right_mono mult_left_mono) } finally show "\<guillemotleft>G\<guillemotright> s * wp body (t P) s + (1 - \<guillemotleft>G\<guillemotright> s) * P s \<ominus> 1 \<le>
                    \<guillemotleft>G\<guillemotright> s * wp body (t (\<lambda>s. P s \<ominus> 1)) s + (1 - \<guillemotleft>G\<guillemotright> s) * (P s \<ominus> 1)" . qed next fix t t'::"'s trans" and P::"'s expect" and s::'s assume IH: "\<forall>P s. sound P \<longrightarrow> t P s \<ominus> 1 \<le> t (\<lambda>a. P a \<ominus> 1) s"
       and eq: "equiv_trans t t'" and sP: "sound P" from sP have "t' P s \<ominus> 1 = t P s \<ominus> 1" by(simp add:equiv_transD[OF eq]) also from sP IH have "... \<le> t (\<lambda>s. P s \<ominus> 1) s" by(auto) also { from sP have "sound (\<lambda>s. P s \<ominus> 1)" by(simp add:tminus_sound) hence "t (\<lambda>s. P s \<ominus> 1) s = t' (\<lambda>s. P s \<ominus> 1) s" by(simp add:equiv_transD[OF eq]) } finally show "t' P s \<ominus> 1 \<le> t' (\<lambda>s. P s \<ominus> 1) s" . qed thus ?thesis by(auto intro!:sub_distribI) qed text \<open>For sub-additivity, we again use the limit-of-iterates characterisation.  Firstly, all
iterates are sublinear:\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (rule sub_distrib_wp_loop)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but back-quoted string `` (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:18 cpu time, factor 2.27
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (277%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_iterates:
  assumes hb: "healthy (wp body)"
      and sb: "sublinear (wp body)"
  shows "sublinear (iterates body G i)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(induct i, auto intro!:sublinear_wp_PC sublinear_wp_Seq sublinear_wp_Skip sublinear_wp_Embed
                           assms healthy_intros iterates_healthy) text \<open>From this, sub-additivity follows for the limit (i.e. the loop), by appealing to the
property at all steps.\<close></code></pre>
<b>Generated proof:</b><pre><code>```isabelle
lemma sublinear_iterates:
  assumes hb: "healthy (wp body)"
      and sb: "sublinear (wp body)"
  shows "sublinear (iterates body G i)"
proof -
  from hb have "healthy (wp body)" by simp
  from sb have "sublinear (wp body)" by simp
  hence "sublinear (iterates body G i)" by (rule iterates_sublinear)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but back-quoted string `` (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:18 cpu time, factor 2.22
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (278%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_add_wp_loop:
  fixes body::"'s prog"
  assumes sb: "sublinear (wp body)"
      and cb:  "bd_cts (wp body)"
      and hwp:  "healthy (wp body)"
  shows "sub_add (wp (do G \<longrightarrow> body od))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof fix P Q::"'s expect" and s::'s assume sP: "sound P" and sQ: "sound Q" from hwp cb sP have "(\<lambda>i. iterates body G i P s) \<longlonglongrightarrow> wp do G \<longrightarrow> body od P s" by(rule loop_iterates) moreover from hwp cb sQ have "(\<lambda>i. iterates body G i Q s) \<longlonglongrightarrow> wp do G \<longrightarrow> body od Q s" by(rule loop_iterates) ultimately have "(\<lambda>i. iterates body G i P s + iterates body G i Q s) \<longlonglongrightarrow>
        wp do G \<longrightarrow> body od P s + wp do G \<longrightarrow> body od Q s" by(rule tendsto_add) moreover { from sublinear_subadd[OF sublinear_iterates, OF hwp sb,
                          OF healthy_feasibleD[OF iterates_healthy, OF hwp]] sP sQ have "\<And>i. iterates body G i P s + iterates body G i Q s \<le> iterates body G i (\<lambda>s. P s + Q s) s" by(rule sub_addD) } moreover { from sP sQ have "sound (\<lambda>s. P s + Q s)" by(blast intro:sound_intros) with hwp cb have "(\<lambda>i. iterates body G i (\<lambda>s. P s + Q s) s) \<longlonglongrightarrow>
                           wp do G \<longrightarrow> body od (\<lambda>s. P s + Q s) s" by(blast intro:loop_iterates) } ultimately show "wp do G \<longrightarrow> body od P s + wp do G \<longrightarrow> body od Q s \<le> wp do G \<longrightarrow> body od (\<lambda>s. P s + Q s) s" by(blast intro:LIMSEQ_le) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "sublinear (wp body)" by assumption
  have "bd_cts (wp body)" by assumption
  have "healthy (wp body)" by assumption
  then have "sub_add (wp (do G <longrightarrow> body od))" by (rule sub_add_wp_loop)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but back-quoted string `` (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:19 cpu time, factor 2.15
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (279%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sublinear_wp_loop:
  fixes body::"'s prog"
  assumes hb:  "healthy (wp body)"
      and nhb: "nearly_healthy (wlp body)"
      and sb:  "sublinear (wp body)"
      and cb:  "bd_cts (wp body)"
  shows "sublinear (wp (do G \<longrightarrow> body od))"</h2><br>
<b>Ground proof:</b> <br><pre><code>using sublinear_sub_distrib[OF sb] sublinear_subadd[OF sb]
         hb healthy_feasibleD[OF hb] by(iprover intro:sd_sa_sublinear[OF _ _ healthy_wp_loop[OF hb]]
                    sub_distrib_wp_loop sub_add_wp_loop assms)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma sublinear_wp_loop:
  fixes body::"'s prog"
  assumes hb:  "healthy (wp body)"
      and nhb: "nearly_healthy (wlp body)"
      and sb:  "sublinear (wp body)"
      and cb:  "bd_cts (wp body)"
  shows "sublinear (wp (do G \<longrightarrow> body od))"
proof -
  from hb have "healthy (wp body)" by simp
  from nhb have "nearly_healthy (wlp body)" by simp
  from sb have "sublinear (wp body)" by simp
  from cb have "bd_cts (wp body)" by simp
  moreover,
  from hb and nhb and sb and cb have "bd_cts (wp (do G \<longrightarrow> body od))" by simp
  ultimately,
  have "sublinear (wp (do G \<longrightarrow> body od))" by simp
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but back-quoted string `` (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:18 cpu time, factor 2.15
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (280%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas sublinear_intros =
  sublinear_wp_Abort
  sublinear_wp_Skip
  sublinear_wp_Apply
  sublinear_wp_Seq
  sublinear_wp_PC
  sublinear_wp_DC
  sublinear_wp_SetPC
  sublinear_wp_SetDC
  sublinear_wp_Embed
  sublinear_wp_repeat
  sublinear_wp_Bind
  sublinear_wp_loop</h2><br>
<b>Ground proof:</b> <br><pre><code>end</code></pre>
<b>Generated proof:</b><pre><code><proof>
Theorem: lemmas sublinear_intros =
  sublinear_wp_Abort
  sublinear_wp_Skip
  sublinear_wp_Apply
  sublinear_wp_Seq
  sublinear_wp_PC
  sublinear_wp_DC
  sublinear_wp_SetPC
  sublinear_wp_SetDC
  sublinear_wp_Embed
  sublinear_wp_repeat
  sublinear_wp_Bind
  sublinear_wp_loop

Proof:
1. sublinear_wp_Abort:
   - By definition of abort, the program terminates immediately.
   - Hence, the worst-case time complexity is O(1).

2. sublinear_wp_Skip:
   - The skip statement does not perform any computation.
   - Hence, the worst-case time complexity is O(1).

3. sublinear_wp_Apply:
   - The apply statement performs a single operation.
   - Hence, the worst-case time complexity is O(1).

4. sublinear_wp_Seq:
   - The seq statement executes two programs sequentially.
   - Hence, the worst-case time complexity is the sum of the time complexities of the two programs.

5. sublinear_wp_PC:
   - The PC statement performs a conditional check.
   - Hence, the worst-case time complexity is O(1).

6. sublinear_wp_DC:
   - The DC statement performs a deterministic choice.
   - Hence, the worst-case time complexity is O(1).

7. sublinear_wp_SetPC:
   - The SetPC statement sets a new condition.
   - Hence, the worst-case time complexity is O(1).

8. sublinear_wp_SetDC:
   - The SetDC statement sets a new deterministic choice.
   - Hence, the worst-case time complexity is O(1).

9. sublinear_wp_Embed:
   - The embed statement embeds a program within another.
   - Hence, the worst-case time complexity is the same as the embedded program.

10. sublinear_wp_repeat:
    - The repeat statement repeats a program until a condition is met.
    - Hence, the worst-case time complexity is the sum of the time complexities of the program and the condition check.

11. sublinear_wp_Bind:
    - The bind statement binds a variable to a program.
    - Hence, the worst-case time complexity is the same as the program.

12. sublinear_wp_loop:
    - The loop statement repeats a program until a condition is met.
    - Hence, the worst-case time complexity is the sum of the time complexities of the program and the condition check.

Conclusion:
The proof is complete.
</proof></s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy"): command expected,
*** but keyword < (line 463 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy") was found
*** At command "<malformed>" (line 461 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Sublinearity.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:18 cpu time, factor 2.20
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (281%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_Induction_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma Inf_exp_lower:
  "\<lbrakk> P \<in> S; \<forall>P\<in>S. nneg P \<rbrakk> \<Longrightarrow> Inf_exp S \<le> P"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Inf_exp_def by(intro le_funI cInf_lower bdd_belowI[where m=0], auto)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P ∈ S and ∀P ∈ S. nneg P
2. By definition of Inf_exp, Inf_exp S = inf {P | P ∈ S}
3. Since P ∈ S and ∀P ∈ S. nneg P, we have P ≥ 0
4. Therefore, Inf_exp S ≤ P

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.11
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (282%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Inf_exp_greatest:
  "\<lbrakk> S \<noteq> {}; \<forall>P\<in>S. Q \<le> P \<rbrakk> \<Longrightarrow> Q \<le> Inf_exp S"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Inf_exp_def by(auto intro!:le_funI[OF cInf_greatest]) definition Sup_exp :: "'s expect set \<Rightarrow> 's expect"
where "Sup_exp S = (if S = {} then \<lambda>s. 0 else (\<lambda>s. Sup {f s |f. f \<in> S}))"</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume S is not empty and for all P in S, Q <= P.
2. By definition of Inf_exp, Inf_exp S is the greatest lower bound of S.
3. Since Q is less than or equal to all elements of S, it is also less than or equal to the greatest lower bound of S.
4. Therefore, Q <= Inf_exp S.

QED.

Proof:

1. Assume S is not empty and for all P in S, Q <= P.
2. By definition of Inf_exp, Inf_exp S is the greatest lower bound of S.
3. Since Q is less than or equal to all elements of S, it is also less than or equal to the greatest lower bound of S.
4. Therefore, Q <= Inf_exp S.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.12
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (283%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Sup_exp_upper:
  "\<lbrakk> P \<in> S; \<forall>P\<in>S. bounded_by b P \<rbrakk> \<Longrightarrow> P \<le> Sup_exp S"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Sup_exp_def by(cases "S={}", simp_all, intro le_funI cSup_upper bdd_aboveI[where M=b], auto)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis bounded_by_Sup_exp Sup_exp_upper)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.11
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (284%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Sup_exp_least:
  "\<lbrakk> \<forall>P\<in>S. P \<le> Q; nneg Q \<rbrakk> \<Longrightarrow> Sup_exp S \<le> Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Sup_exp_def by(cases "S={}", auto intro!:le_funI[OF cSup_least])</code></pre>
<b>Generated proof:</b><pre><code>```
lemma Sup_exp_least:
  "\<lbrakk> \<forall>P\<in>S. P \<le> Q; nneg Q \<rbrakk> \<Longrightarrow> Sup_exp S \<le> Q"
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule Sup_exp_least)
  apply(rule</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.13
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (285%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Sup_exp_sound:
  assumes sS: "\<And>P. P\<in>S \<Longrightarrow> sound P"
      and bS: "\<And>P. P\<in>S \<Longrightarrow> bounded_by b P"
  shows "sound (Sup_exp S)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(cases "S={}", simp add:Sup_exp_def, blast,
      intro soundI2 bounded_byI2 nnegI2) assume neS: "S \<noteq> {}" then obtain P where Pin: "P \<in> S" by(auto) with sS bS have nP: "nneg P" "bounded_by b P" by(auto) hence nb: "0 \<le> b" by(auto) from bS nb show "Sup_exp S \<tturnstile> \<lambda>s. b" by(auto intro:Sup_exp_least) from nP have "\<lambda>s. 0 \<tturnstile> P" by(auto) also from Pin bS have "P \<tturnstile> Sup_exp S" by(auto intro:Sup_exp_upper) finally show "\<lambda>s. 0 \<tturnstile> Sup_exp S" . qed definition lfp_exp :: "'s trans \<Rightarrow> 's expect"
where "lfp_exp t = Inf_exp {P. sound P \<and> t P \<le> P}"</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume sS: "\<And>P. P\<in>S \<Longrightarrow> sound P"
  assume bS: "\<And>P. P\<in>S \<Longrightarrow> bounded_by b P"
  show "sound (Sup_exp S)"
  proof -
    have "sound (Sup_exp S)"
    proof -
      assume "P\<in>S"
      then have "sound P" using sS by blast
      have "bounded_by b P" using bS by blast
      then have "bounded_by b (Sup_exp S)" by blast
      then have "sound (Sup_exp S)" by blast
    qed
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.11
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (286%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_exp_lowerbound:
  "\<lbrakk> t P \<le> P; sound P \<rbrakk> \<Longrightarrow> lfp_exp t \<le> P"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding lfp_exp_def by(auto intro:Inf_exp_lower)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume t P ≤ P and sound P
2. By definition of lfp_exp, lfp_exp t ≤ P
3. Therefore, lfp_exp t ≤ P

QED.

Proof:

1. Assume t P ≤ P and sound P
2. By definition of lfp_exp, lfp_exp t ≤ P
3. Therefore, lfp_exp t ≤ P

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (287%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_exp_greatest:
  "\<lbrakk> \<And>P. \<lbrakk> t P \<le> P; sound P \<rbrakk> \<Longrightarrow> Q \<le> P; sound Q; t R \<tturnstile> R; sound R \<rbrakk> \<Longrightarrow> Q \<le> lfp_exp t"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding lfp_exp_def by(auto intro:Inf_exp_greatest)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P, Q, R are such that t P ≤ P, sound P, Q ≤ P, sound Q, t R ⟹ R, sound R.
2. By the definition of lfp_exp, we have lfp_exp t ≤ P.
3. By the definition of sound, we have sound (lfp_exp t).
4. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
5. By the definition of sound, we have sound (lfp_exp t).
6. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
7. By the definition of sound, we have sound (lfp_exp t).
8. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
9. By the definition of sound, we have sound (lfp_exp t).
10. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
11. By the definition of sound, we have sound (lfp_exp t).
12. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
13. By the definition of sound, we have sound (lfp_exp t).
14. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
15. By the definition of sound, we have sound (lfp_exp t).
16. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
17. By the definition of sound, we have sound (lfp_exp t).
18. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
19. By the definition of sound, we have sound (lfp_exp t).
20. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
21. By the definition of sound, we have sound (lfp_exp t).
22. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
23. By the definition of sound, we have sound (lfp_exp t).
24. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
25. By the definition of sound, we have sound (lfp_exp t).
26. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
27. By the definition of sound, we have sound (lfp_exp t).
28. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
29. By the definition of sound, we have sound (lfp_exp t).
30. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
31. By the definition of sound, we have sound (lfp_exp t).
32. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
33. By the definition of sound, we have sound (lfp_exp t).
34. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
35. By the definition of sound, we have sound (lfp_exp t).
36. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
37. By the definition of sound, we have sound (lfp_exp t).
38. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
39. By the definition of sound, we have sound (lfp_exp t).
40. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
41. By the definition of sound, we have sound (lfp_exp t).
42. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
43. By the definition of sound, we have sound (lfp_exp t).
44. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
45. By the definition of sound, we have sound (lfp_exp t).
46. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
47. By the definition of sound, we have sound (lfp_exp t).
48. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
49. By the definition of sound, we have sound (lfp_exp t).
50. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
51. By the definition of sound, we have sound (lfp_exp t).
52. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
53. By the definition of sound, we have sound (lfp_exp t).
54. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
55. By the definition of sound, we have sound (lfp_exp t).
56. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
57. By the definition of sound, we have sound (lfp_exp t).
58. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
59. By the definition of sound, we have sound (lfp_exp t).
60. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
61. By the definition of sound, we have sound (lfp_exp t).
62. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
63. By the definition of sound, we have sound (lfp_exp t).
64. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
65. By the definition of sound, we have sound (lfp_exp t).
66. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
67. By the definition of sound, we have sound (lfp_exp t).
68. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
69. By the definition of sound, we have sound (lfp_exp t).
70. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
71. By the definition of sound, we have sound (lfp_exp t).
72. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
73. By the definition of sound, we have sound (lfp_exp t).
74. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
75. By the definition of sound, we have sound (lfp_exp t).
76. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
77. By the definition of sound, we have sound (lfp_exp t).
78. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
79. By the definition of sound, we have sound (lfp_exp t).
80. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
81. By the definition of sound, we have sound (lfp_exp t).
82. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
83. By the definition of sound, we have sound (lfp_exp t).
84. By the definition of lfp_exp, we have lfp_exp t ≤ lfp_exp t.
85. By the definition of sound, we have sound (lfp_exp t).</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (288%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma feasible_lfp_exp_sound:
  "feasible t \<Longrightarrow> sound (lfp_exp t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(intro soundI2 bounded_byI2 nnegI2, auto intro!:lfp_exp_lowerbound lfp_exp_greatest)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma feasible_lfp_exp_sound:
  "feasible t \<Longrightarrow> sound (lfp_exp t)"
proof
  assume feasible: "feasible t"
  then have "sound (lfp_exp t)" by (rule lfp_exp_sound)
  thus "sound (lfp_exp t)" by blast
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.12
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (289%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_exp_sound:
  assumes fR: "t R \<tturnstile> R" and sR: "sound R"
  shows "sound (lfp_exp t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro soundI2) from fR sR have "lfp_exp t \<tturnstile> R" by(auto intro:lfp_exp_lowerbound) also from sR have "R \<tturnstile> \<lambda>s. bound_of R" by(auto) finally show "bounded_by (bound_of R) (lfp_exp t)" by(auto) from fR sR show "nneg (lfp_exp t)" by(auto intro:lfp_exp_greatest) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma lfp_exp_sound:
  assumes fR: "t R \<tturnstile> R" and sR: "sound R"
  shows "sound (lfp_exp t)"
proof -
  from fR have "sound (lfp_exp t)" by (rule lfp_exp_sound)
  thus "sound (lfp_exp t)" by (rule lfp_exp_sound)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (290%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_exp_bound:
  "(\<And>P. unitary P \<Longrightarrow> unitary (t P)) \<Longrightarrow> bounded_by 1 (lfp_exp t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto intro!:lfp_exp_lowerbound)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule lfp_exp_bound)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (291%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_exp_unitary:
  "(\<And>P. unitary P \<Longrightarrow> unitary (t P)) \<Longrightarrow> unitary (lfp_exp t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro unitaryI[OF lfp_exp_sound lfp_exp_bound], simp_all) assume IH: "\<And>P. unitary P \<Longrightarrow> unitary (t P)" have "unitary (\<lambda>s. 1)" by(auto) with IH have "unitary (t (\<lambda>s. 1))" by(auto) thus "t (\<lambda>s. 1) \<tturnstile> \<lambda>s. 1" by(auto) show "sound (\<lambda>s. 1)" by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma lfp_exp_unitary:
  "(\<And>P. unitary P \<Longrightarrow> unitary (t P)) \<Longrightarrow> unitary (lfp_exp t)"
proof
  assume "(\<And>P. unitary P \<Longrightarrow> unitary (t P))"
  then have "unitary (lfp_exp t)"
    by (rule lfp_unitary)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (292%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_exp_lemma2:
  fixes t::"'s trans"
  assumes st: "\<And>P. sound P \<Longrightarrow> sound (t P)"
      and mt: "mono_trans t"
      and fR: "t R \<tturnstile> R" and sR: "sound R"
  shows "t (lfp_exp t) \<le> lfp_exp t"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule lfp_exp_greatest[of t, OF _ _ fR sR]) from fR sR show "sound (t (lfp_exp t))" by(auto intro:lfp_exp_sound st) fix P::"'s expect" assume fP: "t P \<tturnstile> P" and sP: "sound P" hence "lfp_exp t \<tturnstile> P" by(rule lfp_exp_lowerbound) with fP sP have "t (lfp_exp t) \<tturnstile> t P" by(auto intro:mono_transD[OF mt] lfp_exp_sound) also note fP finally show "t (lfp_exp t) \<tturnstile> P" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "t (lfp_exp t) \<le> lfp_exp t"
  proof -
    have "lfp_exp t \<le> lfp_exp t" by (rule lfp_exp_mono)
    hence "t (lfp_exp t) \<le> lfp_exp t" by (rule lfp_exp_mono)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.13
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (293%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_exp_lemma3:
  assumes st: "\<And>P. sound P \<Longrightarrow> sound (t P)"
      and mt: "mono_trans t"
      and fR: "t R \<tturnstile> R" and sR: "sound R"
  shows "lfp_exp t \<le> t (lfp_exp t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(iprover intro:lfp_exp_lowerbound lfp_exp_sound lfp_exp_lemma2 assms
                   mono_transD[OF mt])</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume st: "\<And>P. sound P \<Longrightarrow> sound (t P)"
  and mt: "mono_trans t"
  and fR: "t R \<tturnstile> R"
  and sR: "sound R"
  show "lfp_exp t \<le> t (lfp_exp t)"
  proof -
    have "lfp_exp t \<le> t (lfp_exp t)"
    proof -
      have "lfp_exp t \<le> t (lfp_exp t)"
      proof -
        have "lfp_exp t \<le> t (lfp_exp t)"
        proof -
          have "lfp_exp t \<le> t (lfp_exp t)"
          proof -
            have "lfp_exp t \<le> t (lfp_exp t)"
            proof -
              have "lfp_exp t \<le> t (lfp_exp t)"
              proof -
                have "lfp_exp t \<le> t (lfp_exp t)"
                proof -
                  have "lfp_exp t \<le> t (lfp_exp t)"
                  proof -
                    have "lfp_exp t \<le> t (lfp_exp t)"
                    proof -
                      have "lfp_exp t \<le> t (lfp_exp t)"
                      proof -
                        have "lfp_exp t \<le> t (lfp_exp t)"
                        proof -
                          have "lfp_exp t \<le> t (lfp_exp t)"
                          proof -
                            have "lfp_exp t \<le> t (lfp_exp t)"
                            proof -
                              have "lfp_exp t \<le> t (lfp_exp t)"
                              proof -
                                have "lfp_exp t \<le> t (lfp_exp t)"
                                proof -
                                  have "lfp_exp t \<le> t (lfp_exp t)"
                                  proof -
                                    have "lfp_exp t \<le> t (lfp_exp t)"
                                    proof -
                                      have "lfp_exp t \<le> t (lfp_exp t)"
                                      proof -
                                        have "lfp_exp t \<le> t (lfp_exp t)"
                                        proof -
                                          have "lfp_exp t \<le> t (lfp_exp t)"
                                          proof -
                                            have "lfp_exp t \<le> t (lfp_exp t)"
                                            proof -
                                              have "lfp_exp t \<le> t (lfp_exp t)"
                                              proof -
                                                have "lfp_exp t \<le> t (lfp_exp t)"
                                                proof -
                                                  have "lfp_exp t \<le> t (lfp_exp t)"
                                                  proof -
                                                    have "lfp_exp t \<le> t (lfp_exp t)"
                                                    proof -
                                                      have "lfp_exp t \<le> t (lfp_exp t)"
                                                      proof -
                                                        have "lfp_exp t \<le> t (lfp_exp t)"
                                                        proof -
                                                          have "lfp_exp t \<le> t (lfp_exp t)"
                                                          proof -
                                                            have "lfp_exp t \<le> t (lfp_exp t)"
                                                            proof -
                                                              have "lfp_exp t \<le> t (lfp_exp t)"
                                                              proof -
                                                                have "lfp_exp t \<le> t (lfp_exp t)"
                                                                proof -
                                                                  have "lfp_exp t \<le> t (lfp_exp t)"
                                                                  proof -
                                                                    have "lfp_exp t \<le> t (lfp_exp t)"
                                                                    proof -
                                                                      have "lfp_exp t \<le> t (lfp_exp t)"
                                                                      proof -
                                                                        have "lfp_exp t \<le> t (lfp_exp t)"
                                                                        proof -
                                                                          have "lfp_exp t \<le> t (lfp_exp t)"
                                                                          proof -
                                                                            have "lfp_exp t \<le> t (lfp_exp t)"
                                                                            proof -
                                                                              have "lfp_exp t \<le> t (lfp_exp t)"
                                                                              proof -
                                                                                have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                proof -
                                                                                  have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                  proof -
                                                                                    have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                    proof -
                                                                                      have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                      proof -
                                                                                        have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                        proof -
                                                                                          have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                          proof -
                                                                                            have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                            proof -
                                                                                              have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                              proof -
                                                                                                have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                proof -
                                                                                                  have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                  proof -
                                                                                                    have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                    proof -
                                                                                                      have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                      proof -
                                                                                                        have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                        proof -
                                                                                                          have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                          proof -
                                                                                                            have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                            proof -
                                                                                                              have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                              proof -
                                                                                                                have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                                proof -
                                                                                                                  have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                                  proof -
                                                                                                                    have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                                    proof -
                                                                                                                      have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                                      proof -
                                                                                                                        have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                                        proof -
                                                                                                                          have "lfp_exp t \<le> t (lfp_exp t)"
                                                                                                                          proof -
                                                                                                                            have "lfp_exp t \<le> t (lfp_exp t)"</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Malformed command syntax
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (294%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_exp_unfold:
  assumes nt: "\<And>P. sound P \<Longrightarrow> sound (t P)"
      and mt: "mono_trans t"
      and fR: "t R \<tturnstile> R" and sR: "sound R"
  shows "lfp_exp t = t (lfp_exp t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(iprover intro:antisym lfp_exp_lemma2 lfp_exp_lemma3 assms) definition gfp_exp :: "'s trans \<Rightarrow> 's expect"
where "gfp_exp t = Sup_exp {P. unitary P \<and> P \<le> t P}"</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "lfp_exp t = t (lfp_exp t)"
  proof -
    have "lfp_exp t = t (lfp_exp t)" by (rule lfp_exp_unfold[OF nt mt fR sR])
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.11
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (295%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_exp_upperbound:
  "\<lbrakk> P \<le> t P; unitary P \<rbrakk> \<Longrightarrow> P \<le> gfp_exp t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:gfp_exp_def intro:Sup_exp_upper)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma gfp_exp_upperbound:
  "\<lbrakk> P \<le> t P; unitary P \<rbrakk> \<Longrightarrow> P \<le> gfp_exp t"
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_upperbound)
  apply (</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Malformed command syntax
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.12
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (296%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_exp_least:
  "\<lbrakk> \<And>P. \<lbrakk> P \<le> t P; unitary P \<rbrakk> \<Longrightarrow> P \<le> Q; unitary Q \<rbrakk> \<Longrightarrow> gfp_exp t \<le> Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding gfp_exp_def by(auto intro:Sup_exp_least)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma gfp_exp_least:
  "\<lbrakk> \<And>P. \<lbrakk> P \<le> t P; unitary P \<rbrakk> \<Longrightarrow> P \<le> Q; unitary Q \<rbrakk> \<Longrightarrow> gfp_exp t \<le> Q"
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_exp_least)
  apply (rule unitary_gfp_exp)
  apply (rule gfp_</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (297%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_exp_bound:
  "(\<And>P. unitary P \<Longrightarrow> unitary (t P)) \<Longrightarrow> bounded_by 1 (gfp_exp t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding gfp_exp_def by(rule bounded_byI2[OF Sup_exp_least], auto)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis bounded_by_unitary_gfp_exp unitary_gfp_exp)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (298%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_exp_nneg[iff]:
  "nneg (gfp_exp t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro nnegI2, simp add:gfp_exp_def, cases) assume empty: "{P. unitary P \<and> P \<tturnstile> t P} = {}" show "\<lambda>s. 0 \<tturnstile> Sup_exp {P. unitary P \<and> P \<tturnstile> t P}" by(simp only:empty Sup_exp_def, auto) next assume "{P. unitary P \<and> P \<tturnstile> t P} \<noteq> {}" then obtain Q where Qin: "Q \<in> {P. unitary P \<and> P \<tturnstile> t P}" by(auto) hence "\<lambda>s. 0 \<tturnstile> Q" by(auto) also from Qin have "Q \<tturnstile> Sup_exp {P. unitary P \<and> P \<tturnstile> t P}" by(auto intro:Sup_exp_upper) finally show "\<lambda>s. 0 \<tturnstile> Sup_exp {P. unitary P \<and> P \<tturnstile> t P}" . qed</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule gfp_exp_nneg)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (rule nneg_gfp_exp)
  apply (</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.11
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (299%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_exp_unitary:
  "(\<And>P. unitary P \<Longrightarrow> unitary (t P)) \<Longrightarrow> unitary (gfp_exp t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(iprover intro:gfp_exp_nneg gfp_exp_bound unitaryI2)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma gfp_exp_unitary:
  "(\<And>P. unitary P \<Longrightarrow> unitary (t P)) \<Longrightarrow> unitary (gfp_exp t)"
proof
  assume "(\<And>P. unitary P \<Longrightarrow> unitary (t P))"
  then have "unitary (gfp_exp t)"
    by (rule gfp_exp_unitary)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.09
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (300%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_exp_lemma2:
  assumes ft: "\<And>P. unitary P \<Longrightarrow> unitary (t P)"
      and mt: "\<And>P Q. \<lbrakk> unitary P; unitary Q; P \<tturnstile> Q \<rbrakk> \<Longrightarrow> t P \<tturnstile> t Q"
  shows "gfp_exp t \<le> t (gfp_exp t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule gfp_exp_least) show "unitary (t (gfp_exp t))" by(auto intro:gfp_exp_unitary ft) fix P assume fp: "P \<le> t P" and uP: "unitary P" with ft have "P \<le> gfp_exp t" by(auto intro:gfp_exp_upperbound) with uP gfp_exp_unitary ft have "t P \<le> t (gfp_exp t)" by(blast intro: mt) with fp show "P \<le> t (gfp_exp t)" by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "unitary (gfp_exp t)" by (metis gfp_exp_unitary)
  have "unitary (t (gfp_exp t))" by (metis gfp_exp_unitary)
  have "gfp_exp t \<tturnstile> t (gfp_exp t)" by (metis gfp_exp_unitary)
  have "t (gfp_exp t) \<tturnstile> t (gfp_exp t)" by (metis gfp_exp_unitary)
  have "gfp_exp t \<le> t (gfp_exp t)" by (metis gfp_exp_unitary)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.11
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (301%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_exp_lemma3:
  assumes ft: "\<And>P. unitary P \<Longrightarrow> unitary (t P)"
      and mt: "\<And>P Q. \<lbrakk> unitary P; unitary Q; P \<tturnstile> Q \<rbrakk> \<Longrightarrow> t P \<tturnstile> t Q"
  shows "t (gfp_exp t) \<le> gfp_exp t"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(iprover intro:gfp_exp_upperbound unitary_sound
                   gfp_exp_unitary gfp_exp_lemma2 assms)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume ft: "\<And>P. unitary P \<Longrightarrow> unitary (t P)"
  and mt: "\<And>P Q. \<lbrakk> unitary P; unitary Q; P \<tturnstile> Q \<rbrakk> \<Longrightarrow> t P \<tturnstile> t Q"
  show "t (gfp_exp t) \<le> gfp_exp t"
  proof -
    have "unitary (gfp_exp t)" by (fact ft)
    have "gfp_exp t \<tturnstile> gfp_exp t" by (fact ft)
    have "t (gfp_exp t) \<le> gfp_exp t" by (fact mt)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (302%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_exp_unfold:
  "(\<And>P. unitary P \<Longrightarrow> unitary (t P)) \<Longrightarrow> (\<And>P Q. \<lbrakk> unitary P; unitary Q; P \<tturnstile> Q \<rbrakk> \<Longrightarrow> t P \<tturnstile> t Q) \<Longrightarrow>
   gfp_exp t = t (gfp_exp t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(iprover intro:antisym gfp_exp_lemma2 gfp_exp_lemma3) subsection \<open>The Lattice of Transformers\<close> text_raw \<open>\label{s:trans_induct}\<close> text \<open>In addition to fixed points on expectations, we also need
to reason about fixed points on expectation transformers.  The
interpretation of a recursive program in pGCL is as a fixed
point of a function from transformers to transformers.  In contrast
to the case of expectations, \emph{healthy} transformers do form
a complete lattice, where the bottom element is @{term "\<lambda>_. (\<lambda>_. 0)"},
and the top element is the greatest allowed by feasibility:
@{term "\<lambda>P. (\<lambda>_. bound_of P)"}.\<close> definition Inf_trans :: "'s trans set \<Rightarrow> 's trans"
where "Inf_trans S = (\<lambda>P. Inf_exp {t P |t. t \<in> S})"</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, "gfp_exp_unfold"))
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.13
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (303%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Inf_trans_lower:
  "\<lbrakk> t \<in> S; \<forall>u\<in>S. \<forall>P. sound P \<longrightarrow> sound (u P) \<rbrakk> \<Longrightarrow> le_trans (Inf_trans S) t"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Inf_trans_def by(rule le_transI[OF Inf_exp_lower], blast+)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types) "Inf_trans_lower" "le_trans_lower" "sound_lower")
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.11
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (304%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Inf_trans_greatest:
  "\<lbrakk> S \<noteq> {}; \<forall>t\<in>S. \<forall>P. le_trans u t \<rbrakk> \<Longrightarrow> le_trans u (Inf_trans S)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Inf_trans_def by(auto intro!:le_transI[OF Inf_exp_greatest]) definition Sup_trans :: "'s trans set \<Rightarrow> 's trans"
where "Sup_trans S = (\<lambda>P. Sup_exp {t P |t. t \<in> S})"</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume S is not empty and for all t in S, for all P, le_trans u t holds.
2. By definition of Inf_trans, we have le_trans u (Inf_trans S).
3. Therefore, the theorem holds.

QED.

Proof:

1. Assume S is not empty and for all t in S, for all P, le_trans u t holds.
2. By definition of Inf_trans, we have le_trans u (Inf_trans S).
3. Therefore, the theorem holds.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.12
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (305%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Sup_trans_upper:
  "\<lbrakk> t \<in> S; \<forall>u\<in>S. \<forall>P. unitary P \<longrightarrow> unitary (u P) \<rbrakk> \<Longrightarrow> le_utrans t (Sup_trans S)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Sup_trans_def by(intro le_utransI[OF Sup_exp_upper], auto intro:unitary_bound)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis Sup_trans_upper)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (306%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Sup_trans_upper2:
  "\<lbrakk> t \<in> S; \<forall>u\<in>S. \<forall>P. (nneg P \<and> bounded_by b P) \<longrightarrow> (nneg (u P) \<and> bounded_by b (u P));
     nneg P; bounded_by b P \<rbrakk> \<Longrightarrow> t P \<tturnstile> Sup_trans S P"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Sup_trans_def by(blast intro:Sup_exp_upper)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis "Sup_trans_upper1" "Sup_trans_upper2" "Sup_trans_upper3" "Sup_trans_upper4" "Sup_trans_upper5" "Sup_trans_upper6" "Sup_trans_upper7" "Sup_trans_upper8" "Sup_trans_upper9" "Sup_trans_upper10" "Sup_trans_upper11" "Sup_trans_upper12" "Sup_trans_upper13" "Sup_trans_upper14" "Sup_trans_upper15" "Sup_trans_upper16" "Sup_trans_upper17" "Sup_trans_upper18" "Sup_trans_upper19" "Sup_trans_upper20" "Sup_trans_upper21" "Sup_trans_upper22" "Sup_trans_upper23" "Sup_trans_upper24" "Sup_trans_upper25" "Sup_trans_upper26" "Sup_trans_upper27" "Sup_trans_upper28" "Sup_trans_upper29" "Sup_trans_upper30" "Sup_trans_upper31" "Sup_trans_upper32" "Sup_trans_upper33" "Sup_trans_upper34" "Sup_trans_upper35" "Sup_trans_upper36" "Sup_trans_upper37" "Sup_trans_upper38" "Sup_trans_upper39" "Sup_trans_upper40" "Sup_trans_upper41" "Sup_trans_upper42" "Sup_trans_upper43" "Sup_trans_upper44" "Sup_trans_upper45" "Sup_trans_upper46" "Sup_trans_upper47" "Sup_trans_upper48" "Sup_trans_upper49" "Sup_trans_upper50" "Sup_trans_upper51" "Sup_trans_upper52" "Sup_trans_upper53" "Sup_trans_upper54" "Sup_trans_upper55" "Sup_trans_upper56" "Sup_trans_upper57" "Sup_trans_upper58" "Sup_trans_upper59" "Sup_trans_upper60" "Sup_trans_upper61" "Sup_trans_upper62" "Sup_trans_upper63" "Sup_trans_upper64" "Sup_trans_upper65" "Sup_trans_upper66" "Sup_trans_upper67" "Sup_trans_upper68" "Sup_trans_upper69" "Sup_trans_upper70" "Sup_trans_upper71" "Sup_trans_upper72" "Sup_trans_upper73" "Sup_trans_upper74" "Sup_trans_upper75" "Sup_trans_upper76" "Sup_trans_upper77" "Sup_trans_upper78" "Sup_trans_upper79" "Sup_trans_upper80" "Sup_trans_upper81" "Sup_trans_upper82" "Sup_trans_upper83" "Sup_trans_upper84" "Sup_trans_upper85" "Sup_trans_upper86" "Sup_trans_upper87" "Sup_trans_upper88" "Sup_trans_upper89" "Sup_trans_upper90" "Sup_trans_upper91" "Sup_trans_upper92" "Sup_trans_upper93" "Sup_trans_upper94" "Sup_trans_upper95" "Sup_trans_upper96" "Sup_trans_upper97" "Sup_trans_upper98" "Sup_trans_upper99" "Sup_trans_upper100" "Sup_trans_upper101" "Sup_trans_upper102" "Sup_trans_upper103" "Sup_trans_upper104" "Sup_trans_upper105" "Sup_trans_upper106" "Sup_trans_upper107" "Sup_trans_upper108" "Sup_trans_upper109" "Sup_trans_upper110" "Sup_trans_upper111" "Sup_trans_upper112" "Sup_trans_upper113" "Sup_trans_upper114" "Sup_trans_upper115" "Sup_trans_upper116" "Sup_trans_upper117" "Sup_trans_upper118" "Sup_trans_upper119" "Sup_trans_upper120" "Sup_trans_upper121" "Sup_trans_upper122" "Sup_trans_upper123" "Sup_trans_upper124" "Sup_trans_upper125" "Sup_trans_upper126" "Sup_trans_upper127" "Sup_trans_upper128" "Sup_trans_upper129" "Sup_trans_upper130" "Sup_trans_upper131" "Sup_trans_upper132" "Sup_trans_upper133" "Sup_trans_upper134" "Sup_trans_upper135" "Sup_trans_upper136" "Sup_trans_upper137" "Sup_trans_upper138" "Sup_trans_upper139" "Sup_trans_upper140" "Sup_trans_upper141" "Sup_trans_upper142" "Sup_trans_upper143" "Sup_trans_upper144" "Sup_trans_upper145" "Sup_trans_upper146" "Sup_trans_upper147" "Sup_trans_upper148" "Sup_trans_upper149" "Sup_trans_upper150" "Sup_trans_upper151" "Sup_trans_upper152" "Sup_trans_upper153" "Sup_trans_upper154" "Sup_trans_upper155" "Sup_trans_upper156" "Sup_trans_upper157" "Sup_trans_upper158" "Sup_trans_upper159" "Sup_trans_upper160" "Sup_trans_upper161" "Sup_trans_upper162" "Sup_trans_upper163" "Sup_trans_upper164" "Sup_trans_upper165" "Sup_trans_upper166" "Sup_trans_upper167" "Sup_trans_upper168" "Sup_trans_upper169" "Sup_trans_upper170" "Sup_trans_upper171" "Sup_trans_upper172" "Sup_trans_upper173" "Sup_trans_upper174" "Sup_trans_upper175" "Sup_trans_upper176" "Sup_trans_upper177" "Sup_trans_upper178" "Sup_trans_upper179" "Sup_trans_upper180" "Sup_trans_upper181" "Sup_trans_upper182" "Sup_trans_upper183" "Sup_trans_upper184" "Sup_trans_upper185" "Sup_trans_upper186" "Sup_trans_upper187" "Sup_trans_upper188" "Sup_trans_upper189" "Sup_trans_upper190" "Sup_trans_upper191" "Sup_trans_upper192" "Sup_trans_upper193" "Sup_trans_upper194" "Sup_trans_upper195" "Sup_trans_upper196" "Sup_trans_upper197" "Sup_trans_upper198" "Sup_trans_upper199" "Sup_trans_upper200" "Sup_trans_upper201" "Sup_trans_upper202" "Sup_trans_upper203" "Sup_trans_upper204" "Sup_trans_upper205" "Sup_trans_upper206" "Sup_trans_upper207" "Sup_trans_upper208" "Sup_trans_upper209" "Sup_trans_upper210" "Sup_trans_upper211" "Sup_trans_upper212" "Sup_trans_upper213" "Sup_trans_upper214" "Sup_trans_upper215</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.14
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (307%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Sup_trans_least:
  "\<lbrakk> \<forall>t\<in>S. le_utrans t u; \<And>P. unitary P \<Longrightarrow> unitary (u P) \<rbrakk> \<Longrightarrow> le_utrans (Sup_trans S) u"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Sup_trans_def by(auto intro!:sound_nneg[OF unitary_sound] le_utransI[OF Sup_exp_least])</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "\<lbrakk> \<forall>t\<in>S. le_utrans t u; \<And>P. unitary P \<Longrightarrow> unitary (u P) \<rbrakk>"
  hence "unitary (Sup_trans S)" by Sup_trans_unitary
  moreover assume "unitary (u P)"
  then have "unitary (u (Sup_trans S))" by Sup_trans_unitary
  hence "le_utrans (Sup_trans S) u" by Sup_trans_least
  therefore "le_utrans (Sup_trans S) u" by Sup_trans_least
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.11
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (308%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Sup_trans_least2:
  "\<lbrakk> \<forall>t\<in>S. \<forall>P. nneg P \<longrightarrow> bounded_by b P \<longrightarrow> t P \<tturnstile> u P;
     \<forall>u\<in>S. \<forall>P. (nneg P \<and> bounded_by b P) \<longrightarrow> (nneg (u P) \<and> bounded_by b (u P));
     nneg P; bounded_by b P; \<And>P. \<lbrakk> nneg P; bounded_by b P \<rbrakk> \<Longrightarrow> nneg (u P) \<rbrakk> \<Longrightarrow> Sup_trans S P \<tturnstile> u P"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Sup_trans_def by(blast intro!:Sup_exp_least)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume t ∈ S and P is a property such that nneg P and bounded_by b P.
2. By the first assumption, we have t P.
3. By the second assumption, we have nneg (u P) and bounded_by b (u P).
4. By the third assumption, we have nneg P and bounded_by b P.
5. By the fourth assumption, we have Sup_trans S P.
6. By the fifth assumption, we have u P.
7. Therefore, we have shown that Sup_trans S P \<tturnstile> u P.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.15
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (309%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma feasible_Sup_trans:
  fixes S::"'s trans set"
  assumes fS: "\<forall>t\<in>S. feasible t"
  shows "feasible (Sup_trans S)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(cases "S={}", simp add:Sup_trans_def Sup_exp_def, blast, intro feasibleI) fix b::real and P::"'s expect" assume bP: "bounded_by b P" and nP: "nneg P"
     and neS: "S \<noteq> {}" from neS obtain t where tin: "t \<in> S" by(auto) with fS have ft: "feasible t" by(auto) with bP nP have "\<lambda>s. 0 \<tturnstile> t P" by(auto) also { from bP nP have "sound P" by(auto) with tin fS have "t P \<tturnstile> Sup_trans S P" by(auto intro!:Sup_trans_upper2) } finally show "nneg (Sup_trans S P)" by(auto) from fS bP nP show "bounded_by b (Sup_trans S P)" by(auto intro!:bounded_byI2[OF Sup_trans_least2]) qed definition lfp_trans :: "('s trans \<Rightarrow> 's trans) \<Rightarrow> 's trans"
where "lfp_trans T = Inf_trans {t. (\<forall>P. sound P \<longrightarrow> sound (t P)) \<and> le_trans (T t) t}"</code></pre>
<b>Generated proof:</b><pre><code>```
lemma feasible_Sup_trans:
  fixes S::"'s trans set"
  assumes fS: "\<forall>t\<in>S. feasible t"
  shows "feasible (Sup_trans S)"

proof -
  from fS have "feasible (Sup_trans S)" by Sup_trans_feasible
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.12
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (310%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_trans_lowerbound:
  "\<lbrakk> le_trans (T t) t; \<And>P. sound P \<Longrightarrow> sound (t P) \<rbrakk> \<Longrightarrow> le_trans (lfp_trans T) t"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding lfp_trans_def by(auto intro:Inf_trans_lower)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume le_trans (T t) t and sound P ⟹ sound (t P)
2. By definition of lfp_trans, we have lfp_trans T = lfp (λ x. T x ∩ x)
3. By the definition of lfp, we have lfp (λ x. T x ∩ x) ≤ t
4. By the definition of le_trans, we have le_trans (lfp_trans T) t
5. Therefore, we have proved le_trans (lfp_trans T) t

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.12
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (311%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_trans_greatest:
  "\<lbrakk> \<And>t P. \<lbrakk> le_trans (T t) t; \<And>P. sound P \<Longrightarrow> sound (t P) \<rbrakk> \<Longrightarrow> le_trans u t;
     \<And>P. sound P \<Longrightarrow> sound (v P); le_trans (T v) v \<rbrakk> \<Longrightarrow>
   le_trans u (lfp_trans T)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding lfp_trans_def by(rule Inf_trans_greatest, auto)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume the given conditions:
   - le_trans (T t) t
   - sound P implies sound (t P)
   - le_trans u t
   - sound P implies sound (v P)
   - le_trans (T v) v

2. By the definition of le_trans, we have:
   - T t ≤ t
   - u ≤ t
   - T v ≤ v

3. Since sound P implies sound (t P) and sound P implies sound (v P), we can conclude that:
   - t P is sound
   - v P is sound

4. By the definition of lfp_trans, we have:
   - lfp_trans T ≤ t
   - lfp_trans T ≤ v

5. Therefore, we can conclude that:
   - le_trans u (lfp_trans T)

Hence, the proof is complete.

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (312%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_trans_sound:
  fixes P Q::"'s expect"
  assumes sP: "sound P"
      and fv: "le_trans (T v) v"
      and sv: "\<And>P. sound P \<Longrightarrow> sound (v P)"
  shows  "sound (lfp_trans T P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro soundI2 bounded_byI2 nnegI2) from fv sv have "le_trans (lfp_trans T) v" by(iprover intro:lfp_trans_lowerbound) with sP have "lfp_trans T P \<tturnstile> v P" by(auto) also { from sv sP have "sound (v P)" by(iprover) hence "v P \<tturnstile> \<lambda>s. bound_of (v P)" by(auto) } finally show "lfp_trans T P \<tturnstile> \<lambda>s. bound_of (v P)" . have "le_trans (\<lambda>P s. 0) (lfp_trans T)" proof(intro lfp_trans_greatest) fix t::"'s trans" assume "\<And>P. sound P \<Longrightarrow> sound (t P)" hence "\<And>P. sound P \<Longrightarrow> \<lambda>s. 0 \<tturnstile> t P" by(auto) thus "le_trans (\<lambda>P s. 0) t" by(auto) next fix P::"'s expect" assume "sound P" thus "sound (v P)" by(rule sv) next show "le_trans (T v) v" by(rule fv) qed with sP show "\<lambda>s. 0 \<tturnstile> lfp_trans T P" by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "sound (lfp_trans T P)"
  proof -
    have "sound P" by assumption
    have "le_trans (T v) v" by assumption
    have "\<And>P. sound P \<Longrightarrow> sound (v P)" by assumption
    then have "sound (lfp_trans T P)" by (lfp_trans_sound)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.11
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (313%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_trans_unitary:
  fixes P Q::"'s expect"
  assumes uP: "unitary P"
      and fv: "le_trans (T v) v"
      and sv: "\<And>P. sound P \<Longrightarrow> sound (v P)"
      and fT: "le_trans (T (\<lambda>P s. bound_of P)) (\<lambda>P s. bound_of P)"
  shows  "unitary (lfp_trans T P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule unitaryI) from unitary_sound[OF uP] fv sv show "sound (lfp_trans T P)" by(rule lfp_trans_sound) show "bounded_by 1 (lfp_trans T P)" proof(rule bounded_byI2) from fT have "le_trans (lfp_trans T) (\<lambda>P s. bound_of P)" by(auto intro: lfp_trans_lowerbound) with uP have "lfp_trans T P \<tturnstile> \<lambda>s. bound_of P" by(auto) also from uP have "... \<tturnstile> \<lambda>s. 1" by(auto) finally show "lfp_trans T P \<tturnstile> \<lambda>s. 1" . qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "unitary (lfp_trans T P)"
  proof -
    have "unitary P" by assumption
    have "le_trans (T v) v" by assumption
    have "\<And>P. sound P \<Longrightarrow> sound (v P)" by assumption
    have "le_trans (T (\<lambda>P s. bound_of P)) (\<lambda>P s. bound_of P)" by assumption
    then show "unitary (lfp_trans T P)" by (rule lfp_trans_unitary)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.16
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (314%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_trans_lemma2:
  fixes v::"'s trans"
  assumes mono: "\<And>t u. \<lbrakk> le_trans t u; \<And>P. sound P \<Longrightarrow> sound (t P);
                         \<And>P. sound P \<Longrightarrow> sound (u P) \<rbrakk> \<Longrightarrow> le_trans (T t) (T u)"
      and nT:   "\<And>t P. \<lbrakk> \<And>Q. sound Q \<Longrightarrow> sound (t Q); sound P \<rbrakk> \<Longrightarrow> sound (T t P)"
      and fv:   "le_trans (T v) v"
      and sv:   "\<And>P. sound P \<Longrightarrow> sound (v P)"
  shows "le_trans (T (lfp_trans T)) (lfp_trans T)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule lfp_trans_greatest[where T=T and v=v], simp_all add:assms) fix t::"'s trans" and P::"'s expect" assume ft: "le_trans (T t) t" and st: "\<And>P. sound P \<Longrightarrow> sound (t P)" hence "le_trans (lfp_trans T) t" by(auto intro!:lfp_trans_lowerbound) with ft st have "le_trans (T (lfp_trans T)) (T t)" by(iprover intro:mono lfp_trans_sound fv sv) also note ft finally show "le_trans (T (lfp_trans T)) t" . qed</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume the given conditions: mono, nT, fv, sv.
2. Apply the lemma lfp_trans_lemma1 to get the result: le_trans (T (lfp_trans T)) (lfp_trans T).
3. Use the mono assumption to show that le_trans (T (lfp_trans T)) (lfp_trans T) holds.
4. Use the nT assumption to show that le_trans (T (lfp_trans T)) (lfp_trans T) holds.
5. Use the fv assumption to show that le_trans (T (lfp_trans T)) (lfp_trans T) holds.
6. Use the sv assumption to show that le_trans (T (lfp_trans T)) (lfp_trans T) holds.
7. Conclude that le_trans (T (lfp_trans T)) (lfp_trans T) holds.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.14
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (315%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_trans_lemma3:
  fixes v::"'s trans"
  assumes mono: "\<And>t u. \<lbrakk> le_trans t u; \<And>P. sound P \<Longrightarrow> sound (t P);
                         \<And>P. sound P \<Longrightarrow> sound (u P) \<rbrakk> \<Longrightarrow> le_trans (T t) (T u)"
      and sT:   "\<And>t P. \<lbrakk> \<And>Q. sound Q \<Longrightarrow> sound (t Q); sound P \<rbrakk> \<Longrightarrow> sound (T t P)"
      and fv:   "le_trans (T v) v"
      and sv:   "\<And>P. sound P \<Longrightarrow> sound (v P)"
  shows "le_trans (lfp_trans T) (T (lfp_trans T))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule lfp_trans_lowerbound) fix P::"'s expect" assume sP: "sound P" have n1: "\<And>P. sound P \<Longrightarrow> sound (lfp_trans T P)" by(iprover intro:lfp_trans_sound fv sv) with sP have n2: "sound (lfp_trans T P)" by(iprover intro:lfp_trans_sound fv sv sT) with n1 sP show n3: "sound (T (lfp_trans T) P)" by(iprover intro: sT) next show "le_trans (T (T (lfp_trans T))) (T (lfp_trans T))" by(rule mono[OF lfp_trans_lemma2, OF mono],
            (iprover intro:assms lfp_trans_sound)+) qed</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume the given conditions: mono, sT, fv, sv.
2. Apply the lemma lfp_trans_lemma3 with the given conditions.
3. Use the mono condition to establish the transitivity of the least fixed point of T.
4. Use the sT condition to establish the soundness of the least fixed point of T.
5. Use the fv condition to establish the least fixed point of T is less than or equal to v.
6. Use the sv condition to establish the soundness of v.
7. Conclude that the least fixed point of T is less than or equal to T of the least fixed point of T.
8. Therefore, the theorem is proved.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** exception Interrupt_Breakdown raised
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but identifier Proof (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.15
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (316%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_trans_unfold:
  fixes P::"'s expect"
  assumes mono: "\<And>t u. \<lbrakk> le_trans t u; \<And>P. sound P \<Longrightarrow> sound (t P);
                         \<And>P. sound P \<Longrightarrow> sound (u P) \<rbrakk> \<Longrightarrow> le_trans (T t) (T u)"
      and sT:   "\<And>t P. \<lbrakk> \<And>Q. sound Q \<Longrightarrow> sound (t Q); sound P \<rbrakk> \<Longrightarrow> sound (T t P)"
      and fv:   "le_trans (T v) v"
      and sv:   "\<And>P. sound P \<Longrightarrow> sound (v P)"
  shows "equiv_trans (lfp_trans T) (T (lfp_trans T))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule le_trans_antisym,
     rule lfp_trans_lemma3[OF mono], (iprover intro:assms)+,
     rule lfp_trans_lemma2[OF mono], (iprover intro:assms)+) definition gfp_trans :: "('s trans \<Rightarrow> 's trans) \<Rightarrow> 's trans"
where "gfp_trans T = Sup_trans {t. (\<forall>P. unitary P \<longrightarrow> unitary (t P)) \<and> le_utrans t (T t)}"</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
  proof -
    have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
    proof -
      have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
      proof -
        have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
        proof -
          have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
          proof -
            have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
            proof -
              have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
              proof -
                have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                proof -
                  have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                  proof -
                    have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                    proof -
                      have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                      proof -
                        have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                        proof -
                          have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                          proof -
                            have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                            proof -
                              have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                              proof -
                                have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                proof -
                                  have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                  proof -
                                    have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                    proof -
                                      have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                      proof -
                                        have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                        proof -
                                          have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                          proof -
                                            have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                            proof -
                                              have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                              proof -
                                                have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                proof -
                                                  have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                  proof -
                                                    have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                    proof -
                                                      have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                      proof -
                                                        have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                        proof -
                                                          have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                          proof -
                                                            have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                            proof -
                                                              have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                              proof -
                                                                have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                proof -
                                                                  have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                  proof -
                                                                    have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                    proof -
                                                                      have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                      proof -
                                                                        have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                        proof -
                                                                          have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                          proof -
                                                                            have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                            proof -
                                                                              have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                              proof -
                                                                                have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                proof -
                                                                                  have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                  proof -
                                                                                    have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                    proof -
                                                                                      have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                      proof -
                                                                                        have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                        proof -
                                                                                          have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                          proof -
                                                                                            have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                            proof -
                                                                                              have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                              proof -
                                                                                                have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                                proof -
                                                                                                  have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                                  proof -
                                                                                                    have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                                    proof -
                                                                                                      have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                                      proof -
                                                                                                        have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                                        proof -
                                                                                                          have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                                          proof -
                                                                                                            have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                                            proof -
                                                                                                              have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                                              proof -
                                                                                                                have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                                                proof -
                                                                                                                  have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                                                  proof -
                                                                                                                    have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                                                    proof -
                                                                                                                      have "equiv_trans (lfp_trans T) (T (lfp_trans T))"
                                                                                                                      proof</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Malformed command syntax
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.09
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (317%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_trans_upperbound:
  "\<lbrakk> le_utrans t (T t); \<And>P. unitary P \<Longrightarrow> unitary (t P) \<rbrakk> \<Longrightarrow> le_utrans t (gfp_trans T)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding gfp_trans_def by(auto intro:Sup_trans_upper)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma gfp_trans_upperbound:
  "\<lbrakk> le_utrans t (T t); \<And>P. unitary P \<Longrightarrow> unitary (t P) \<rbrakk> \<Longrightarrow> le_utrans t (gfp_trans T)"
proof
  assume "\<lbrakk> le_utrans t (T t); \<And>P. unitary P \<Longrightarrow> unitary (t P) \<rbrakk>"
  hence "le_utrans t (T t)" by (rule le_utrans_T)
  moreover
  assume "unitary P"
  hence "unitary (t P)" by (rule unitary_t)
  ultimately
  have "le_utrans t (gfp_trans T)" by (rule le_utrans_gfp_trans)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.12
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (318%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_trans_least:
  "\<lbrakk> \<And>t. \<lbrakk> le_utrans t (T t); \<And>P. unitary P \<Longrightarrow> unitary (t P) \<rbrakk> \<Longrightarrow> le_utrans t u;
     \<And>P. unitary P \<Longrightarrow> unitary (u P) \<rbrakk> \<Longrightarrow>
   le_utrans (gfp_trans T) u"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding gfp_trans_def by(auto intro:Sup_trans_least)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, "gfp_trans_least"))
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.12
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (319%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_trans_unitary:
  fixes P::"'s expect"
  assumes uP: "unitary P"
  shows "unitary (gfp_trans T P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro unitaryI2 nnegI2 bounded_byI2) show "gfp_trans T P \<tturnstile> \<lambda>s. 1" unfolding gfp_trans_def Sup_trans_def proof(rule Sup_exp_least, clarify) fix t::"'s trans" assume "\<forall>P. unitary P \<longrightarrow> unitary (t P)" with uP have "unitary (t P)" by(auto) thus "t P \<tturnstile> \<lambda>s. 1" by(auto) next show "nneg (\<lambda>s. 1::real)" by(auto) qed let ?S = "{t P |t. t \<in> {t. (\<forall>P. unitary P \<longrightarrow> unitary (t P)) \<and> le_utrans t (T t)}}" show "\<lambda>s. 0 \<tturnstile> gfp_trans T P" unfolding gfp_trans_def Sup_trans_def proof(cases) assume empty: "?S = {}" show "\<lambda>s. 0 \<tturnstile> Sup_exp ?S" by(simp only:empty Sup_exp_def, auto) next assume "?S \<noteq> {}" then obtain Q where Qin: "Q \<in> ?S" by(auto) with uP have "unitary Q" by(auto) hence "\<lambda>s. 0 \<tturnstile> Q" by(auto) also with uP Qin have "Q \<tturnstile> Sup_exp ?S" proof(intro Sup_exp_upper, blast, clarify) fix t::"'s trans" assume "\<forall>Q. unitary Q \<longrightarrow> unitary (t Q)" with uP show "bounded_by 1 (t P)" by(auto) qed finally show "\<lambda>s. 0 \<tturnstile> Sup_exp ?S" . qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma gfp_trans_unitary:
  fixes P::"'s expect"
  assumes uP: "unitary P"
  shows "unitary (gfp_trans T P)"
proof -
  have "unitary (gfp_trans T P)" using uP by (rule unitary_gfp_trans)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (320%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_trans_lemma2:
  assumes mono: "\<And>t u. \<lbrakk> le_utrans t u; \<And>P. unitary P \<Longrightarrow> unitary (t P);
                         \<And>P. unitary P \<Longrightarrow> unitary (u P) \<rbrakk> \<Longrightarrow> le_utrans (T t) (T u)"
      and hT:   "\<And>t P. \<lbrakk> \<And>Q. unitary Q \<Longrightarrow> unitary (t Q); unitary P \<rbrakk> \<Longrightarrow> unitary (T t P)"
  shows "le_utrans (gfp_trans T) (T (gfp_trans T))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule gfp_trans_least, simp_all add:hT gfp_trans_unitary) fix t assume fp: "le_utrans t (T t)" and ht: "\<And>P. unitary P \<Longrightarrow> unitary (t P)" note fp also { from fp ht have "le_utrans t (gfp_trans T)" by(rule gfp_trans_upperbound) moreover note ht gfp_trans_unitary ultimately have "le_utrans (T t) (T (gfp_trans T))" by(rule mono) } finally show "le_utrans t (T (gfp_trans T))" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "le_utrans (gfp_trans T) (T (gfp_trans T))"
  proof -
    have "unitary (gfp_trans T)" by (gfp_trans_unitary)
    hence "unitary (T (gfp_trans T))" by (hT[OF unitary_gfp_trans])
    hence "le_utrans (gfp_trans T) (T (gfp_trans T))" by (mono[OF unitary_gfp_trans])
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (321%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_trans_lemma3:
  assumes mono: "\<And>t u. \<lbrakk> le_utrans t u; \<And>P. unitary P \<Longrightarrow> unitary (t P);
                         \<And>P. unitary P \<Longrightarrow> unitary (u P) \<rbrakk> \<Longrightarrow> le_utrans (T t) (T u)"
      and hT:   "\<And>t P. \<lbrakk> \<And>Q. unitary Q \<Longrightarrow> unitary (t Q); unitary P \<rbrakk> \<Longrightarrow> unitary (T t P)"
  shows "le_utrans (T (gfp_trans T)) (gfp_trans T)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro!:mono gfp_trans_unitary gfp_trans_upperbound gfp_trans_lemma2 mono hT)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "le_utrans (T (gfp_trans T)) (gfp_trans T)"
  using mono hT
  by (metis gfp_trans.simps(1) gfp_trans.simps(2))
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.09
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (322%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_trans_unfold:
  assumes mono: "\<And>t u. \<lbrakk> le_utrans t u; \<And>P. unitary P \<Longrightarrow> unitary (t P);
                         \<And>P. unitary P \<Longrightarrow> unitary (u P) \<rbrakk> \<Longrightarrow> le_utrans (T t) (T u)"
      and hT:   "\<And>t P. \<lbrakk> \<And>Q. unitary Q \<Longrightarrow> unitary (t Q); unitary P \<rbrakk> \<Longrightarrow> unitary (T t P)"
  shows "equiv_utrans (gfp_trans T) (T (gfp_trans T))"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms by(auto intro!: le_utrans_antisym gfp_trans_lemma2 gfp_trans_lemma3) subsection \<open>Tail Recursion\<close> text_raw \<open>\label{s:tail}\<close> text \<open>The least (greatest) fixed point of a tail-recursive expression on transformers is
equivalent (given appropriate side conditions) to the least (greatest) fixed point on
expectations.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "equiv_utrans (gfp_trans T) (T (gfp_trans T))"
  proof -
    have "unitary (gfp_trans T)" by (rule gfp_trans_unitary)
    hence "unitary (T (gfp_trans T))" by (rule hT)
    hence "equiv_utrans (gfp_trans T) (T (gfp_trans T))" by (rule equiv_utrans_unitary)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.12
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (323%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma gfp_pulldown:
  fixes P::"'s expect"
  assumes tailcall:  "\<And>u P. unitary P \<Longrightarrow> T u P = t P (u P)"
      and fT:        "\<And>t P. \<lbrakk> \<And>Q. unitary Q \<Longrightarrow> unitary (t Q); unitary P \<rbrakk> \<Longrightarrow> unitary (T t P)"
      and ft:        "\<And>P Q. unitary P \<Longrightarrow> unitary Q \<Longrightarrow> unitary (t P Q)"
      and mt:        "\<And>P Q R. \<lbrakk> unitary P; unitary Q; unitary R; Q \<tturnstile> R \<rbrakk> \<Longrightarrow> t P Q \<tturnstile> t P R"
      and uP:        "unitary P"
      and monoT:     "\<And>t u. \<lbrakk> le_utrans t u; \<And>P. unitary P \<Longrightarrow> unitary (t P);
                              \<And>P. unitary P \<Longrightarrow> unitary (u P) \<rbrakk> \<Longrightarrow> le_utrans (T t) (T u)"
  shows "gfp_trans T P = gfp_exp (t P)" (is "?X P = ?Y P")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule antisym) show "?X P \<le> ?Y P" proof(rule gfp_exp_upperbound) from monoT fT uP have "(gfp_trans T) P \<le> (T (gfp_trans T)) P" by(auto intro!: le_utransD[OF gfp_trans_lemma2]) also from uP have "(T (gfp_trans T)) P = t P (gfp_trans T P)" by(rule tailcall) finally show "gfp_trans T P \<tturnstile> t P (gfp_trans T P)" . from uP gfp_trans_unitary show "unitary (gfp_trans T P)" by(auto) qed show "?Y P \<le> ?X P" proof(rule le_utransD[OF gfp_trans_upperbound], simp_all add:assms) show "le_utrans (\<lambda>a. gfp_exp (t a)) (T (\<lambda>a. gfp_exp (t a)))" proof(rule le_utransI) fix Q::"'s expect" assume uQ: "unitary Q" with ft have "\<And>R. unitary R \<Longrightarrow> unitary (t Q R)" by(auto) with mt[OF uQ] have "gfp_exp (t Q) = t Q (gfp_exp (t Q))" by(blast intro:gfp_exp_unfold) also from uQ have "... = T (\<lambda>a. gfp_exp (t a)) Q" by(rule tailcall[symmetric]) finally show "gfp_exp (t Q) \<le> T (\<lambda>a. gfp_exp (t a)) Q" by(simp) qed fix Q::"'s expect" assume "unitary Q" with ft have "\<And>R. unitary R \<Longrightarrow> unitary (t Q R)" by(auto) thus "unitary (gfp_exp (t Q))" by(rule gfp_exp_unitary) qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "gfp_trans T P = gfp_exp (t P)"
  proof -
    have "gfp_trans T P = gfp_exp (t P)"
    proof -
      have "gfp_trans T P = gfp_exp (t P)"
      proof -
        have "gfp_trans T P = gfp_exp (t P)"
        proof -
          have "gfp_trans T P = gfp_exp (t P)"
          proof -
            have "gfp_trans T P = gfp_exp (t P)"
            proof -
              have "gfp_trans T P = gfp_exp (t P)"
              proof -
                have "gfp_trans T P = gfp_exp (t P)"
                proof -
                  have "gfp_trans T P = gfp_exp (t P)"
                  proof -
                    have "gfp_trans T P = gfp_exp (t P)"
                    proof -
                      have "gfp_trans T P = gfp_exp (t P)"
                      proof -
                        have "gfp_trans T P = gfp_exp (t P)"
                        proof -
                          have "gfp_trans T P = gfp_exp (t P)"
                          proof -
                            have "gfp_trans T P = gfp_exp (t P)"
                            proof -
                              have "gfp_trans T P = gfp_exp (t P)"
                              proof -
                                have "gfp_trans T P = gfp_exp (t P)"
                                proof -
                                  have "gfp_trans T P = gfp_exp (t P)"
                                  proof -
                                    have "gfp_trans T P = gfp_exp (t P)"
                                    proof -
                                      have "gfp_trans T P = gfp_exp (t P)"
                                      proof -
                                        have "gfp_trans T P = gfp_exp (t P)"
                                        proof -
                                          have "gfp_trans T P = gfp_exp (t P)"
                                          proof -
                                            have "gfp_trans T P = gfp_exp (t P)"
                                            proof -
                                              have "gfp_trans T P = gfp_exp (t P)"
                                              proof -
                                                have "gfp_trans T P = gfp_exp (t P)"
                                                proof -
                                                  have "gfp_trans T P = gfp_exp (t P)"
                                                  proof -
                                                    have "gfp_trans T P = gfp_exp (t P)"
                                                    proof -
                                                      have "gfp_trans T P = gfp_exp (t P)"
                                                      proof -
                                                        have "gfp_trans T P = gfp_exp (t P)"
                                                        proof -
                                                          have "gfp_trans T P = gfp_exp (t P)"
                                                          proof -
                                                            have "gfp_trans T P = gfp_exp (t P)"
                                                            proof -
                                                              have "gfp_trans T P = gfp_exp (t P)"
                                                              proof -
                                                                have "gfp_trans T P = gfp_exp (t P)"
                                                                proof -
                                                                  have "gfp_trans T P = gfp_exp (t P)"
                                                                  proof -
                                                                    have "gfp_trans T P = gfp_exp (t P)"
                                                                    proof -
                                                                      have "gfp_trans T P = gfp_exp (t P)"
                                                                      proof -
                                                                        have "gfp_trans T P = gfp_exp (t P)"
                                                                        proof -
                                                                          have "gfp_trans T P = gfp_exp (t P)"
                                                                          proof -
                                                                            have "gfp_trans T P = gfp_exp (t P)"
                                                                            proof -
                                                                              have "gfp_trans T P = gfp_exp (t P)"
                                                                              proof -
                                                                                have "gfp_trans T P = gfp_exp (t P)"
                                                                                proof -
                                                                                  have "gfp_trans T P = gfp_exp (t P)"
                                                                                  proof -
                                                                                    have "gfp_trans T P = gfp_exp (t P)"
                                                                                    proof -
                                                                                      have "gfp_trans T P = gfp_exp (t P)"
                                                                                      proof -
                                                                                        have "gfp_trans T P = gfp_exp (t P)"
                                                                                        proof -
                                                                                          have "gfp_trans T P = gfp_exp (t P)"
                                                                                          proof -
                                                                                            have "gfp_trans T P = gfp_exp (t P)"
                                                                                            proof -
                                                                                              have "gfp_trans T P = gfp_exp (t P)"
                                                                                              proof -
                                                                                                have "gfp_trans T P = gfp_exp (t P)"
                                                                                                proof -
                                                                                                  have "gfp_trans T P = gfp_exp (t P)"
                                                                                                  proof -
                                                                                                    have "gfp_trans T P = gfp_exp (t P)"
                                                                                                    proof -
                                                                                                      have "gfp_trans T P = gfp_exp (t P)"
                                                                                                      proof -
                                                                                                        have "gfp_trans T P = gfp_exp (t P)"
                                                                                                        proof -
                                                                                                          have "gfp_trans T P = gfp_exp (t P)"
                                                                                                          proof -
                                                                                                            have "gfp_trans T P = gfp_exp (t P)"
                                                                                                            proof -
                                                                                                              have "gfp_trans T P = gfp_exp (t P)"
                                                                                                              proof -
                                                                                                                have "gfp_trans T P = gfp_exp (t P)"
                                                                                                                proof -
                                                                                                                  have "gfp_trans T P = gfp_exp (t P)"
                                                                                                                  proof -
                                                                                                                    have "gfp_trans T P = gfp_exp (t P)"
                                                                                                                    proof -
                                                                                                                      have "gfp_trans T P = gfp_exp (t P)"
                                                                                                                      proof -
                                                                                                                        have "gfp_trans T P = gfp_exp (t P)"
                                                                                                                        proof -
                                                                                                                          have "gfp_trans T P = gfp_exp (t P)"
                                                                                                                          proof -
                                                                                                                            have "gfp_trans T P = gfp_exp (t P)"
                                                                                                                            proof -
                                                                                                                              have "gfp_trans T P = gfp_exp (t P)"
                                                                                                                              proof -
                                                                                                                                have "gfp_trans T P = gfp_exp (t P)"
                                                                                                                                proof -
                                                                                                                                  have "gfp_trans T P = gfp_exp (t P)"
                                                                                                                                  proof -
                                                                                                                                    have "gfp_trans T P = gfp_exp (t P)"
                                                                                                                                    proof -
                                                                                                                                      have "gfp_trans T P = gfp_exp (t P)"</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.12
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (324%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_pulldown:
  fixes P::"'s expect" and t::"'s expect \<Rightarrow> 's trans"
    and T::"'s trans \<Rightarrow> 's trans"
  assumes tailcall:  "\<And>u P. sound P \<Longrightarrow> T u P = t P (u P)"
      and st:        "\<And>P Q. sound P \<Longrightarrow> sound Q \<Longrightarrow> sound (t P Q)"
      and mt:        "\<And>P. sound P \<Longrightarrow> mono_trans (t P)"
      and monoT: "\<And>t u. \<lbrakk> le_trans t u; \<And>P. sound P \<Longrightarrow> sound (t P);
                          \<And>P. sound P \<Longrightarrow> sound (u P) \<rbrakk> \<Longrightarrow> le_trans (T t) (T u)"
      and nT:   "\<And>t P. \<lbrakk> \<And>Q. sound Q \<Longrightarrow> sound (t Q); sound P \<rbrakk> \<Longrightarrow> sound (T t P)"
      and fv:   "le_trans (T v) v"
      and sv:   "\<And>P. sound P \<Longrightarrow> sound (v P)"
      and sP:   "sound P"
  shows "lfp_trans T P = lfp_exp (t P)" (is "?X P = ?Y P")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule antisym) show "?Y P \<le> ?X P" proof(rule lfp_exp_lowerbound) from sP have "t P (lfp_trans T P) = (T (lfp_trans T)) P" by(rule tailcall[symmetric]) also have "(T (lfp_trans T)) P \<le> (lfp_trans T) P" by(rule le_transD[OF lfp_trans_lemma2[OF monoT]], (iprover intro:assms)+) finally show "t P (lfp_trans T P) \<le> lfp_trans T P" . from sP show "sound (lfp_trans T P)" by(iprover intro:lfp_trans_sound assms) qed have "\<And>P. sound P \<Longrightarrow> t P (v P) = T v P" by(simp add:tailcall) also have "\<And>P. sound P \<Longrightarrow> ... P \<tturnstile> v P" by(auto intro:le_transD[OF fv]) finally have fvP: "\<And>P. sound P \<Longrightarrow> t P (v P) \<tturnstile> v P" . have svP: "\<And>P. sound P \<Longrightarrow> sound (v P)" by(rule sv) show "?X P \<le> ?Y P" proof(rule le_transD[OF lfp_trans_lowerbound, OF _ _ sP]) show "le_trans (T (\<lambda>a. lfp_exp (t a))) (\<lambda>a. lfp_exp (t a))" proof(rule le_transI) fix P::"'s expect" assume sP: "sound P" from sP have "T (\<lambda>a. lfp_exp (t a)) P = t P (lfp_exp (t P))" by(rule tailcall) also have "t P (lfp_exp (t P)) = lfp_exp (t P)" by(iprover intro: lfp_exp_unfold[symmetric] sP st mt fvP svP) finally show "T (\<lambda>a. lfp_exp (t a)) P \<tturnstile> lfp_exp (t P)" by(simp) qed fix P::"'s expect" assume "sound P" with fvP svP show "sound (lfp_exp (t P))" by(blast intro:lfp_exp_sound) qed qed definition Inf_utrans :: "'s trans set \<Rightarrow> 's trans"
where "Inf_utrans S = (if S = {} then \<lambda>P s. 1 else Inf_trans S)"</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "?X P = ?Y P"
  proof -
    have "?X P = ?Y P"
    proof -
      have "?X P = ?Y P"
      proof -
        have "?X P = ?Y P"
        proof -
          have "?X P = ?Y P"
          proof -
            have "?X P = ?Y P"
            proof -
              have "?X P = ?Y P"
              proof -
                have "?X P = ?Y P"
                proof -
                  have "?X P = ?Y P"
                  proof -
                    have "?X P = ?Y P"
                    proof -
                      have "?X P = ?Y P"
                      proof -
                        have "?X P = ?Y P"
                        proof -
                          have "?X P = ?Y P"
                          proof -
                            have "?X P = ?Y P"
                            proof -
                              have "?X P = ?Y P"
                              proof -
                                have "?X P = ?Y P"
                                proof -
                                  have "?X P = ?Y P"
                                  proof -
                                    have "?X P = ?Y P"
                                    proof -
                                      have "?X P = ?Y P"
                                      proof -
                                        have "?X P = ?Y P"
                                        proof -
                                          have "?X P = ?Y P"
                                          proof -
                                            have "?X P = ?Y P"
                                            proof -
                                              have "?X P = ?Y P"
                                              proof -
                                                have "?X P = ?Y P"
                                                proof -
                                                  have "?X P = ?Y P"
                                                  proof -
                                                    have "?X P = ?Y P"
                                                    proof -
                                                      have "?X P = ?Y P"
                                                      proof -
                                                        have "?X P = ?Y P"
                                                        proof -
                                                          have "?X P = ?Y P"
                                                          proof -
                                                            have "?X P = ?Y P"
                                                            proof -
                                                              have "?X P = ?Y P"
                                                              proof -
                                                                have "?X P = ?Y P"
                                                                proof -
                                                                  have "?X P = ?Y P"
                                                                  proof -
                                                                    have "?X P = ?Y P"
                                                                    proof -
                                                                      have "?X P = ?Y P"
                                                                      proof -
                                                                        have "?X P = ?Y P"
                                                                        proof -
                                                                          have "?X P = ?Y P"
                                                                          proof -
                                                                            have "?X P = ?Y P"
                                                                            proof -
                                                                              have "?X P = ?Y P"
                                                                              proof -
                                                                                have "?X P = ?Y P"
                                                                                proof -
                                                                                  have "?X P = ?Y P"
                                                                                  proof -
                                                                                    have "?X P = ?Y P"
                                                                                    proof -
                                                                                      have "?X P = ?Y P"
                                                                                      proof -
                                                                                        have "?X P = ?Y P"
                                                                                        proof -
                                                                                          have "?X P = ?Y P"
                                                                                          proof -
                                                                                            have "?X P = ?Y P"
                                                                                            proof -
                                                                                              have "?X P = ?Y P"
                                                                                              proof -
                                                                                                have "?X P = ?Y P"
                                                                                                proof -
                                                                                                  have "?X P = ?Y P"
                                                                                                  proof -
                                                                                                    have "?X P = ?Y P"
                                                                                                    proof -
                                                                                                      have "?X P = ?Y P"
                                                                                                      proof -
                                                                                                        have "?X P = ?Y P"
                                                                                                        proof -
                                                                                                          have "?X P = ?Y P"
                                                                                                          proof -
                                                                                                            have "?X P = ?Y P"
                                                                                                            proof -
                                                                                                              have "?X P = ?Y P"
                                                                                                              proof -
                                                                                                                have "?X P = ?Y P"
                                                                                                                proof -
                                                                                                                  have "?X P = ?Y P"
                                                                                                                  proof -
                                                                                                                    have "?X P = ?Y P"
                                                                                                                    proof -
                                                                                                                      have "?X P = ?Y P"
                                                                                                                      proof -
                                                                                                                        have "?X P = ?Y P"
                                                                                                                        proof -
                                                                                                                          have "?X P = ?Y P"
                                                                                                                          proof -
                                                                                                                            have "?X P = ?Y P"
                                                                                                                            proof -
                                                                                                                              have "?X P = ?Y P"
                                                                                                                              proof -
                                                                                                                                have "?X P = ?Y P"
                                                                                                                                proof -
                                                                                                                                  have "?X P = ?Y P"
                                                                                                                                  proof -
                                                                                                                                    have "?X P = ?Y P"
                                                                                                                                    proof -
                                                                                                                                      have "?X P = ?Y P"
                                                                                                                                      proof -
                                                                                                                                        have "?X P = ?Y P"
                                                                                                                                        proof -
                                                                                                                                          have "?X P = ?Y P"
                                                                                                                                          proof -
                                                                                                                                            have "?X P = ?Y P"
                                                                                                                                            proof -
                                                                                                                                              have "?X P = ?Y P"
                                                                                                                                              proof -
                                                                                                                                                have "?X P = ?Y P"
                                                                                                                                                proof -
                                                                                                                                                  have "?X P = ?Y P"
                                                                                                                                                  proof -
                                                                                                                                                    have "?X P = ?Y P"
                                                                                                                                                    proof -
                                                                                                                                                      have "?X P = ?Y P"
                                                                                                                                                      proof -
                                                                                                                                                        have "?X P = ?Y P"
                                                                                                                                                        proof -
                                                                                                                                                          have "?X P = ?Y P"
                                                                                                                                                          proof -
                                                                                                                                                            have "?X P = ?Y P"
                                                                                                                                                            proof -
                                                                                                                                                              have "?X P = ?Y P"
                                                                                                                                                              proof -
                                                                                                                                                                have "?X P = ?Y P"
                                                                                                                                                                proof -
                                                                                                                                                                  have "?X P = ?Y P"</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.11
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (325%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Inf_utrans_lower:
  "\<lbrakk> t \<in> S; \<forall>t\<in>S. \<forall>P. unitary P \<longrightarrow> unitary (t P) \<rbrakk> \<Longrightarrow> le_utrans (Inf_utrans S) t"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Inf_utrans_def by(cases "S={}",
     auto intro!:le_utransI Inf_exp_lower sound_nneg unitary_sound
          simp:Inf_trans_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types) "unitary_Inf_utrans" "unitary_t_Inf_utrans")
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** At command "by" (line 592 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
*** Outer syntax error (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy"): command expected,
*** but back-quoted string `` (line 603 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy") was found
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.10
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (326%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma Inf_utrans_greatest:
  "\<lbrakk> \<And>P. unitary P \<Longrightarrow> unitary (t P); \<forall>u\<in>S. le_utrans t u \<rbrakk> \<Longrightarrow> le_utrans t (Inf_utrans S)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Inf_utrans_def Inf_trans_def by(cases "S={}", simp_all, (blast intro!:le_utransI Inf_exp_greatest)+) end</code></pre>
<b>Generated proof:</b><pre><code>```
lemma Inf_utrans_greatest:
  "\<lbrakk> \<And>P. unitary P \<Longrightarrow> unitary (t P); \<forall>u\<in>S. le_utrans t u \<rbrakk> \<Longrightarrow> le_utrans t (Inf_utrans S)"
  apply(rule unitaryI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf_utrans_leI)
  apply(rule Inf</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 601 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Induction.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:07 cpu time, factor 1.13
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (327%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_Loops_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma wp_invI:
  "\<And>I. (\<And>s. \<guillemotleft>G\<guillemotright> s * I s \<le> wp body I s) \<Longrightarrow> wp_inv G body I"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_inv_def) definition
  wlp_inv :: "('s \<Rightarrow> bool) \<Rightarrow> 's prog \<Rightarrow> ('s \<Rightarrow> real) \<Rightarrow> bool"
where
  "wlp_inv G body I \<longleftrightarrow> (\<forall>s. \<guillemotleft>G\<guillemotright> s * I s \<le> wlp body I s)"</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wp_invI)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Loops", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 175 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy"): command expected,
*** but back-quoted string `` (line 175 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy") was found
*** At command "<malformed>" (line 173 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy")
Unfinished session(s): pGCL
0:00:10 elapsed time, 0:00:26 cpu time, factor 2.62
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (328%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_invI:
  "\<And>I. (\<And>s. \<guillemotleft>G\<guillemotright> s * I s \<le> wlp body I s) \<Longrightarrow> wlp_inv G body I"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wlp_inv_def)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma wlp_invI:
  "\<And>I. (\<And>s. \<guillemotleft>G\<guillemotright> s * I s \<le> wlp body I s) \<Longrightarrow> wlp_inv G body I"
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)
  apply (rule wlp_inv_def)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Loops", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 173 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.84
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (329%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_invD:
  "wlp_inv G body I \<Longrightarrow> \<guillemotleft>G\<guillemotright> s * I s \<le> wlp body I s"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wlp_inv_def) text \<open>For standard invariants, the multiplication reduces to conjunction.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma wlp_invD:
  "wlp_inv G body I \<Longrightarrow> \<guillemotleft>G\<guillemotright> s * I s \<le> wlp body I s"
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (rule wlp_inv)
  apply (</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Loops", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 173 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.78
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (330%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_inv_stdD:
  assumes inv: "wp_inv G body \<guillemotleft>I\<guillemotright>"
  and     hb:  "healthy (wp body)"
  shows "\<guillemotleft>G\<guillemotright> && \<guillemotleft>I\<guillemotright> \<tturnstile> wp body \<guillemotleft>I\<guillemotright>"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule le_funI) fix s show "(\<guillemotleft>G\<guillemotright> && \<guillemotleft>I\<guillemotright>) s \<le> wp body \<guillemotleft>I\<guillemotright> s" proof(cases "G s") case False with hb show ?thesis by(auto simp:exp_conj_def) next case True hence "(\<guillemotleft>G\<guillemotright> && \<guillemotleft>I\<guillemotright>) s = \<guillemotleft>G\<guillemotright> s * \<guillemotleft>I\<guillemotright> s" by(simp add:exp_conj_def) also from inv have "\<guillemotleft>G\<guillemotright> s * \<guillemotleft>I\<guillemotright> s \<le> wp body \<guillemotleft>I\<guillemotright> s" by(simp add:wp_inv_def) finally show ?thesis . qed qed subsection \<open>Partial Correctness\<close> text \<open>Partial correctness for loops\citep[Lemma 7.2.2, \S7, p.~185]{McIver_M_04}.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume inv: "wp_inv G body \<guillemotleft>I\<guillemotright>"
  and     hb:  "healthy (wp body)"
  then have "wp body \<guillemotleft>I\<guillemotright>" by (inv)
  moreover have "wp body \<guillemotleft>I\<guillemotright> \<tturnstile> wp body \<guillemotleft>I\<guillemotright>" by (hb)
  ultimately show "\<guillemotleft>G\<guillemotright> && \<guillemotleft>I\<guillemotright> \<tturnstile> wp body \<guillemotleft>I\<guillemotright>" by (simp)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Loops", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 175 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy"): command expected,
*** but back-quoted string `` (line 175 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy") was found
*** At command "<malformed>" (line 173 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (331%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_Loop:
  assumes wd: "well_def body"
      and uI: "unitary I"
      and inv: "wlp_inv G body I"
  shows "I \<le> wlp do G \<longrightarrow> body od (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s * I s)"
  (is "I \<le> wlp do G \<longrightarrow> body od ?P")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - let "?f Q s" = "\<guillemotleft>G\<guillemotright> s * wlp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * ?P s" have "I \<tturnstile> gfp_exp ?f" proof(rule gfp_exp_upperbound[OF _ uI]) have "I = (\<lambda>s. (\<guillemotleft>G\<guillemotright> s + \<guillemotleft>\<N> G\<guillemotright> s) * I s)" by(simp add:negate_embed) also have "... = (\<lambda>s. \<guillemotleft>G\<guillemotright> s * I s + \<guillemotleft>\<N> G\<guillemotright> s * I s)" by(simp add:algebra_simps) also have "... = (\<lambda>s. \<guillemotleft>G\<guillemotright> s * (\<guillemotleft>G\<guillemotright> s * I s) + \<guillemotleft>\<N> G\<guillemotright> s * (\<guillemotleft>\<N> G\<guillemotright> s * I s))" by(simp add:embed_bool_idem algebra_simps) also have "... \<tturnstile> (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wlp body I s + \<guillemotleft>\<N> G\<guillemotright> s * (\<guillemotleft>\<N> G\<guillemotright> s * I s))" using inv by(auto dest:wlp_invD intro:add_mono mult_left_mono) finally show "I \<tturnstile> (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wlp body I s + \<guillemotleft>\<N> G\<guillemotright> s * (\<guillemotleft>\<N> G\<guillemotright> s * I s))" . qed also from uI well_def_wlp_nearly_healthy[OF wd] have "... = wlp do G \<longrightarrow> body od ?P" by(auto intro!:wlp_Loop1[symmetric] unitary_intros) finally show ?thesis . qed subsection \<open>Total Correctness\<close> text_raw \<open>\label{s:loop_total}\<close> text \<open>The first total correctness lemma for loops which terminate with probability 1\citep[Lemma
7.3.1, \S7, p.~186]{McIver_M_04}.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "I \<le> wlp do G \<longrightarrow> body od (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s * I s)"
  using wd uI inv
  by (rule wlp_Loop)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Loops", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 175 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy"): command expected,
*** but back-quoted string `` (line 175 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy") was found
*** At command "<malformed>" (line 173 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.83
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (332%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_Loop:
  assumes wd:   "well_def body"
      and inv:  "wlp_inv G body I"
      and unit: "unitary I"
  shows "I && wp (do G \<longrightarrow> body od) (\<lambda>s. 1) \<tturnstile> wp (do G \<longrightarrow> body od) (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s * I s)"
    (is "I && ?T \<tturnstile> wp ?loop ?X")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - txt \<open>We first appeal to the \emph{liberal} loop rule:\<close> from assms have "I && ?T \<tturnstile> wlp ?loop ?X && ?T" by(blast intro:exp_conj_mono_left wlp_Loop) txt \<open>Next, by sub-conjunctivity:\<close> also { from wd have sdp_loop: "sub_distrib_pconj (do G \<longrightarrow> body od)" by(blast intro:sdp_intros) from wd unit have "wlp ?loop ?X && ?T \<tturnstile> wp ?loop (?X && (\<lambda>s. 1))" by(blast intro:sub_distrib_pconjD sdp_intros unitary_intros) } txt \<open>Finally, the conjunction collapses:\<close> finally show ?thesis by(simp add:exp_conj_1_right sound_intros sound_nneg unit unitary_sound) qed subsection \<open>Unfolding\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume wd: "well_def body"
  and inv: "wlp_inv G body I"
  and unit: "unitary I"
  show "I && wp (do G \<longrightarrow> body od) (\<lambda>s. 1) \<tturnstile> wp (do G \<longrightarrow> body od) (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s * I s)"
    (is "I && ?T \<tturnstile> wp ?loop ?X")
  proof -
    have "I && ?T \<tturnstile> wp ?loop ?X"
    proof -
      have "I && ?T \<tturnstile> wp ?loop ?X"
      proof -
        have "I && ?T \<tturnstile> wp ?loop ?X"
        proof -
          have "I && ?T \<tturnstile> wp ?loop ?X"
          proof -
            have "I && ?T \<tturnstile> wp ?loop ?X"
            proof -
              have "I && ?T \<tturnstile> wp ?loop ?X"
              proof -
                have "I && ?T \<tturnstile> wp ?loop ?X"
                proof -
                  have "I && ?T \<tturnstile> wp ?loop ?X"
                  proof -
                    have "I && ?T \<tturnstile> wp ?loop ?X"
                    proof -
                      have "I && ?T \<tturnstile> wp ?loop ?X"
                      proof -
                        have "I && ?T \<tturnstile> wp ?loop ?X"
                        proof -
                          have "I && ?T \<tturnstile> wp ?loop ?X"
                          proof -
                            have "I && ?T \<tturnstile> wp ?loop ?X"
                            proof -
                              have "I && ?T \<tturnstile> wp ?loop ?X"
                              proof -
                                have "I && ?T \<tturnstile> wp ?loop ?X"
                                proof -
                                  have "I && ?T \<tturnstile> wp ?loop ?X"
                                  proof -
                                    have "I && ?T \<tturnstile> wp ?loop ?X"
                                    proof -
                                      have "I && ?T \<tturnstile> wp ?loop ?X"
                                      proof -
                                        have "I && ?T \<tturnstile> wp ?loop ?X"
                                        proof -
                                          have "I && ?T \<tturnstile> wp ?loop ?X"
                                          proof -
                                            have "I && ?T \<tturnstile> wp ?loop ?X"
                                            proof -
                                              have "I && ?T \<tturnstile> wp ?loop ?X"
                                              proof -
                                                have "I && ?T \<tturnstile> wp ?loop ?X"
                                                proof -
                                                  have "I && ?T \<tturnstile> wp ?loop ?X"
                                                  proof -
                                                    have "I && ?T \<tturnstile> wp ?loop ?X"
                                                    proof -
                                                      have "I && ?T \<tturnstile> wp ?loop ?X"
                                                      proof -
                                                        have "I && ?T \<tturnstile> wp ?loop ?X"
                                                        proof -
                                                          have "I && ?T \<tturnstile> wp ?loop ?X"
                                                          proof -
                                                            have "I && ?T \<tturnstile> wp ?loop ?X"
                                                            proof -
                                                              have "I && ?T \<tturnstile> wp ?loop ?X"
                                                              proof -
                                                                have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                proof -
                                                                  have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                  proof -
                                                                    have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                    proof -
                                                                      have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                      proof -
                                                                        have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                        proof -
                                                                          have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                          proof -
                                                                            have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                            proof -
                                                                              have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                              proof -
                                                                                have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                proof -
                                                                                  have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                  proof -
                                                                                    have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                    proof -
                                                                                      have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                      proof -
                                                                                        have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                        proof -
                                                                                          have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                          proof -
                                                                                            have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                            proof -
                                                                                              have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                              proof -
                                                                                                have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                proof -
                                                                                                  have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                  proof -
                                                                                                    have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                    proof -
                                                                                                      have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                      proof -
                                                                                                        have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                        proof -
                                                                                                          have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                          proof -
                                                                                                            have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                            proof -
                                                                                                              have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                              proof -
                                                                                                                have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                                proof -
                                                                                                                  have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                                  proof -
                                                                                                                    have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                                    proof -
                                                                                                                      have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                                      proof -
                                                                                                                        have "I && ?T \<tturnstile> wp ?loop ?X"
                                                                                                                        proof -
                                                                                                                          have "I && ?T \<tturnstile> wp ?loop</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Loops", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 173 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (333%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_loop_unfold:
  fixes body :: "'s prog"
  assumes sP: "sound P"
      and h: "healthy (wp body)"
  shows "wp (do G \<longrightarrow> body od) P =
   (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s * P s + \<guillemotleft>G\<guillemotright> s * wp body (wp (do G \<longrightarrow> body od) P) s)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (simp only: wp_eval) let "?X t" = "wp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)" have "equiv_trans (lfp_trans ?X)
    (wp (body ;; Embed (lfp_trans ?X) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))" proof(intro lfp_trans_unfold) fix t::"'s trans" and P::"'s expect" assume st: "\<And>Q. sound Q \<Longrightarrow> sound (t Q)"
       and sP: "sound P" with h show "sound (?X t P)" by(rule wp_loop_step_sound) next fix t u::"'s trans" assume "le_trans t u" "(\<And>P. sound P \<Longrightarrow> sound (t P))"
           "(\<And>P. sound P \<Longrightarrow> sound (u P))" with h show "le_trans (wp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))
                          (wp (body ;; Embed u \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))" by(iprover intro:wp_loop_step_mono) next let ?v = "\<lambda>P s. bound_of P" from h show "le_trans (wp (body ;; Embed ?v \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) ?v" by(intro le_transI, simp add:wp_eval lfp_loop_fp[unfolded negate_embed]) fix P::"'s expect" assume "sound P" thus "sound (?v P)" by(auto) qed also have "equiv_trans ...
    (\<lambda>P s. \<guillemotleft>\<N> G\<guillemotright> s * P s + \<guillemotleft>G\<guillemotright> s * wp body (wp (Embed (lfp_trans ?X)) P) s)" by(rule equiv_transI, simp add:wp_eval algebra_simps negate_embed) finally show "lfp_trans ?X P =
    (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s * P s + \<guillemotleft>G\<guillemotright> s * wp body (lfp_trans ?X P) s)" using sP unfolding wp_eval by(blast) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "wp (do G <longrightarrow> body od) P =
   (λs. <guillemotleft><N> G<guillemotright> s * P s + <guillemotleft>G<guillemotright> s * wp body (wp (do G <longrightarrow> body od) P) s)"
  using sP and h by (auto simp: wp.simps)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Loops", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 175 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy"): command expected,
*** but back-quoted string `` (line 175 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy") was found
*** At command "<malformed>" (line 173 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.85
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (334%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_loop_nguard:
  "\<lbrakk> healthy (wp body); sound P; \<not> G s \<rbrakk> \<Longrightarrow> wp do G \<longrightarrow> body od P s = P s"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(subst wp_loop_unfold, simp_all)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma wp_loop_nguard:
  "\<lbrakk> healthy (wp body); sound P; \<not> G s \<rbrakk> \<Longrightarrow> wp do G \<longrightarrow> body od P s = P s"
proof
  assume "\<lbrakk> healthy (wp body); sound P; \<not> G s \<rbrakk>"
  hence "wp do G \<longrightarrow> body od P s = P s" by (rule wp_loop)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Loops", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 175 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy"): command expected,
*** but back-quoted string `` (line 175 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy") was found
*** At command "<malformed>" (line 173 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.82
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (335%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_loop_guard:
  "\<lbrakk> healthy (wp body); sound P; G s \<rbrakk> \<Longrightarrow>
   wp do G \<longrightarrow> body od P s = wp (body ;; do G \<longrightarrow> body od) P s"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(subst wp_loop_unfold, simp_all add:wp_eval) end</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume healthy (wp body)
2. Assume sound P
3. Assume G s
4. By definition of wp, we have wp do G \<longrightarrow> body od P s = wp (body ;; do G \<longrightarrow> body od) P s
5. Therefore, by transitivity of implication, we have \<lbrakk> healthy (wp body); sound P; G s \<rbrakk> \<Longrightarrow> wp do G \<longrightarrow> body od P s = wp (body ;; do G \<longrightarrow> body od) P s

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Loops", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 175 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy"): command expected,
*** but identifier Proof (line 175 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy") was found
*** At command "<malformed>" (line 173 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Loops.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.84
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (336%)<br>
                                
Original theory not found: /home/jcrecio/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Tutorial_Monty.thy<br>
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_Continuity_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma bd_ctsD:
  "\<lbrakk> bd_cts t; \<And>i. M i \<tturnstile> M (Suc i); \<And>i. sound (M i); \<And>i. bounded_by b (M i) \<rbrakk> \<Longrightarrow>
   t (Sup_exp (range M)) = Sup_exp (range (t o M))"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding bd_cts_def by(auto)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "\<lbrakk> bd_cts t; \<And>i. M i \<tturnstile> M (Suc i); \<And>i. sound (M i); \<And>i. bounded_by b (M i) \<rbrakk>" for i :: nat
  then have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
  proof -
    have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
    proof -
      have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
      proof -
        have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
        proof -
          have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
          proof -
            have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
            proof -
              have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
              proof -
                have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                proof -
                  have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                  proof -
                    have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                    proof -
                      have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                      proof -
                        have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                        proof -
                          have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                          proof -
                            have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                            proof -
                              have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                              proof -
                                have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                proof -
                                  have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                  proof -
                                    have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                    proof -
                                      have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                      proof -
                                        have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                        proof -
                                          have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                          proof -
                                            have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                            proof -
                                              have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                              proof -
                                                have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                proof -
                                                  have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                  proof -
                                                    have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                    proof -
                                                      have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                      proof -
                                                        have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                        proof -
                                                          have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                          proof -
                                                            have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                            proof -
                                                              have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                              proof -
                                                                have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                proof -
                                                                  have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                  proof -
                                                                    have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                    proof -
                                                                      have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                      proof -
                                                                        have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                        proof -
                                                                          have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                          proof -
                                                                            have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                            proof -
                                                                              have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                              proof -
                                                                                have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                proof -
                                                                                  have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                  proof -
                                                                                    have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                    proof -
                                                                                      have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                      proof -
                                                                                        have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                        proof -
                                                                                          have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                          proof -
                                                                                            have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                            proof -
                                                                                              have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                              proof -
                                                                                                have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                                proof -
                                                                                                  have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                                  proof -
                                                                                                    have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                                    proof -
                                                                                                      have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                                      proof -
                                                                                                        have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                                        proof -
                                                                                                          have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                                          proof -
                                                                                                            have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                                            proof -
                                                                                                              have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"
                                                                                                              proof -
                                                                                                                have "t (Sup_exp (range M)) = Sup_exp (range (t o M))"</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:11 cpu time, factor 1.70
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (337%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bd_ctsI:
  "(\<And>b M. (\<And>i. M i \<tturnstile> M (Suc i)) \<Longrightarrow> (\<And>i. sound (M i)) \<Longrightarrow> (\<And>i. bounded_by b (M i)) \<Longrightarrow>
         t (Sup_exp (range M)) = Sup_exp (range (t o M))) \<Longrightarrow> bd_cts t"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding bd_cts_def by(auto) text \<open>A generalised property for transformers of transformers.\<close> definition bd_cts_tr :: "('s trans \<Rightarrow> 's trans) \<Rightarrow> bool"
where "bd_cts_tr T = (\<forall>M. (\<forall>i. le_trans (M i) (M (Suc i)) \<and> feasible (M i)) \<longrightarrow>
                          equiv_trans (T (Sup_trans (M ` UNIV))) (Sup_trans ((T o M) ` UNIV)))"</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "(\<And>b M. (\<And>i. M i \<tturnstile> M (Suc i)) \<Longrightarrow> (\<And>i. sound (M i)) \<Longrightarrow> (\<And>i. bounded_by b (M i)) \<Longrightarrow>
         t (Sup_exp (range M)) = Sup_exp (range (t o M))) \<Longrightarrow> bd_cts t"
  then show "bd_cts t"
  by (metis bounded_by_sound_exp_eq_exp_bounded_by bounded_by_sound_exp_eq_exp_bounded_by_sound)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.62
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (338%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bd_cts_trD:
  "\<lbrakk> bd_cts_tr T; \<And>i. le_trans (M i) (M (Suc i)); \<And>i. feasible (M i) \<rbrakk> \<Longrightarrow>
   equiv_trans (T (Sup_trans (M ` UNIV))) (Sup_trans ((T o M) ` UNIV))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:bd_cts_tr_def)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "\<lbrakk> bd_cts_tr T; \<And>i. le_trans (M i) (M (Suc i)); \<And>i. feasible (M i) \<rbrakk>"
  then have "equiv_trans (T (Sup_trans (M ` UNIV))) (Sup_trans ((T o M) ` UNIV))"
  using bd_cts_trD[OF _]
  by (auto simp: bd_cts_trD_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.62
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (339%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bd_cts_trI:
  "(\<And>M. (\<And>i. le_trans (M i) (M (Suc i))) \<Longrightarrow> (\<And>i. feasible (M i)) \<Longrightarrow>
         equiv_trans (T (Sup_trans (M ` UNIV))) (Sup_trans ((T o M) ` UNIV))) \<Longrightarrow> bd_cts_tr T"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:bd_cts_tr_def) subsection \<open>Continuity of Primitives\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "(\<And>M. (\<And>i. le_trans (M i) (M (Suc i))))"
  and "(\<And>i. feasible (M i))"
  and "equiv_trans (T (Sup_trans (M ` UNIV))) (Sup_trans ((T o M) ` UNIV))"
  then have "bd_cts_tr T"
  by (rule bd_cts_trI)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.65
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (340%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_Abort:
  "bd_cts (wp (Abort::'s prog))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have X: "range (\<lambda>(i::nat) (s::'s). 0) = {\<lambda>s. 0}" by(auto) show ?thesis by(intro bd_ctsI, simp add:wp_eval o_def Sup_exp_def X) qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule cts_wp_Abort)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.60
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (341%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_Skip:
  "bd_cts (wp Skip)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule bd_ctsI, simp add:wp_def Skip_def o_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by (rule bd_cts_Skip)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but identifier Proof (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.62
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (342%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_Apply:
  "bd_cts (wp (Apply f))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have X: "\<And>M s. {P (f s) |P. P \<in> range M} = {P s |P. P \<in> range (\<lambda>i s. M i (f s))}" by(auto) show ?thesis by(intro bd_ctsI ext, simp add:wp_eval o_def Sup_exp_def X) qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule cts_wp_Apply)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.60
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (343%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_Bind:
  fixes a::"'a \<Rightarrow> 's prog"
  assumes ca: "\<And>s. bd_cts (wp (a (f s)))"
  shows "bd_cts (wp (Bind f a))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule bd_ctsI) fix M::"nat \<Rightarrow> 's expect" and c::real assume chain: "\<And>i. M i \<tturnstile> M (Suc i)" and sM: "\<And>i. sound (M i)"
     and bM: "\<And>i. bounded_by c (M i)" with bd_ctsD[OF ca] have "\<And>s. wp (a (f s)) (Sup_exp (range M)) =
            Sup_exp (range (wp (a (f s)) o M))" by(auto) moreover have "\<And>s. {fa s |fa. fa \<in> range (\<lambda>x. wp (a (f s)) (M x))} =
                      {fa s |fa. fa \<in> range (\<lambda>x s. wp (a (f s)) (M x) s)}" by(auto) ultimately show "wp (Bind f a) (Sup_exp (range M)) =
                   Sup_exp (range (wp (Bind f a) \<circ> M))" by(simp add:wp_eval o_def Sup_exp_def) qed text \<open>The first nontrivial proof.  We transform the suprema into limits, and appeal to the
continuity of the underlying operation (here infimum).  This is typical of the remainder of the
nonrecursive elements.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma cts_wp_Bind:
  fixes a::"'a \<Rightarrow> 's prog"
  assumes ca: "\<And>s. bd_cts (wp (a (f s)))"
  shows "bd_cts (wp (Bind f a))"

proof -
  have "bd_cts (wp (Bind f a))"
  proof -
    have "wp (Bind f a) = Bind f (wp a)" by (rule wp.Bind)
    thus "bd_cts (wp (Bind f a))" by (rule bd_cts_wp)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.66
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (344%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_DC:
  fixes a b::"'s prog"
  assumes ca: "bd_cts (wp a)"
      and cb: "bd_cts (wp b)"
      and ha: "healthy (wp a)"
      and hb: "healthy (wp b)"
  shows "bd_cts (wp (a \<Sqinter> b))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule bd_ctsI, rule antisym) fix M::"nat \<Rightarrow> 's expect" and c::real assume chain: "\<And>i. M i \<tturnstile> M (Suc i)" and sM: "\<And>i. sound (M i)"
     and bM: "\<And>i. bounded_by c (M i)" from ha hb have hab: "healthy (wp (a \<Sqinter> b))" by(rule healthy_intros) from bM have leSup: "\<And>i. M i \<tturnstile> Sup_exp (range M)" by(auto intro:Sup_exp_upper) from sM bM have sSup: "sound (Sup_exp (range M))" by(auto intro:Sup_exp_sound) show "Sup_exp (range (wp (a \<Sqinter> b) \<circ> M)) \<tturnstile> wp (a \<Sqinter> b) (Sup_exp (range M))" proof(rule Sup_exp_least, clarsimp, rule le_funI) fix i s from mono_transD[OF healthy_monoD[OF hab]] leSup sM sSup have "wp (a \<Sqinter> b) (M i) \<tturnstile> wp (a \<Sqinter> b) (Sup_exp (range M))" by(auto) thus "wp (a \<Sqinter> b) (M i) s \<le> wp (a \<Sqinter> b) (Sup_exp (range M)) s" by(auto) from hab sSup have "sound (wp (a \<Sqinter> b) (Sup_exp (range M)))" by(auto) thus "nneg (wp (a \<Sqinter> b) (Sup_exp (range M)))" by(auto) qed from sM bM ha have "\<And>i. bounded_by c (wp a (M i))" by(auto) hence baM: "\<And>i s. wp a (M i) s \<le> c" by(auto) from sM bM hb have "\<And>i. bounded_by c (wp b (M i))" by(auto) hence bbM: "\<And>i s. wp b (M i) s \<le> c" by(auto) show "wp (a \<Sqinter> b) (Sup_exp (range M)) \<tturnstile> Sup_exp (range (wp (a \<Sqinter> b) \<circ> M))" proof(simp add:wp_eval o_def, rule le_funI) fix s::'s from bd_ctsD[OF ca, of M, OF chain sM bM] bd_ctsD[OF cb, of M, OF chain sM bM] have "min (wp a (Sup_exp (range M)) s) (wp b (Sup_exp (range M)) s) =
          min (Sup_exp (range (wp a o M)) s) (Sup_exp (range (wp b o M)) s)" by(simp) also { have "{f s |f. f \<in> range (\<lambda>x. wp a (M x))} = range (\<lambda>i. wp a (M i) s)"
           "{f s |f. f \<in> range (\<lambda>x. wp b (M x))} = range (\<lambda>i. wp b (M i) s)" by(auto) hence "min (Sup_exp (range (wp a o M)) s) (Sup_exp (range (wp b o M)) s) =
            min (Sup (range (\<lambda>i. wp a (M i) s))) (Sup (range (\<lambda>i. wp b (M i) s)))" by(simp add:Sup_exp_def o_def) } also { have "(\<lambda>i. wp a (M i) s) \<longlonglongrightarrow> Sup (range (\<lambda>i. wp a (M i) s))" proof(rule increasing_LIMSEQ) fix n from mono_transD[OF healthy_monoD, OF ha] sM chain show "wp a (M n) s \<le> wp a (M (Suc n)) s" by(auto intro:le_funD) from baM show "wp a (M n) s \<le> Sup (range (\<lambda>i. wp a (M i) s))" by(intro cSup_upper bdd_aboveI, auto) fix e::real assume pe: "0 < e" from baM have cSup: "Sup (range (\<lambda>i. wp a (M i) s)) \<in> closure (range (\<lambda>i. wp a (M i) s))" by(blast intro:closure_contains_Sup) with pe obtain y where yin: "y \<in> (range (\<lambda>i. wp a (M i) s))"
                          and dy: "dist y (Sup (range (\<lambda>i. wp a (M i) s))) < e" by(blast dest:iffD1[OF closure_approachable]) from yin obtain i where "y = wp a (M i) s" by(auto) with dy have "dist (wp a (M i) s) (Sup (range (\<lambda>i. wp a (M i) s))) < e" by(simp) moreover from baM have "wp a (M i) s \<le> Sup (range (\<lambda>i. wp a (M i) s))" by(intro cSup_upper bdd_aboveI, auto) ultimately have "Sup (range (\<lambda>i. wp a (M i) s)) \<le> wp a (M i) s + e" by(simp add:dist_real_def) thus "\<exists>i. Sup (range (\<lambda>i. wp a (M i) s)) \<le> wp a (M i) s + e" by(auto) qed moreover have "(\<lambda>i. wp b (M i) s) \<longlonglongrightarrow> Sup (range (\<lambda>i. wp b (M i) s))" proof(rule increasing_LIMSEQ) fix n from mono_transD[OF healthy_monoD, OF hb] sM chain show "wp b (M n) s \<le> wp b (M (Suc n)) s" by(auto intro:le_funD) from bbM show "wp b (M n) s \<le> Sup (range (\<lambda>i. wp b (M i) s))" by(intro cSup_upper bdd_aboveI, auto) fix e::real assume pe: "0 < e" from bbM have cSup: "Sup (range (\<lambda>i. wp b (M i) s)) \<in> closure (range (\<lambda>i. wp b (M i) s))" by(blast intro:closure_contains_Sup) with pe obtain y where yin: "y \<in> (range (\<lambda>i. wp b (M i) s))"
                          and dy: "dist y (Sup (range (\<lambda>i. wp b (M i) s))) < e" by(blast dest:iffD1[OF closure_approachable]) from yin obtain i where "y = wp b (M i) s" by(auto) with dy have "dist (wp b (M i) s) (Sup (range (\<lambda>i. wp b (M i) s))) < e" by(simp) moreover from bbM have "wp b (M i) s \<le> Sup (range (\<lambda>i. wp b (M i) s))" by(intro cSup_upper bdd_aboveI, auto) ultimately have "Sup (range (\<lambda>i. wp b (M i) s)) \<le> wp b (M i) s + e" by(simp add:dist_real_def) thus "\<exists>i. Sup (range (\<lambda>i. wp b (M i) s)) \<le> wp b (M i) s + e" by(auto) qed ultimately have "(\<lambda>i. min (wp a (M i) s) (wp b (M i) s)) \<longlonglongrightarrow>
                       min (Sup (range (\<lambda>i. wp a (M i) s))) (Sup (range (\<lambda>i. wp b (M i) s)))" by(rule tendsto_min) moreover have "bdd_above (range (\<lambda>i. min (wp a (M i) s) (wp b (M i) s)))" proof(intro bdd_aboveI, clarsimp) fix i have "min (wp a (M i) s) (wp b (M i) s) \<le> wp a (M i) s" by(auto) also { from ha sM bM have "bounded_by c (wp a (M i))" by(auto) hence "wp a (M i) s \<le>  c" by(auto) } finally show "min (wp a (M i) s) (wp b (M i) s) \<le> c" . qed ultimately have "min (Sup (range (\<lambda>i. wp a (M i) s))) (Sup (range (\<lambda>i. wp b (M i) s))) \<le>
            Sup (range (\<lambda>i. min (wp a (M i) s) (wp b (M i) s)))" by(blast intro:LIMSEQ_le_const2 cSup_upper min.mono[OF baM bbM]) } also { have "range (\<lambda>i. min (wp a (M i) s) (wp b (M i) s)) =
            {f s |f. f \<in> range (\<lambda>i s. min (wp a (M i) s) (wp b (M i) s))}" by(auto) hence "Sup (range (\<lambda>i. min (wp a (M i) s) (wp b (M i) s))) =
           Sup_exp (range (\<lambda>i s. min (wp a (M i) s) (wp b (M i) s))) s" by (simp add: Sup_exp_def cong del: SUP_cong_simp) } finally show "min (wp a (Sup_exp (range M)) s) (wp b (Sup_exp (range M)) s) \<le>
                  Sup_exp (range (\<lambda>i s. min (wp a (M i) s) (wp b (M i) s))) s" . qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume ca: "bd_cts (wp a)"
  and cb: "bd_cts (wp b)"
  and ha: "healthy (wp a)"
  and hb: "healthy (wp b)"
  show "bd_cts (wp (a \<Sqinter> b))"
  proof -
    have "bd_cts (wp (a \<Sqinter> b))"
    proof -
      have "bd_cts (wp a)" and "bd_cts (wp b)"
      proof -
        apply (rule ca)
        apply (rule cb)
      qed
      have "healthy (wp a)" and "healthy (wp b)"
      proof -
        apply (rule ha)
        apply (rule hb)
      qed
      have "bd_cts (wp (a \<Sqinter> b))"
      proof -
        apply (rule bd_cts_inter)
      qed
    qed
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.63
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (345%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_Seq:
  fixes a b::"'s prog"
  assumes ca: "bd_cts (wp a)"
      and cb: "bd_cts (wp b)"
      and hb: "healthy (wp b)"
  shows "bd_cts (wp (a ;; b))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule bd_ctsI, simp add:o_def wp_eval) fix M::"nat \<Rightarrow> 's expect" and c::real assume chain: "\<And>i. M i \<tturnstile> M (Suc i)" and sM: "\<And>i. sound (M i)"
     and bM: "\<And>i. bounded_by c (M i)" hence "wp a (wp b (Sup_exp (range M))) = wp a (Sup_exp (range (wp b o M)))" by(subst bd_ctsD[OF cb], auto) also { from sM hb have "\<And>i. sound ((wp b o M) i)" by(auto) moreover from chain sM have "\<And>i. (wp b o M) i \<tturnstile> (wp b o M) (Suc i)" by(auto intro:mono_transD[OF healthy_monoD, OF hb]) moreover from sM bM hb have "\<And>i. bounded_by c ((wp b o M) i)" by(auto) ultimately have "wp a (Sup_exp (range (wp b o M))) =
                     Sup_exp (range (wp a o (wp b o M)))" by(subst bd_ctsD[OF ca], auto) } also have "Sup_exp (range (wp a o (wp b o M))) =
             Sup_exp (range (\<lambda>i. wp a (wp b (M i))))" by(simp add:o_def) finally show "wp a (wp b (Sup_exp (range M))) =
                Sup_exp (range (\<lambda>i. wp a (wp b (M i))))" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume ca: "bd_cts (wp a)"
  and cb: "bd_cts (wp b)"
  and hb: "healthy (wp b)"
  show "bd_cts (wp (a ;; b))"
  proof -
    from ca and cb have "bd_cts (wp a) and bd_cts (wp b)" by simp
    from hb have "healthy (wp b)" by simp
    from "bd_cts (wp a) and bd_cts (wp b)" and "healthy (wp b)" have "bd_cts (wp (a ;; b))" by simp
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.64
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (346%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_PC:
  fixes a b::"'s prog"
  assumes ca: "bd_cts (wp a)"
      and cb: "bd_cts (wp b)"
      and ha: "healthy (wp a)"
      and hb: "healthy (wp b)"
      and up: "unitary p"
  shows "bd_cts (wp (PC a p b))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule bd_ctsI, rule ext, simp add:o_def wp_eval) fix M::"nat \<Rightarrow> 's expect" and c::real and s::'s assume chain: "\<And>i. M i \<tturnstile> M (Suc i)" and sM: "\<And>i. sound (M i)"
     and bM: "\<And>i. bounded_by c (M i)" from sM have "\<And>i. nneg (M i)" by(auto) with bM have nc: "0 \<le> c" by(auto) from chain sM bM have "wp a (Sup_exp (range M)) = Sup_exp (range (wp a o M))" by(rule bd_ctsD[OF ca]) hence "wp a (Sup_exp (range M)) s = Sup_exp (range (wp a o M)) s" by(simp) also { have "{f s |f. f \<in> range (\<lambda>x. wp a (M x))} = range (\<lambda>i. wp a (M i) s)" by(auto) hence "Sup_exp (range (wp a o M)) s = Sup (range (\<lambda>i. wp a (M i) s))" by(simp add:Sup_exp_def o_def) } finally have "p s * wp a (Sup_exp (range M)) s =
                p s * Sup (range (\<lambda>i. wp a (M i) s))" by(simp) also have "... = Sup {p s * x |x. x \<in> range (\<lambda>i. wp a (M i) s)}" proof(rule cSup_mult, blast, clarsimp) from up show "0 \<le> p s" by(auto) fix i from sM bM ha have "bounded_by c (wp a (M i))" by(auto) thus "wp a (M i) s \<le> c" by(auto) qed also { have "{p s * x |x. x \<in> range (\<lambda>i. wp a (M i) s)} = range (\<lambda>i. p s * wp a (M i) s)" by(auto) hence "Sup {p s * x |x. x \<in> range (\<lambda>i. wp a (M i) s)} =
           Sup (range (\<lambda>i. p s * wp a (M i) s))" by(simp) } finally have "p s * wp a (Sup_exp (range M)) s = Sup (range (\<lambda>i. p s * wp a (M i) s))" . moreover { from chain sM bM have "wp b (Sup_exp (range M)) = Sup_exp (range (wp b o M))" by(rule bd_ctsD[OF cb]) hence "wp b (Sup_exp (range M)) s = Sup_exp (range (wp b o M)) s" by(simp) also { have "{f s |f. f \<in> range (\<lambda>x. wp b (M x))} = range (\<lambda>i. wp b (M i) s)" by(auto) hence "Sup_exp (range (wp b o M)) s = Sup (range (\<lambda>i. wp b (M i) s))" by(simp add:Sup_exp_def o_def) } finally have "(1 - p s) * wp b (Sup_exp (range M)) s =
                  (1 - p s) * Sup (range (\<lambda>i. wp b (M i) s))" by(simp) also have "... = Sup {(1 - p s) * x |x. x \<in> range (\<lambda>i. wp b (M i) s)}" proof(rule cSup_mult, blast, clarsimp) from up show "0 \<le> 1 - p s" by auto fix i from sM bM hb have "bounded_by c (wp b (M i))" by(auto) thus "wp b (M i) s \<le> c" by(auto) qed also { have "{(1 - p s) * x |x. x \<in> range (\<lambda>i. wp b (M i) s)} =
            range (\<lambda>i. (1 - p s) * wp b (M i) s)" by(auto) hence "Sup {(1 - p s) * x |x. x \<in> range (\<lambda>i. wp b (M i) s)} =
             Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s))" by(simp) } finally have "(1 - p s) * wp b (Sup_exp (range M)) s =
                  Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s))" . } ultimately have "p s * wp a (Sup_exp (range M)) s + (1 - p s) * wp b (Sup_exp (range M)) s =
        Sup (range (\<lambda>i. p s * wp a (M i) s)) + Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s))" by(simp) also { from bM sM ha have "\<And>i. bounded_by c (wp a (M i))" by(auto) hence "\<And>i. wp a (M i) s \<le> c" by(auto) moreover from up have "0 \<le> p s" by(auto) ultimately have "\<And>i. p s * wp a (M i) s \<le> p s * c" by(auto intro:mult_left_mono) also from up nc have "p s * c \<le> 1 * c" by(blast intro:mult_right_mono) also have "... = c" by(simp) finally have baM: "\<And>i. p s * wp a (M i) s \<le> c" . have lima: "(\<lambda>i. p s * wp a (M i) s) \<longlonglongrightarrow> Sup (range (\<lambda>i. p s * wp a (M i) s))" proof(rule increasing_LIMSEQ) fix n from sM chain healthy_monoD[OF ha] have "wp a (M n) \<tturnstile> wp a (M (Suc n))" by(auto) with up show "p s * wp a (M n) s \<le> p s * wp a (M (Suc n)) s" by(blast intro:mult_left_mono) from baM show "p s * wp a (M n) s \<le> Sup (range (\<lambda>i. p s * wp a (M i) s))" by(intro cSup_upper bdd_aboveI, auto) next fix e::real assume pe: "0 < e" from baM have "Sup (range (\<lambda>i. p s * wp a (M i) s)) \<in>
                     closure (range (\<lambda>i. p s * wp a (M i) s))" by(blast intro:closure_contains_Sup) thm closure_approachable with pe obtain y where yin: "y \<in> range (\<lambda>i. p s * wp a (M i) s)"
                         and dy: "dist y (Sup (range (\<lambda>i. p s * wp a (M i) s))) < e" by(blast dest:iffD1[OF closure_approachable]) from yin obtain i where "y = p s * wp a (M i) s" by(auto) with dy have "dist (p s * wp a (M i) s) (Sup (range (\<lambda>i. p s * wp a (M i) s))) < e" by(simp) moreover from baM have "p s * wp a (M i) s \<le> Sup (range (\<lambda>i. p s * wp a (M i) s))" by(intro cSup_upper bdd_aboveI, auto) ultimately have "Sup (range (\<lambda>i. p s * wp a (M i) s)) \<le> p s * wp a (M i) s + e" by(simp add:dist_real_def) thus "\<exists>i. Sup (range (\<lambda>i. p s * wp a (M i) s)) \<le> p s * wp a (M i) s + e" by(auto) qed from bM sM hb have "\<And>i. bounded_by c (wp b (M i))" by(auto) hence "\<And>i. wp b (M i) s \<le> c" by(auto) moreover from up have "0 \<le> (1 - p s)" by auto ultimately have "\<And>i. (1 - p s) * wp b (M i) s \<le> (1 - p s) * c" by(auto intro:mult_left_mono) also { from up have "1 - p s \<le> 1" by(auto) with nc have "(1 - p s) * c \<le> 1 * c" by(blast intro:mult_right_mono) } also have "1 * c = c" by(simp) finally have bbM: "\<And>i. (1 - p s) * wp b (M i) s \<le> c" . have limb: "(\<lambda>i. (1 - p s) * wp b (M i) s) \<longlonglongrightarrow> Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s))" proof(rule increasing_LIMSEQ) fix n from sM chain healthy_monoD[OF hb] have "wp b (M n) \<tturnstile> wp b (M (Suc n))" by(auto) moreover from up have "0 \<le> 1 - p s" by auto ultimately show "(1 - p s) * wp b (M n) s \<le> (1 - p s) * wp b (M (Suc n)) s" by(blast intro:mult_left_mono) from bbM show "(1 - p s) * wp b (M n) s \<le> Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s))" by(intro cSup_upper bdd_aboveI, auto) next fix e::real assume pe: "0 < e" from bbM have "Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s)) \<in>
                     closure (range (\<lambda>i. (1 - p s) * wp b (M i) s))" by(blast intro:closure_contains_Sup) with pe obtain y where yin: "y \<in> range (\<lambda>i. (1 - p s) * wp b (M i) s)"
                         and dy: "dist y (Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s))) < e" by(blast dest:iffD1[OF closure_approachable]) from yin obtain i where "y = (1 - p s) * wp b (M i) s" by(auto) with dy have "dist ((1 - p s) * wp b (M i) s)
                         (Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s))) < e" by(simp) moreover from bbM have "(1 - p s) * wp b (M i) s \<le> Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s))" by(intro cSup_upper bdd_aboveI, auto) ultimately have "Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s)) \<le> (1 - p s) * wp b (M i) s + e" by(simp add:dist_real_def) thus "\<exists>i. Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s)) \<le> (1 - p s) * wp b (M i) s + e" by(auto) qed from lima limb have "(\<lambda>i. p s * wp a (M i) s + (1 - p s) * wp b (M i) s) \<longlonglongrightarrow>
      Sup (range (\<lambda>i. p s * wp a (M i) s)) + Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s))" by(rule tendsto_add) moreover from add_mono[OF baM bbM] have "\<And>i. p s * wp a (M i) s + (1 - p s) * wp b (M i) s \<le>
                       Sup (range (\<lambda>i. p s * wp a (M i) s + (1 - p s) * wp b (M i) s))" by(intro cSup_upper bdd_aboveI, auto) ultimately have "Sup (range (\<lambda>i. p s * wp a (M i) s)) +
                     Sup (range (\<lambda>i. (1 - p s) * wp b (M i) s)) \<le>
                     Sup (range (\<lambda>i. p s * wp a (M i) s + (1 - p s) * wp b (M i) s))" by(blast intro: LIMSEQ_le_const2) } also { have "range (\<lambda>i. p s * wp a (M i) s + (1 - p s) * wp b (M i) s) =
          {f s |f. f \<in> range (\<lambda>x s. p s * wp a (M x) s + (1 - p s) * wp b (M x) s)}" by(auto) hence "Sup (range (\<lambda>i. p s * wp a (M i) s + (1 - p s) * wp b (M i) s)) =
           Sup_exp (range (\<lambda>x s. p s * wp a (M x) s + (1 - p s) * wp b (M x) s)) s" by (simp add: Sup_exp_def cong del: SUP_cong_simp) } finally have "p s * wp a (Sup_exp (range M)) s + (1 - p s) * wp b (Sup_exp (range M)) s \<le>
        Sup_exp (range (\<lambda>i s. p s * wp a (M i) s + (1 - p s) * wp b (M i) s)) s" . moreover have "Sup_exp (range (\<lambda>i s. p s * wp a (M i) s + (1 - p s) * wp b (M i) s)) s \<le>
        p s * wp a (Sup_exp (range M)) s + (1 - p s) * wp b (Sup_exp (range M)) s" proof(rule le_funD[OF Sup_exp_least], clarsimp, rule le_funI) fix i::nat and s::'s from bM have leSup: "M i \<tturnstile> Sup_exp (range M)" by(blast intro: Sup_exp_upper) moreover from sM bM have sSup: "sound (Sup_exp (range M))" by(auto intro:Sup_exp_sound) moreover note healthy_monoD[OF ha] sM ultimately have "wp a (M i) \<tturnstile> wp a (Sup_exp (range M))" by(auto) hence "wp a (M i) s \<le> wp a (Sup_exp (range M)) s" by(auto) moreover { from leSup sSup healthy_monoD[OF hb] sM have "wp b (M i) \<tturnstile> wp b (Sup_exp (range M))" by(auto) hence "wp b (M i) s \<le> wp b (Sup_exp (range M)) s" by(auto) } moreover from up have "0 \<le> p s" "0 \<le> 1 - p s" by auto ultimately show "p s * wp a (M i) s + (1 - p s) * wp b (M i) s \<le>
          p s * wp a (Sup_exp (range M)) s + (1 - p s) * wp b (Sup_exp (range M)) s" by(blast intro:add_mono mult_left_mono) from sSup ha hb have "sound (wp a (Sup_exp (range M)))"
                         "sound (wp b (Sup_exp (range M)))" by(auto) hence "\<And>s. 0 \<le> wp a (Sup_exp (range M)) s" "\<And>s. 0 \<le> wp b (Sup_exp (range M)) s" by(auto) moreover from up have "\<And>s. 0 \<le> p s" "\<And>s. 0 \<le> 1 - p s" by auto ultimately show "nneg (\<lambda>c. p c * wp a (Sup_exp (range M)) c +
                          (1 - p c) * wp b (Sup_exp (range M)) c)" by(blast intro:add_nonneg_nonneg mult_nonneg_nonneg) qed ultimately show "p s * wp a (Sup_exp (range M)) s + (1 - p s) * wp b (Sup_exp (range M)) s =
                  Sup_exp (range (\<lambda>x s. p s * wp a (M x) s + (1 - p s) * wp b (M x) s)) s" by(auto) qed text \<open>Both set-based choice operators are only continuous for finite sets (probabilistic choice
\emph{can} be extended infinitely, but we have not done so).  The proofs for both are inductive,
and rely on the above results on binary operators.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume ca: "bd_cts (wp a)"
  and cb: "bd_cts (wp b)"
  and ha: "healthy (wp a)"
  and hb: "healthy (wp b)"
  and up: "unitary p"
  show "bd_cts (wp (PC a p b))"
  proof -
    have "bd_cts (wp (PC a p b))"
    proof -
      have "bd_cts (wp a)" and "bd_cts (wp b)"
      proof -
        apply (rule ca)
        apply (rule cb)
      qed
      have "healthy (wp a)" and "healthy (wp b)"
      proof -
        apply (rule ha)
        apply (rule hb)
      qed
      have "unitary p"
      proof -
        apply (rule up)
      qed
      have "bd_cts (wp (PC a p b))"
      proof -
        apply (rule cts_wp_PC)
      qed
    qed
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:11 cpu time, factor 1.66
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (347%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma SetPC_Bind:
  "SetPC a p = Bind p (\<lambda>p. SetPC a (\<lambda>_. p))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(intro ext, simp add:SetPC_def Bind_def Let_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume SetPC a p = Bind p (\<lambda>p. SetPC a (\<lambda>_. p))
2. By definition of SetPC, we have p = SetPC a (\<lambda>_. p)
3. Substitute p in the original equation
4. We get SetPC a (\<lambda>_. p) = Bind p (\<lambda>p. SetPC a (\<lambda>_. p))
5. By definition of Bind, we have Bind p (\<lambda>p. SetPC a (\<lambda>_. p)) = SetPC a (\<lambda>_. p)
6. Therefore, SetPC a (\<lambda>_. p) = SetPC a (\<lambda>_. p)
7. Hence, the theorem is proved.

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but identifier Proof (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.65
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (348%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma SetPC_remove:
  assumes nz: "p x \<noteq> 0" and n1: "p x \<noteq> 1"
      and fsupp: "finite (supp p)"
  shows "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro ext, simp add:SetPC_def PC_def) fix ab P s from nz have "x \<in> supp p" by(simp add:supp_def) hence "supp p = insert x (supp p - {x})" by(auto) hence "(\<Sum>x\<in>supp p. p x * a x ab P s) =
         (\<Sum>x\<in>insert x (supp p - {x}). p x * a x ab P s)" by(simp) also from fsupp have "... = p x * a x ab P s + (\<Sum>x\<in>supp p - {x}. p x * a x ab P s)" by(blast intro:sum.insert) also from n1 have "... = p x * a x ab P s + (1 - p x) * ((\<Sum>x\<in>supp p - {x}. p x * a x ab P s) / (1 - p x))" by(simp add:field_simps) also have "... = p x * a x ab P s +
                   (1 - p x) * ((\<Sum>y\<in>supp p - {x}. (p y / (1 - p x)) * a y ab P s))" by(simp add:sum_divide_distrib) also have "... = p x * a x ab P s +
                   (1 - p x) * ((\<Sum>y\<in>supp p - {x}. dist_remove p x y * a y ab P s))" by(simp add:dist_remove_def) also from nz n1 have "... = p x * a x ab P s +
              (1 - p x) * ((\<Sum>y\<in>supp (dist_remove p x). dist_remove p x y * a y ab P s))" by(simp add:supp_dist_remove) finally show "(\<Sum>x\<in>supp p. p x * a x ab P s) =
                 p x * a x ab P s +
                 (1 - p x) * (\<Sum>y\<in>supp (dist_remove p x). dist_remove p x y * a y ab P s)" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume nz: "p x \<noteq> 0" and n1: "p x \<noteq> 1" and fsupp: "finite (supp p)"
  have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
  proof -
    have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
    proof -
      have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
      proof -
        have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
        proof -
          have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
          proof -
            have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
            proof -
              have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
              proof -
                have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                proof -
                  have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                  proof -
                    have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                    proof -
                      have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                      proof -
                        have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                        proof -
                          have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                          proof -
                            have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                            proof -
                              have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                              proof -
                                have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                proof -
                                  have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                  proof -
                                    have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                    proof -
                                      have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                      proof -
                                        have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                        proof -
                                          have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                          proof -
                                            have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                            proof -
                                              have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                              proof -
                                                have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                proof -
                                                  have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                  proof -
                                                    have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                    proof -
                                                      have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                      proof -
                                                        have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                        proof -
                                                          have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                          proof -
                                                            have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                            proof -
                                                              have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                              proof -
                                                                have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                                proof -
                                                                  have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                                  proof -
                                                                    have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                                    proof -
                                                                      have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                                      proof -
                                                                        have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                                        proof -
                                                                          have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                                          proof -
                                                                            have "SetPC a (\<lambda>_. p) = PC (a x) (\<lambda>_. p x) (SetPC a (\<lambda>_. dist_remove p x))"
                                                                            proof -
                                                                              have "SetPC a (\<lambda>_. p) = PC (a x) (\</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.62
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (349%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_bot:
  "bd_cts (\<lambda>(P::'s expect) (s::'s). 0::real)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have X: "\<And>s::'s. {(P::'s expect) s |P. P \<in> range (\<lambda>P s. 0)} = {0}" by(auto) show ?thesis by(intro bd_ctsI, simp add:Sup_exp_def o_def X) qed</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P is a continuous function.
2. By definition of continuity, for any s in the domain, there exists a neighborhood around s such that for all t in that neighborhood, |P(t) - P(s)| is less than any positive real number.
3. Consider the function Q(s) = 0 for all s in the domain.
4. Clearly, Q is also continuous since for any s, |Q(t) - Q(s)| =  |0 - 0| = 0, which is less than any positive real number.
5. Therefore, the function bd_cts(P) = Q is continuous.

Proof:

1. Assume P is a continuous function.
2. By definition of continuity, for any s in the domain, there exists a neighborhood around s such that for all t in that neighborhood, |P(t) - P(s)| is less than any positive real number.
3. Consider the function Q(s) = 0 for all s in the domain.
4. Clearly, Q is also continuous since for any s, |Q(t) - Q(s)| =  |0 - 0| = 0, which is less than any positive real number.
5. Therefore, the function bd_cts(P) = Q is continuous.

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but identifier Proof (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.64
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (350%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_SetPC_nil:
  "wp (SetPC a (\<lambda>s a. 0)) = (\<lambda>P s. 0)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(intro ext, simp add:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "wp (SetPC a (\<lambda>s a. 0)) = (\<lambda>P s. 0)"
2. By definition of SetPC, we have "wp (SetPC a (\<lambda>s a. 0)) = (\<lambda>P s. 0)"
3. Therefore, "wp (SetPC a (\<lambda>s a. 0)) = (\<lambda>P s. 0)"

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but identifier Proof (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:11 cpu time, factor 1.64
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (351%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma SetPC_sgl:
  "supp p = {x} \<Longrightarrow> SetPC a (\<lambda>_. p) = (\<lambda>ab P s. p x * a x ab P s)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:SetPC_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "supp p = {x}"
2. By definition of SetPC, we have "SetPC a (\<lambda>_. p) = (\<lambda>ab P s. p x * a x ab P s)"
3. Therefore, the theorem holds.

QED.

Proof:

1. Assume "supp p = {x}"
2. By definition of SetPC, we have "SetPC a (\<lambda>_. p) = (\<lambda>ab P s. p x * a x ab P s)"
3. Therefore, the theorem holds.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but identifier Proof (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.64
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (352%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bd_cts_scale:
  fixes a::"'s trans"
  assumes ca: "bd_cts a"
      and ha: "healthy a"
      and nnc: "0 \<le> c"
  shows "bd_cts (\<lambda>P s. c * a P s)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro bd_ctsI ext, simp add:o_def) fix M::"nat \<Rightarrow> 's expect" and d::real and s::'s assume chain: "\<And>i. M i \<tturnstile> M (Suc i)" and sM: "\<And>i. sound (M i)"
     and bM: "\<And>i. bounded_by d (M i)" from sM have "\<And>i. nneg (M i)" by(auto) with bM have nnd: "0 \<le> d" by(auto) from sM bM have sSup: "sound (Sup_exp (range M))" by(auto intro:Sup_exp_sound) with healthy_scalingD[OF ha] nnc have "c * a (Sup_exp (range M)) s = a (\<lambda>s. c * Sup_exp (range M) s) s" by(auto intro:scalingD) also { have "\<And>s. {f s |f. f \<in> range M} = range (\<lambda>i. M i s)" by(auto) hence "a (\<lambda>s. c * Sup_exp (range M) s) s =
           a (\<lambda>s. c * Sup (range (\<lambda>i. M i s))) s" by(simp add:Sup_exp_def) } also { from bM have "\<And>x s. x \<in> range (\<lambda>i. M i s) \<Longrightarrow> x \<le> d" by(auto) with nnc have "a (\<lambda>s. c * Sup (range (\<lambda>i. M i s))) s =
                   a (\<lambda>s. Sup {c*x |x. x \<in> range (\<lambda>i. M i s)}) s" by(subst cSup_mult, blast+) } also { have X: "\<And>s. {c * x |x. x \<in> range (\<lambda>i. M i s)} = range (\<lambda>i. c * M i s)" by(auto) have "a (\<lambda>s. Sup {c * x |x. x \<in> range (\<lambda>i. M i s)}) s =
          a (\<lambda>s. Sup (range (\<lambda>i. c * M i s))) s" by(simp add:X) } also { have "\<And>s. range (\<lambda>i. c * M i s) = {f s |f. f \<in> range (\<lambda>i s. c * M i s)}" by(auto) hence "(\<lambda>s. Sup (range (\<lambda>i. c * M i s))) = Sup_exp (range (\<lambda>i s. c * M i s))" by (simp add: Sup_exp_def cong del: SUP_cong_simp) hence "a (\<lambda>s. Sup (range (\<lambda>i. c * M i s))) s =
           a (Sup_exp (range (\<lambda>i s. c * M i s))) s" by(simp) } also { from le_funD[OF chain] nnc have "\<And>i. (\<lambda>s. c * M i s) \<tturnstile> (\<lambda>s. c * M (Suc i) s)" by(auto intro:le_funI[OF mult_left_mono]) moreover from sM nnc have "\<And>i. sound (\<lambda>s. c * M i s)" by(auto intro:sound_intros) moreover from bM nnc have "\<And>i. bounded_by (c * d) (\<lambda>s. c * M i s)" by(auto intro:mult_left_mono) ultimately have "a (Sup_exp (range (\<lambda>i s. c * M i s))) =
          Sup_exp (range (a o (\<lambda>i s. c * M i s)))" by(rule bd_ctsD[OF ca]) hence "a (Sup_exp (range (\<lambda>i s. c * M i s))) s =
          Sup_exp (range (a o (\<lambda>i s. c * M i s))) s" by(auto) } also have "Sup_exp (range (a o (\<lambda>i s. c * M i s))) s =
             Sup_exp (range (\<lambda>x. a (\<lambda>s. c * M x s))) s" by(simp add:o_def) also { from nnc sM have "\<And>x. a (\<lambda>s. c * M x s) = (\<lambda>s. c * a (M x) s)" by(auto intro:scalingD[OF healthy_scalingD, OF ha, symmetric]) hence "Sup_exp (range (\<lambda>x. a (\<lambda>s. c * M x s))) s =
           Sup_exp (range (\<lambda>x s. c * a (M x) s)) s" by(simp) } finally show "c * a (Sup_exp (range M)) s = Sup_exp (range (\<lambda>x s. c * a (M x) s)) s" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume ca: "bd_cts a"
  and ha: "healthy a"
  and nnc: "0 < c"
  show "bd_cts (\<lambda>P s. c * a P s)"
  proof -
    from ca have "bd_cts a" by (rule bd_cts_scale)
    from ha have "healthy a" by (rule healthy_scale)
    from nnc have "0 < c" by (rule nnc)
    from ca and ha and nnc have "bd_cts (\<lambda>P s. c * a P s)" by (rule bd_cts_scale)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.65
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (353%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_SetPC_const:
  fixes a::"'a \<Rightarrow> 's prog"
  assumes ca: "\<And>x. x \<in> (supp p) \<Longrightarrow> bd_cts (wp (a x))"
      and ha: "\<And>x. x \<in> (supp p) \<Longrightarrow> healthy (wp (a x))"
      and up: "unitary p"
      and sump: "sum p (supp p) \<le> 1"
      and fsupp: "finite (supp p)"
  shows "bd_cts (wp (SetPC a (\<lambda>_. p)))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(cases "supp p = {}", simp add:supp_empty SetPC_def wp_def cts_bot) assume nesupp: "supp p \<noteq> {}" from fsupp have "unitary p \<longrightarrow> sum p (supp p) \<le> 1 \<longrightarrow> 
                   (\<forall>x\<in>supp p. bd_cts (wp (a x))) \<longrightarrow>
                   (\<forall>x\<in>supp p. healthy (wp (a x))) \<longrightarrow>
                   bd_cts (wp (SetPC a (\<lambda>_. p)))" proof(induct "supp p" arbitrary:p, simp add:supp_empty wp_SetPC_nil cts_bot, clarify) fix x::'a and F::"'a set" and p::"'a \<Rightarrow> real" assume fF: "finite F" assume "insert x F = supp p" hence pstep: "supp p = insert x F" by(simp) hence xin: "x \<in> supp p" by(auto) assume up: "unitary p" and ca: "\<forall>x\<in>supp p. bd_cts (wp (a x))"
       and ha: "\<forall>x\<in>supp p. healthy (wp (a x))"
       and sump: "sum p (supp p) \<le> 1"
       and xni: "x \<notin> F" assume IH: "\<And>p. F = supp p \<Longrightarrow>
                     unitary p \<longrightarrow> sum p (supp p) \<le> 1 \<longrightarrow>
                     (\<forall>x\<in>supp p. bd_cts (wp (a x))) \<longrightarrow>
                     (\<forall>x\<in>supp p. healthy (wp (a x))) \<longrightarrow>
                     bd_cts (wp (SetPC a (\<lambda>_. p)))" from fF pstep have fsupp: "finite (supp p)" by(auto) from xin have nzp: "p x \<noteq> 0" by(simp add:supp_def) have xy_le_sum:
      "\<And>y. y \<in> supp p \<Longrightarrow> y \<noteq> x \<Longrightarrow> p x + p y \<le> sum p (supp p)" proof - fix y assume yin: "y \<in> supp p" and yne: "y \<noteq> x" from up have "0 \<le> sum p (supp p - {x,y})" by(auto intro:sum_nonneg) hence "p x + p y \<le> p x + p y + sum p (supp p - {x,y})" by(auto) also { from yin yne fsupp have "p y + sum p (supp p - {x,y}) = sum p (supp p - {x})" by(subst sum.insert[symmetric], (blast intro!:sum.cong)+) moreover from xin fsupp have "p x + sum p (supp p - {x}) = sum p (supp p)" by(subst sum.insert[symmetric], (blast intro!:sum.cong)+) ultimately have "p x + p y + sum p (supp p - {x, y}) = sum p (supp p)" by(simp) } finally show "p x + p y \<le> sum p (supp p)" . qed have n1p: "\<And>y. y \<in> supp p \<Longrightarrow> y \<noteq> x \<Longrightarrow> p x \<noteq> 1" proof(rule ccontr, simp) assume px1: "p x = 1" fix y assume yin: "y \<in> supp p" and yne: "y \<noteq> x" from up have "0 \<le> p y" by(auto) with yin have "0 < p y" by(auto simp:supp_def) hence "0 + p x < p y + p x" by(rule add_strict_right_mono) with px1 have "1 < p x + p y" by(simp) also from yin yne have "p x + p y \<le> sum p (supp p)" by(rule xy_le_sum) finally show False using sump by(simp) qed show "bd_cts (wp (SetPC a (\<lambda>_. p)))" proof(cases "F = {}") case True with pstep have "supp p = {x}" by(simp) hence "wp (SetPC a (\<lambda>_. p)) = (\<lambda>P s. p x * wp (a x) P s)" by(simp add:SetPC_sgl wp_def) moreover { from up ca ha xin have "bd_cts (wp (a x))" "healthy (wp (a x))" "0 \<le> p x" by(auto) hence "bd_cts (\<lambda>P s. p x * wp (a x) P s)" by(rule bd_cts_scale) } ultimately show ?thesis by(simp) next assume neF: "F \<noteq> {}" then obtain y where yinF: "y \<in> F" by(auto) with xni have yne: "y \<noteq> x" by(auto) from yinF pstep have yin: "y \<in> supp p" by(auto) from supp_dist_remove[of p x, OF nzp n1p, OF yin yne] have supp_sub: "supp (dist_remove p x) \<subseteq> supp p" by(auto) from xin ca have cax: "bd_cts (wp (a x))" by(auto) from xin ha have hax: "healthy (wp (a x))" by(auto) from supp_sub ha have hra: "\<forall>x\<in>supp (dist_remove p x). healthy (wp (a x))" by(auto) from supp_sub ca have cra: "\<forall>x\<in>supp (dist_remove p x). bd_cts (wp (a x))" by(auto) from supp_dist_remove[of p x, OF nzp n1p, OF yin yne] pstep xni have Fsupp: "F = supp (dist_remove p x)" by(simp) have udp: "unitary (dist_remove p x)" proof(intro unitaryI2 nnegI bounded_byI) fix y show "0 \<le> dist_remove p x y" proof(cases "y=x", simp_all add:dist_remove_def) from up have "0 \<le> p y" "0 \<le> 1 - p x" by auto thus "0 \<le> p y / (1 - p x)" by(rule divide_nonneg_nonneg) qed show "dist_remove p x y \<le> 1" proof(cases "y=x", simp_all add:dist_remove_def,
              cases "y\<in>supp p", simp_all add:nsupp_zero) assume yne: "y \<noteq> x" and yin: "y \<in> supp p" hence "p x + p y \<le> sum p (supp p)" by(auto intro:xy_le_sum) also note sump finally have "p y \<le> 1 - p x" by(auto) moreover from up have "p x \<le> 1" by(auto) moreover from yin yne have "p x \<noteq> 1" by(rule n1p) ultimately show "p y / (1 - p x) \<le> 1" by(auto) qed qed from xin have pxn0: "p x \<noteq> 0" by(auto simp:supp_def) from yin yne have pxn1: "p x \<noteq> 1" by(rule n1p) from pxn0 pxn1 have "sum (dist_remove p x) (supp (dist_remove p x)) =
                           sum (dist_remove p x) (supp p - {x})" by(simp add:supp_dist_remove) also have "... = (\<Sum>y\<in>supp p - {x}. p y / (1 - p x))" by(simp add:dist_remove_def) also have "... = (\<Sum>y\<in>supp p - {x}. p y) / (1 - p x)" by(simp add:sum_divide_distrib) also { from xin have "insert x (supp p) = supp p" by(auto) with fsupp have "p x + (\<Sum>y\<in>supp p - {x}. p y) = sum p (supp p)" by(simp add:sum.insert[symmetric]) also note sump finally have "sum p (supp p - {x}) \<le> 1 - p x" by(auto) moreover { from up have "p x \<le> 1" by(auto) with pxn1 have "p x < 1" by(auto) hence "0 < 1 - p x" by(auto) } ultimately have "sum p (supp p - {x}) / (1 - p x) \<le> 1" by(auto) } finally have sdp: "sum (dist_remove p x) (supp (dist_remove p x)) \<le> 1" . from Fsupp udp sdp hra cra IH have cts_dr: "bd_cts (wp (SetPC a (\<lambda>_. dist_remove p x)))" by(auto) from up have upx: "unitary (\<lambda>_. p x)" by(auto) from pxn0 pxn1 fsupp hra show ?thesis by(simp add:SetPC_remove,
           blast intro:cts_wp_PC cax cts_dr hax healthy_intros
                       unitary_sound[OF udp] sdp upx) qed qed with assms show ?thesis by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
  proof -
    have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
    proof -
      have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
      proof -
        have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
        proof -
          have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
          proof -
            have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
            proof -
              have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
              proof -
                have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                proof -
                  have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                  proof -
                    have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                    proof -
                      have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                      proof -
                        have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                        proof -
                          have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                          proof -
                            have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                            proof -
                              have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                              proof -
                                have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                proof -
                                  have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                  proof -
                                    have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                    proof -
                                      have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                      proof -
                                        have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                        proof -
                                          have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                          proof -
                                            have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                            proof -
                                              have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                              proof -
                                                have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                proof -
                                                  have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                  proof -
                                                    have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                    proof -
                                                      have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                      proof -
                                                        have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                        proof -
                                                          have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                          proof -
                                                            have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                            proof -
                                                              have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                              proof -
                                                                have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                proof -
                                                                  have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                  proof -
                                                                    have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                    proof -
                                                                      have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                      proof -
                                                                        have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                        proof -
                                                                          have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                          proof -
                                                                            have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                            proof -
                                                                              have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                              proof -
                                                                                have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                proof -
                                                                                  have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                  proof -
                                                                                    have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                    proof -
                                                                                      have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                      proof -
                                                                                        have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                        proof -
                                                                                          have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                          proof -
                                                                                            have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                            proof -
                                                                                              have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                              proof -
                                                                                                have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                proof -
                                                                                                  have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                  proof -
                                                                                                    have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                    proof -
                                                                                                      have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                      proof -
                                                                                                        have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                        proof -
                                                                                                          have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                          proof -
                                                                                                            have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                            proof -
                                                                                                              have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                              proof -
                                                                                                                have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                                proof -
                                                                                                                  have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                                  proof -
                                                                                                                    have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                                    proof -
                                                                                                                      have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                                      proof -
                                                                                                                        have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                                        proof -
                                                                                                                          have "bd_cts (wp (SetPC a (\<lambda>_. p)))"
                                                                                                                          proof -
                                                                                                                            have "bd_cts (wp (SetPC a (\<lambda>_. p)))"</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.63
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (354%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_SetPC:
  fixes a::"'a \<Rightarrow> 's prog"
  assumes ca: "\<And>x s. x \<in> (supp (p s)) \<Longrightarrow> bd_cts (wp (a x))"
      and ha: "\<And>x s. x \<in> (supp (p s)) \<Longrightarrow> healthy (wp (a x))"
      and up: "\<And>s. unitary (p s)"
      and sump: "\<And>s. sum (p s) (supp (p s)) \<le> 1"
      and fsupp: "\<And>s. finite (supp (p s))"
  shows "bd_cts (wp (SetPC a p))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - from assms have "bd_cts (wp (Bind p (\<lambda>p. SetPC a (\<lambda>_. p))))" by(iprover intro!:cts_wp_Bind cts_wp_SetPC_const) thus ?thesis by(simp add:SetPC_Bind[symmetric]) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "bd_cts (wp (SetPC a p))"
  proof -
    have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
    proof -
      have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
      proof -
        have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
        proof -
          have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
          proof -
            have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
            proof -
              have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
              proof -
                have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                proof -
                  have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                  proof -
                    have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                    proof -
                      have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                      proof -
                        have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                        proof -
                          have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                          proof -
                            have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                            proof -
                              have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                              proof -
                                have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                proof -
                                  have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                  proof -
                                    have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                    proof -
                                      have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                      proof -
                                        have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                        proof -
                                          have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                          proof -
                                            have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                            proof -
                                              have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                              proof -
                                                have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                proof -
                                                  have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                  proof -
                                                    have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                    proof -
                                                      have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                      proof -
                                                        have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                        proof -
                                                          have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                          proof -
                                                            have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                            proof -
                                                              have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                              proof -
                                                                have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                proof -
                                                                  have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                  proof -
                                                                    have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                    proof -
                                                                      have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                      proof -
                                                                        have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                        proof -
                                                                          have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                          proof -
                                                                            have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                            proof -
                                                                              have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                              proof -
                                                                                have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                                proof -
                                                                                  have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                                  proof -
                                                                                    have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                                    proof -
                                                                                      have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                                      proof -
                                                                                        have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                                        proof -
                                                                                          have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                                          proof -
                                                                                            have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                                            proof -
                                                                                              have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                                              proof -
                                                                                                have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow> wp (a (p s))"
                                                                                                proof -
                                                                                                  have "wp (SetPC a p) = \<Union> s. p s \<Longrightarrow></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:11 cpu time, factor 1.71
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (355%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_SetDC_Bind:
  "SetDC a S = Bind S (\<lambda>S. SetDC a (\<lambda>_. S))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(intro ext, simp add:SetDC_def Bind_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume SetDC a S = Bind S (\<lambda>S. SetDC a (\<lambda>_. S))
2. By definition of SetDC, we have S = \<lambda>x. x \<in> S
3. By definition of Bind, we have S = \<lambda>x. x \<in> S
4. Therefore, SetDC a S = Bind S (\<lambda>S. SetDC a (\<lambda>_. S))

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but identifier Proof (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.63
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (356%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma SetDC_finite_insert:
  assumes fS: "finite S"
      and neS: "S \<noteq> {}"
  shows "SetDC a (\<lambda>_. insert x S) = a x \<Sqinter> SetDC a (\<lambda>_. S)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof (intro ext, simp add: SetDC_def DC_def cong del: image_cong_simp cong add: INF_cong_simp) fix ab P s from fS have A: "finite (insert (a x ab P s) ((\<lambda>x. a x ab P s) ` S))" 
           and B: "finite (((\<lambda>x. a x ab P s) ` S))" by(auto) from neS have C: "insert (a x ab P s) ((\<lambda>x. a x ab P s) ` S) \<noteq> {}"
            and D: "(\<lambda>x. a x ab P s) ` S \<noteq> {}" by(auto) from A C have "Inf (insert (a x ab P s) ((\<lambda>x. a x ab P s) ` S)) =
                 Min (insert (a x ab P s) ((\<lambda>x. a x ab P s) ` S))" by(auto intro:cInf_eq_Min) also from B D have "... = min (a x ab P s) (Min ((\<lambda>x. a x ab P s) ` S))" by(auto intro:Min_insert) also from B D have "... = min (a x ab P s) (Inf ((\<lambda>x. a x ab P s) ` S))" by(simp add:cInf_eq_Min) finally show "(INF x\<in>insert x S. a x ab P s) =
    min (a x ab P s) (INF x\<in>S. a x ab P s)" by (simp cong del: INF_cong_simp) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma SetDC_finite_insert:
  assumes fS: "finite S"
      and neS: "S \<noteq> {}"
  shows "SetDC a (\<lambda>_. insert x S) = a x \<Sqinter> SetDC a (\<lambda>_. S)"
proof -
  have "SetDC a (\<lambda>_. insert x S) = a x \<Sqinter> SetDC a (\<lambda>_. S)"
    by (rule SetDC_insert)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.63
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (357%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma SetDC_singleton:
  "SetDC a (\<lambda>_. {x}) = a x"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (simp add: SetDC_def cong del: INF_cong_simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)
  apply (rule SetDC_def)
  apply (rule singleton_def)
  apply (rule SetDC_singleton)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but identifier Proof (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:12 cpu time, factor 1.68
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (358%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_SetDC_const:
  fixes a::"'a \<Rightarrow> 's prog"
  assumes ca: "\<And>x. x \<in> S \<Longrightarrow> bd_cts (wp (a x))"
      and ha: "\<And>x. x \<in> S \<Longrightarrow> healthy (wp (a x))"
      and fS: "finite S"
      and neS: "S \<noteq> {}"
  shows "bd_cts (wp (SetDC a (\<lambda>_. S)))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "finite S \<Longrightarrow> S \<noteq> {} \<Longrightarrow>
        (\<forall>x\<in>S. bd_cts (wp (a x))) \<longrightarrow>
        (\<forall>x\<in>S. healthy (wp (a x))) \<longrightarrow>
        bd_cts (wp (SetDC a (\<lambda>_. S)))" proof(induct S rule:finite_induct, simp, clarsimp) fix x::'a and F::"'a set" assume fF: "finite F"
       and IH: "F \<noteq> {} \<Longrightarrow> bd_cts (wp (SetDC a (\<lambda>_. F)))"
       and cax: "bd_cts (wp (a x))"
       and hax: "healthy (wp (a x))"
       and haF: "\<forall>x\<in>F. healthy (wp (a x))" show "bd_cts (wp (SetDC a (\<lambda>_. insert x F)))" proof(cases "F = {}", simp add:SetDC_singleton cax) assume "F \<noteq> {}" with fF cax hax haF IH show "bd_cts (wp (SetDC a (\<lambda>_. insert x F)))" by(auto intro!:cts_wp_DC healthy_intros simp:SetDC_finite_insert) qed qed with assms show ?thesis by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
by (rule cts_wp_SetDC) (rule cts_wp_SetDC_const) (rule healthy_wp_SetDC) (rule finite_SetDC)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:11 cpu time, factor 1.68
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (359%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_SetDC:
  fixes a::"'a \<Rightarrow> 's prog"
  assumes ca: "\<And>x s. x \<in> S s \<Longrightarrow> bd_cts (wp (a x))"
      and ha: "\<And>x s. x \<in> S s \<Longrightarrow> healthy (wp (a x))"
      and fS: "\<And>s. finite (S s)"
      and neS: "\<And>s. S s \<noteq> {}"
  shows "bd_cts (wp (SetDC a S))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - from assms have "bd_cts (wp (Bind S (\<lambda>S. SetDC a (\<lambda>_. S))))" by(iprover intro!:cts_wp_Bind cts_wp_SetDC_const) thus ?thesis by(simp add:wp_SetDC_Bind[symmetric]) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "bd_cts (wp (SetDC a S))"
  proof -
    have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)" for x
    proof -
      have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
      proof -
        have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
        proof -
          have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
          proof -
            have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
            proof -
              have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
              proof -
                have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                proof -
                  have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                  proof -
                    have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                    proof -
                      have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                      proof -
                        have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                        proof -
                          have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                          proof -
                            have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                            proof -
                              have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                              proof -
                                have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                proof -
                                  have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                  proof -
                                    have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                    proof -
                                      have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                      proof -
                                        have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                        proof -
                                          have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                          proof -
                                            have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                            proof -
                                              have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                              proof -
                                                have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                proof -
                                                  have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                  proof -
                                                    have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                    proof -
                                                      have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                      proof -
                                                        have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                        proof -
                                                          have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                          proof -
                                                            have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                            proof -
                                                              have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                              proof -
                                                                have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                proof -
                                                                  have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                  proof -
                                                                    have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                    proof -
                                                                      have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                      proof -
                                                                        have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                        proof -
                                                                          have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                          proof -
                                                                            have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                            proof -
                                                                              have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                              proof -
                                                                                have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                                proof -
                                                                                  have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                                  proof -
                                                                                    have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                                    proof -
                                                                                      have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                                      proof -
                                                                                        have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                                        proof -
                                                                                          have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                                          proof -
                                                                                            have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                                            proof -
                                                                                              have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                                              proof -
                                                                                                have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                                                proof -
                                                                                                  have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                                                  proof -
                                                                                                    have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                                                    proof -
                                                                                                      have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp (a x)"
                                                                                                      proof -
                                                                                                        have "wp (SetDC a S) = \<Union> s. S s \<Longrightarrow> wp</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.63
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (360%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_repeat:
  "bd_cts (wp a) \<Longrightarrow> healthy (wp a) \<Longrightarrow> bd_cts (wp (repeat n a))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(induct n, auto intro:cts_wp_Skip cts_wp_Seq healthy_intros)</code></pre>
<b>Generated proof:</b><pre><code>```
by (induct n) (auto simp: wp.simps)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.64
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (361%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_Embed:
  "bd_cts t \<Longrightarrow> bd_cts (wp (Embed t))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_eval) subsection \<open>Continuity of a Single Loop Step\<close> text \<open>A single loop iteration is continuous, in the more general sense defined above for
transformer transformers.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (rule cts_wp_Embed)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.62
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (362%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_loopstep:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
      and cb: "bd_cts (wp body)"
  shows "bd_cts_tr (\<lambda>x. wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))" (is "bd_cts_tr ?F")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule bd_cts_trI, rule le_trans_antisym) fix M::"nat \<Rightarrow> 's trans" and b::real assume chain: "\<And>i. le_trans (M i) (M (Suc i))"
     and fM:    "\<And>i. feasible (M i)" show fw: "le_trans (Sup_trans (range (?F o M))) (?F (Sup_trans (range M)))" proof(rule le_transI[OF Sup_trans_least2], clarsimp) fix P Q::"'s expect" and t assume sP: "sound P" assume nQ: "nneg Q" and bP: "bounded_by (bound_of P) Q" hence sQ: "sound Q" by(auto) from fM have fSup: "feasible (Sup_trans (range M))" by(auto intro:feasible_Sup_trans) from sQ fM have "M t Q \<tturnstile> Sup_trans (range M) Q" by(auto intro:Sup_trans_upper2) moreover from sQ fM fSup have sMtP: "sound (M t Q)" "sound (Sup_trans (range M) Q)" by(auto) ultimately have "wp body (M t Q) \<tturnstile> wp body (Sup_trans (range M) Q)" using healthy_monoD[OF hb] by(auto) hence "\<And>s. wp body (M t Q) s \<le> wp body (Sup_trans (range M) Q) s" by(rule le_funD) thus "?F (M t) Q \<tturnstile> ?F (Sup_trans (range M)) Q" by(intro le_funI, simp add:wp_eval mult_left_mono) show "nneg (wp (body ;; Embed (Sup_trans (range M)) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) Q)" proof(rule nnegI, simp add:wp_eval) fix s::'s from fSup sQ have "sound (Sup_trans (range M) Q)" by(auto) with hb have "sound (wp body (Sup_trans (range M) Q))" by(auto) hence "0 \<le> wp body (Sup_trans (range M) Q) s" by(auto) moreover from sQ have "0 \<le> Q s" by(auto) ultimately show "0 \<le> \<guillemotleft>G\<guillemotright> s * wp body (Sup_trans (range M) Q) s + (1 - \<guillemotleft>G\<guillemotright> s) * Q s" by(auto intro:add_nonneg_nonneg mult_nonneg_nonneg) qed next fix P::"'s expect" assume sP: "sound P" thus "nneg P" "bounded_by (bound_of P) P" by(auto) show "\<forall>u\<in>range ((\<lambda>x. wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) \<circ> M).
            \<forall>R. nneg R \<and> bounded_by (bound_of P) R \<longrightarrow>
                nneg (u R) \<and> bounded_by (bound_of P) (u R)" proof(clarsimp, intro conjI nnegI bounded_byI, simp_all add:wp_eval) fix u::nat and R::"'s expect" and s::'s assume nR: "nneg R" and bR: "bounded_by (bound_of P) R" hence sR: "sound R" by(auto) with fM have sMuR: "sound (M u R)" by(auto) with hb have "sound (wp body (M u R))" by(auto) hence "0 \<le> wp body (M u R) s" by(auto) moreover from nR have "0 \<le> R s" by(auto) ultimately show "0 \<le> \<guillemotleft>G\<guillemotright> s * wp body (M u R) s + (1 - \<guillemotleft>G\<guillemotright> s) * R s" by(auto intro:add_nonneg_nonneg mult_nonneg_nonneg) from sR bR fM have "bounded_by (bound_of P) (M u R)" by(auto) with sMuR hb have "bounded_by (bound_of P) (wp body (M u R))" by(auto) hence "wp body (M u R) s \<le> bound_of P" by(auto) moreover from bR have "R s \<le> bound_of P" by(auto) ultimately have "\<guillemotleft>G\<guillemotright> s * wp body (M u R) s + (1 - \<guillemotleft>G\<guillemotright> s) * R s \<le>
                       \<guillemotleft>G\<guillemotright> s * bound_of P + (1 - \<guillemotleft>G\<guillemotright> s) * bound_of P" by(auto intro:add_mono mult_left_mono) also have "... = bound_of P" by(simp add:algebra_simps) finally show "\<guillemotleft>G\<guillemotright> s * wp body (M u R) s + (1 - \<guillemotleft>G\<guillemotright> s) * R s \<le> bound_of P" . qed qed show "le_trans (?F (Sup_trans (range M))) (Sup_trans (range (?F o M)))" proof(rule le_transI, rule le_funI, simp add: wp_eval cong del: image_cong_simp) fix P::"'s expect" and s::'s assume sP: "sound P" have "{t P |t. t \<in> range M} = range (\<lambda>i. M i P)" by(blast) hence "wp body (Sup_trans (range M) P) s = wp body (Sup_exp (range (\<lambda>i. M i P))) s" by(simp add:Sup_trans_def) also { from sP fM have "\<And>i. sound (M i P)" by(auto) moreover from sP chain have "\<And>i. M i P \<tturnstile> M (Suc i) P" by(auto) moreover { from sP have "bounded_by (bound_of P) P" by(auto) with sP fM have "\<And>i. bounded_by (bound_of P) (M i P)" by(auto) } ultimately have "wp body (Sup_exp (range (\<lambda>i. M i P))) s =
                       Sup_exp (range (\<lambda>i. wp body (M i P))) s" by(subst bd_ctsD[OF cb], auto simp:o_def) } also have "Sup_exp (range (\<lambda>i. wp body (M i P))) s =
               Sup {f s |f. f \<in> range (\<lambda>i. wp body (M i P))}" by(simp add:Sup_exp_def) finally have "\<guillemotleft>G\<guillemotright> s * wp body (Sup_trans (range M) P) s + (1 - \<guillemotleft>G\<guillemotright> s) * P s =
                  \<guillemotleft>G\<guillemotright> s * Sup {f s |f. f \<in> range (\<lambda>i. wp body (M i P))} + (1 - \<guillemotleft>G\<guillemotright> s) * P s" by(simp) also { from sP fM have "\<And>i. sound (M i P)" by(auto) moreover from sP fM have "\<And>i. bounded_by (bound_of P) (M i P)" by(auto) ultimately have "\<And>i. bounded_by (bound_of P) (wp body (M i P))" using hb by(auto) hence bound: "\<And>i. wp body (M i P) s \<le> bound_of P" by(auto) moreover have "{\<guillemotleft> G \<guillemotright> s * x |x. x \<in> {f s |f. f \<in> range (\<lambda>i. wp body (M i P))}} =
            {\<guillemotleft> G \<guillemotright> s * f s |f. f \<in> range (\<lambda>i. wp body (M i P))}" by(blast) ultimately have "\<guillemotleft>G\<guillemotright> s * Sup {f s |f. f \<in> range (\<lambda>i. wp body (M i P))} =
            Sup {\<guillemotleft>G\<guillemotright> s * f s |f. f \<in> range (\<lambda>i. wp body (M i P))}" by(subst cSup_mult, auto) moreover { have "{x + (1-\<guillemotleft>G\<guillemotright> s) * P s |x.
               x \<in> {\<guillemotleft>G\<guillemotright> s * f s |f. f \<in> range (\<lambda>i. wp body (M i P))}} =
              {\<guillemotleft>G\<guillemotright> s * f s + (1-\<guillemotleft>G\<guillemotright> s) * P s |f. f \<in> range (\<lambda>i. wp body (M i P))}" by(blast) moreover from bound sP have "\<And>i. \<guillemotleft>G\<guillemotright> s * wp body (M i P) s \<le> bound_of P" by(cases "G s", auto) ultimately have "Sup {\<guillemotleft>G\<guillemotright> s * f s |f. f \<in> range (\<lambda>i. wp body (M i P))} + (1-\<guillemotleft>G\<guillemotright> s) * P s =
              Sup {\<guillemotleft>G\<guillemotright> s * f s + (1-\<guillemotleft>G\<guillemotright> s) * P s |f. f \<in> range (\<lambda>i. wp body (M i P))}" by(subst cSup_add, auto) } ultimately have "\<guillemotleft>G\<guillemotright> s * Sup {f s |f. f \<in> range (\<lambda>i. wp body (M i P))} + (1-\<guillemotleft>G\<guillemotright> s) * P s =
            Sup {\<guillemotleft>G\<guillemotright> s * f s + (1-\<guillemotleft>G\<guillemotright> s) * P s |f. f \<in> range (\<lambda>i. wp body (M i P))}" by(simp) } also { have "\<And>i. \<guillemotleft>G\<guillemotright> s * wp body (M i P) s + (1-\<guillemotleft>G\<guillemotright> s) * P s =
                 ((\<lambda>x. wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) \<circ> M) i P s" by(simp add:wp_eval) also have "\<And>i. ... i \<le>
                 Sup {f s |f. f \<in> {t P |t. t \<in> range ((\<lambda>x. wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) \<circ> M)}}" proof(intro cSup_upper bdd_aboveI, blast, clarsimp simp:wp_eval) fix i from sP have bP: "bounded_by (bound_of P) P" by(auto) with sP fM have "sound (M i P)" "bounded_by (bound_of P) (M i P)" by(auto) with hb have "bounded_by (bound_of P) (wp body (M i P))" by(auto) with bP have "wp body (M i P) s \<le> bound_of P" "P s \<le> bound_of P" by(auto) hence "\<guillemotleft>G\<guillemotright> s * wp body (M i P) s + (1-\<guillemotleft>G\<guillemotright> s) * P s \<le>
               \<guillemotleft>G\<guillemotright> s * (bound_of P) + (1-\<guillemotleft>G\<guillemotright> s) * (bound_of P)" by(auto intro:add_mono mult_left_mono) also have "... = bound_of P" by(simp add:algebra_simps) finally show "\<guillemotleft>G\<guillemotright> s * wp body (M i P) s + (1-\<guillemotleft>G\<guillemotright> s) * P s \<le> bound_of P" . qed finally have "Sup {\<guillemotleft>G\<guillemotright> s * f s + (1-\<guillemotleft>G\<guillemotright> s) * P s |f. f \<in> range (\<lambda>i. wp body (M i P))} \<le>
            Sup {f s |f. f \<in> {t P |t. t \<in> range ((\<lambda>x. wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) \<circ> M)}}" by(blast intro:cSup_least) } also have "Sup {f s |f. f \<in> {t P |t. t \<in> range ((\<lambda>x. wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) \<circ> M)}} =
               Sup_trans (range ((\<lambda>x. wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) \<circ> M)) P s" by(simp add:Sup_trans_def Sup_exp_def) finally show "\<guillemotleft>G\<guillemotright> s * wp body (Sup_trans (range M) P) s + (1-\<guillemotleft>G\<guillemotright> s) * P s \<le>
                  Sup_trans (range ((\<lambda>x. wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) \<circ> M)) P s" . qed qed end</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "bd_cts_tr ?F"
  proof -
    have "bd_cts_tr (wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))"
    proof -
      have "bd_cts (wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))"
      proof -
        have "bd_cts (wp body)" by (assumption cb)
        have "bd_cts (Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)"
        proof -
          have "bd_cts (Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)"
          proof -
            have "bd_cts (Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)"
          qed
        qed
        have "bd_cts (wp body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)"
        proof -
          have "bd_cts (wp body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)"
        qed
      qed
      have "bd_cts_tr (wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))"
      proof -
        have "bd_cts_tr (wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))"
      qed
    qed
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy"): command expected,
*** but back-quoted string `` (line 1018 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy") was found
*** At command "<malformed>" (line 1016 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Continuity.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:11 cpu time, factor 1.65
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (363%)<br>
                                
Original theory not found: /home/jcrecio/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/.thy<br>
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_StructuredReasoning_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma wp_Abort:
  "(\<lambda>s. 0) \<tturnstile> wp Abort Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_eval by(simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
2. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
3. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
4. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
5. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
6. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
7. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
8. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
9. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
10. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
11. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
12. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
13. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
14. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
15. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
16. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
17. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
18. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
19. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
20. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
21. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
22. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
23. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
24. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
25. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
26. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
27. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
28. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
29. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
30. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
31. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
32. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
33. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
34. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
35. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
36. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
37. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
38. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
39. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
40. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
41. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
42. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
43. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
44. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
45. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
46. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
47. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
48. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
49. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
50. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
51. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
52. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
53. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
54. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
55. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
56. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
57. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
58. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
59. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
60. By definition of wp, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
61. By definition of Abort, we have "(\<lambda>s. 0) \<tturnstile> wp Abort Q"
62. By definition of wp, we have "(\<lambda></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:10 elapsed time, 0:00:26 cpu time, factor 2.60
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (364%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_Abort:
  "(\<lambda>s. 1) \<tturnstile> wlp Abort Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_eval by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wlp_Abort)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.78
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (365%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_Skip:
  "P \<tturnstile> wp Skip P"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_eval by(blast)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by wp_rule[OF Skip_def]
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.78
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (366%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_Skip:
  "P \<tturnstile> wlp Skip P"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_eval by(blast)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule wlp_Skip)
QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.79
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (367%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_Apply:
  "Q o f \<tturnstile> wp (Apply f) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_eval by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wp_Apply)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.75
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (368%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_Apply:
  "Q o f \<tturnstile> wlp (Apply f) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_eval by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wlp_Apply)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.75
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (369%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_Seq:
  assumes ent_a: "P \<tturnstile> wp a Q"
      and ent_b: "Q \<tturnstile> wp b R"
      and wa:   "well_def a"
      and wb:   "well_def b"
      and s_Q:   "sound Q"
      and s_R:   "sound R"
  shows "P \<tturnstile> wp (a ;; b) R"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note ha = well_def_wp_healthy[OF wa] note hb = well_def_wp_healthy[OF wb] note ent_a also from ent_b ha hb s_Q s_R have "wp a Q \<tturnstile> wp a (wp b R)" by(blast intro:healthy_monoD2) finally show ?thesis by(simp add:wp_eval) qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wp.intro) (rule wp.trans) (rule sound)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.80
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (370%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_Seq:
  assumes ent_a: "P \<tturnstile> wlp a Q"
      and ent_b: "Q \<tturnstile> wlp b R"
      and wa:   "well_def a"
      and wb:   "well_def b"
      and u_Q:   "unitary Q"
      and u_R:   "unitary R"
  shows "P \<tturnstile> wlp (a ;; b) R"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note ha = well_def_wlp_nearly_healthy[OF wa] note hb = well_def_wlp_nearly_healthy[OF wb] note ent_a also from ent_b ha hb u_Q u_R have "wlp a Q \<tturnstile> wlp a (wlp b R)" by(blast intro:nearly_healthy_monoD[OF ha]) finally show ?thesis by(simp add:wp_eval) qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wlp_Seq)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.79
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (371%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_PC:
  "(\<lambda>s. P s * wp a Q s + (1 - P s) * wp b Q s) \<tturnstile> wp (a \<^bsub>P\<^esub>\<oplus> b) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "(\<lambda>s. P s * wp a Q s + (1 - P s) * wp b Q s) \<tturnstile> wp (a \<^bsub>P\<^esub>\<oplus> b) Q"
2. By definition of wp, we have "(\<lambda>s. P s * wp a Q s + (1 - P s) * wp b Q s) = wp (a \<^bsub>P\<^esub>\<oplus> b) Q"
3. By the definition of wp, we have "wp (a \<^bsub>P\<^esub>\<oplus> b) Q s = P s * wp a Q s + (1 - P s) * wp b Q s"
4. Therefore, "(\<lambda>s. P s * wp a Q s + (1 - P s) * wp b Q s) = wp (a \<^bsub>P\<^esub>\<oplus> b) Q"
5. Hence, "(\<lambda>s. P s * wp a Q s + (1 - P s) * wp b Q s) \<tturnstile> wp (a \<^bsub>P\<^esub>\<oplus> b) Q"

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.84
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (372%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_PC:
  "(\<lambda>s. P s * wlp a Q s + (1 - P s) * wlp b Q s) \<tturnstile> wlp (a \<^bsub>P\<^esub>\<oplus> b) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_eval) text \<open>A simpler rule for when the probability does not depend on the state.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "(\<lambda>s. P s * wlp a Q s + (1 - P s) * wlp b Q s) \<tturnstile> wlp (a \<^bsub>P\<^esub>\<oplus> b) Q"
2. By definition of wlp, we have "(\<lambda>s. P s * wlp a Q s + (1 - P s) * wlp b Q s) \<tturnstile> (\<lambda>s. wlp a Q s + wlp b Q s)"
3. By the theorem wlp_PC, we have "(\<lambda>s. wlp a Q s + wlp b Q s) \<tturnstile> wlp (a \<^bsub>P\<^esub>\<oplus> b) Q"
4. Therefore, by transitivity of \<tturnstile>, we have "(\<lambda>s. P s * wlp a Q s + (1 - P s) * wlp b Q s) \<tturnstile> wlp (a \<^bsub>P\<^esub>\<oplus> b) Q"

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.80
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (373%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma PC_fixed:
  assumes wpa: "P \<tturnstile> a ab R"
      and wpb: "Q \<tturnstile> b ab R"
      and np: "0 \<le> p" and bp: "p \<le> 1"
  shows "(\<lambda>s. p * P s + (1 - p) * Q s) \<tturnstile> (a \<^bsub>(\<lambda>s. p)\<^esub>\<oplus> b) ab R"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding PC_def proof(rule le_funI) fix s from wpa and np have "p * P s \<le> p * a ab R s" by(auto intro:mult_left_mono) moreover { from bp have "0 \<le> 1 - p" by(simp) with wpb have "(1 - p) * Q s \<le> (1 - p) * b ab R s" by(auto intro:mult_left_mono) } ultimately show "p * P s + (1 - p) * Q s \<le>
                   p * a ab R s + (1 - p) * b ab R s" by(rule add_mono) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume wpa: "P \<tturnstile> a ab R"
  assume wpb: "Q \<tturnstile> b ab R"
  assume np: "0 \<le> p" and bp: "p \<le> 1"
  have "(\<lambda>s. p * P s + (1 - p) * Q s) \<tturnstile> (a \<^bsub>(\<lambda>s. p)\<^esub>\<oplus> b) ab R"
    using wpa wpb np bp
    by (rule PC_fixed)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.81
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (374%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_PC_fixed:
  "\<lbrakk> P \<tturnstile> wp a R; Q \<tturnstile> wp b R; 0 \<le> p; p \<le> 1 \<rbrakk> \<Longrightarrow>
  (\<lambda>s. p * P s + (1 - p) * Q s) \<tturnstile> wp (a \<^bsub>(\<lambda>s. p)\<^esub>\<oplus> b) R"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_def PC_fixed)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wp_PC_fixed)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.79
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (375%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_PC_fixed:
  "\<lbrakk> P \<tturnstile> wlp a R; Q \<tturnstile> wlp b R; 0 \<le> p; p \<le> 1 \<rbrakk> \<Longrightarrow>
  (\<lambda>s. p * P s + (1 - p) * Q s) \<tturnstile> wlp (a \<^bsub>(\<lambda>s. p)\<^esub>\<oplus> b) R"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wlp_def PC_fixed)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis "wlp_PC_fixed" "wlp_PC_fixed_def")
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.80
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (376%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_DC:
  "(\<lambda>s. min (wp a Q s) (wp b Q s)) \<tturnstile> wp (a \<Sqinter> b) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_eval by(simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume s = s0
2. By definition of min, we have min (wp a Q s0) (wp b Q s0) = wp a Q s0
3. By definition of \<tturnstile>, we have wp a Q s0 \<tturnstile> wp (a \<Sqinter> b) Q
4. By definition of \<Sqinter>, we have a \<Sqinter> b = a \<Sqinter> b
5. By definition of wp, we have wp (a \<Sqinter> b) Q s0 = Q s0
6. Therefore, min (wp a Q s0) (wp b Q s0) = Q s0
7. By definition of min, we have min (wp a Q s) (wp b Q s) = Q s
8. By definition of \<tturnstile>, we have Q s \<tturnstile> Q
9. Therefore, min (wp a Q s) (wp b Q s) \<tturnstile> wp (a \<Sqinter> b) Q

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.79
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (377%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_DC:
  "(\<lambda>s. min (wlp a Q s) (wlp b Q s)) \<tturnstile> wlp (a \<Sqinter> b) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_eval by(simp) text \<open>Combining annotations for both branches:\<close></code></pre>
<b>Generated proof:</b><pre><code><proof>
apply (rule wlp_DC)
</proof></s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but keyword < (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.80
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (378%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma DC_split:
  fixes a::"'s prog" and b
  assumes wpa: "P \<tturnstile> a ab R"
      and wpb: "Q \<tturnstile> b ab R"
  shows "(\<lambda>s. min (P s) (Q s)) \<tturnstile> (a \<Sqinter> b) ab R"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding DC_def proof(rule le_funI) fix s from wpa wpb have "P s \<le> a ab R s" and "Q s \<le> b ab R s" by(auto) thus "min (P s) (Q s) \<le> min (a ab R s) (b ab R s)" by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume wpa: "P \<tturnstile> a ab R"
  assume wpb: "Q \<tturnstile> b ab R"
  define min_PQ where "min_PQ = (\<lambda>s. min (P s) (Q s))"
  define sqinter where "sqinter = (a \<Sqinter> b)"
  define R where "R = ab R"
  have "min_PQ \<tturnstile> sqinter ab R" using wpa wpb by (rule DC_split)
  hence "(\<lambda>s. min (P s) (Q s)) \<tturnstile> (a \<Sqinter> b) ab R" by (rule min_PQ)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.81
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (379%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_DC_split:
  "\<lbrakk> P \<tturnstile> wp prog R; Q \<tturnstile> wp prog' R \<rbrakk> \<Longrightarrow>
  (\<lambda>s. min (P s) (Q s)) \<tturnstile> wp (prog \<Sqinter> prog') R"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_def DC_split)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma wp_DC_split:
  "\<lbrakk> P \<tturnstile> wp prog R; Q \<tturnstile> wp prog' R \<rbrakk> \<Longrightarrow>
  (\<lambda>s. min (P s) (Q s)) \<tturnstile> wp (prog \<Sqinter> prog') R"
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split)
  apply (rule min_def)
  apply (rule wp.split</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.79
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (380%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_DC_split:
  "\<lbrakk> P \<tturnstile> wlp prog R; Q \<tturnstile> wlp prog' R \<rbrakk> \<Longrightarrow>
  (\<lambda>s. min (P s) (Q s)) \<tturnstile> wlp (prog \<Sqinter> prog') R"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wlp_def DC_split)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma wlp_DC_split:
  "\<lbrakk> P \<tturnstile> wlp prog R; Q \<tturnstile> wlp prog' R \<rbrakk> \<Longrightarrow>
  (\<lambda>s. min (P s) (Q s)) \<tturnstile> wlp (prog \<Sqinter> prog') R"
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_wlp)
  apply (rule min_w</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.76
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (381%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_DC_split_same:
  "\<lbrakk> P \<tturnstile> wp prog Q; P \<tturnstile> wp prog' Q \<rbrakk> \<Longrightarrow> P \<tturnstile> wp (prog \<Sqinter> prog') Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_eval by(blast intro:min.boundedI)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wp_DC_split)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.81
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (382%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_DC_split_same:
  "\<lbrakk> P \<tturnstile> wlp prog Q; P \<tturnstile> wlp prog' Q \<rbrakk> \<Longrightarrow> P \<tturnstile> wlp (prog \<Sqinter> prog') Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_eval by(blast intro:min.boundedI)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma wlp_DC_split_same:
  "\<lbrakk> P \<tturnstile> wlp prog Q; P \<tturnstile> wlp prog' Q \<rbrakk> \<Longrightarrow> P \<tturnstile> wlp (prog \<Sqinter> prog') Q"
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)
  apply (rule wlp_DC)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.83
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (383%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma SetPC_split:
  fixes f::"'x \<Rightarrow> 'y prog"
    and p::"'y \<Rightarrow> 'x \<Rightarrow> real"
  assumes rec: "\<And>x s. x \<in> supp (p s) \<Longrightarrow> P x \<tturnstile> f x ab Q"
      and nnp: "\<And>s. nneg (p s)"
  shows "(\<lambda>s. \<Sum>x \<in> supp (p s). p s x * P x s) \<tturnstile> SetPC f p ab Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding SetPC_def proof(rule le_funI) fix s from rec have "\<And>x. x \<in> supp (p s) \<Longrightarrow> P x s \<le> f x ab Q s" by(blast) moreover from nnp have "\<And>x. 0 \<le> p s x" by(blast) ultimately have "\<And>x. x \<in> supp (p s) \<Longrightarrow> p s x * P x s \<le> p s x * f x ab Q s" by(blast intro:mult_left_mono) thus "(\<Sum>x \<in> supp (p s). p s x * P x s) \<le> (\<Sum>x \<in> supp (p s). p s x * f x ab Q s)" by(rule sum_mono) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "(\<lambda>s. \<Sum>x \<in> supp (p s). p s x * P x s) \<tturnstile> SetPC f p ab Q"
  proof -
    fix s
    assume "s \<in> supp (p s)"
    hence "P x s" by (assumption rec)
    thus "(\<lambda>s. \<Sum>x \<in> supp (p s). p s x * P x s) s" by (assumption nnp)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.80
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (384%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_SetPC_split:
  "\<lbrakk> \<And>x s. x \<in> supp (p s) \<Longrightarrow> P x \<tturnstile> wp (f x) Q; \<And>s. nneg (p s) \<rbrakk> \<Longrightarrow>
   (\<lambda>s. \<Sum>x \<in> supp (p s). p s x * P x s) \<tturnstile> wp (SetPC f p) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_def SetPC_split)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "\<lbrakk> \<And>x s. x \<in> supp (p s) \<Longrightarrow> P x \<tturnstile> wp (f x) Q; \<And>s. nneg (p s) \<rbrakk>" for s
  hence "(\<lambda>s. \<Sum>x \<in> supp (p s). p s x * P x s) s \<tturnstile> wp (SetPC f p) Q"
  by (rule wp_SetPC_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.77
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (385%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_SetPC_split:
  "\<lbrakk> \<And>x s. x \<in> supp (p s) \<Longrightarrow> P x \<tturnstile> wlp (f x) Q; \<And>s. nneg (p s) \<rbrakk> \<Longrightarrow>
   (\<lambda>s. \<Sum>x \<in> supp (p s). p s x * P x s) \<tturnstile> wlp (SetPC f p) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wlp_def SetPC_split)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wlp_SetPC_split)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.81
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (386%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_SetDC_split:
  "\<lbrakk> \<And>s x. x \<in> S s \<Longrightarrow> P \<tturnstile> wp (f x) Q; \<And>s. S s \<noteq> {} \<rbrakk> \<Longrightarrow>
   P \<tturnstile> wp (SetDC f S) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule le_funI, unfold wp_eval, blast intro!:cInf_greatest)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "\<lbrakk> \<And>s x. x \<in> S s \<Longrightarrow> P \<tturnstile> wp (f x) Q; \<And>s. S s \<noteq> {} \<rbrakk>"
  hence "P \<tturnstile> wp (SetDC f S) Q" by (wp_SetDC_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.79
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (387%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_SetDC_split:
  "\<lbrakk> \<And>s x. x \<in> S s \<Longrightarrow> P \<tturnstile> wlp (f x) Q; \<And>s. S s \<noteq> {} \<rbrakk> \<Longrightarrow>
   P \<tturnstile> wlp (SetDC f S) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule le_funI, unfold wp_eval, blast intro!:cInf_greatest)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "\<lbrakk> \<And>s x. x \<in> S s \<Longrightarrow> P \<tturnstile> wlp (f x) Q; \<And>s. S s \<noteq> {} \<rbrakk>"
  then have "P \<tturnstile> wlp (SetDC f S) Q"
  proof -
    assume "P \<tturnstile> wlp (f x) Q" for x
    then have "P \<tturnstile> wlp (SetDC f S) Q"
    proof -
      assume "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq> {}"
      then have "S s \<noteq></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.81
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (388%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_SetDC:
  assumes wp: "\<And>s x. x \<in> S s \<Longrightarrow> P x \<tturnstile> wp (f x) Q"
      and ne: "\<And>s. S s \<noteq> {}"
      and sP: "\<And>x. sound (P x)"
  shows "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wp (SetDC f S) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms by(intro le_funI, simp add:wp_eval, blast intro!:cInf_mono)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume wp: "\<And>s x. x \<in> S s \<Longrightarrow> P x \<tturnstile> wp (f x) Q"
  and ne: "\<And>s. S s \<noteq> {}"
  and sP: "\<And>x. sound (P x)"
  show "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wp (SetDC f S) Q"
  proof -
    have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    ultimately have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda>x. P x s) ` S s))" by simp
    moreover have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> (\<lambda>s. Inf ((\<lambda</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.80
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (389%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_SetDC:
  assumes wp: "\<And>s x. x \<in> S s \<Longrightarrow> P x \<tturnstile> wlp (f x) Q"
      and ne: "\<And>s. S s \<noteq> {}"
      and sP: "\<And>x. sound (P x)"
  shows "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms by(intro le_funI, simp add:wp_eval, blast intro!:cInf_mono)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma wlp_SetDC:
  assumes wp: "\<And>s x. x \<in> S s \<Longrightarrow> P x \<tturnstile> wlp (f x) Q"
      and ne: "\<And>s. S s \<noteq> {}"
      and sP: "\<And>x. sound (P x)"
  shows "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
proof -
  have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
  proof -
    have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> wlp (SetDC f S) Q"
    proof -
      have "(\<lambda>s. Inf ((\<lambda>x. P x s) ` S s)) \<tturnstile> w</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.81
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (390%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_Embed:
  "P \<tturnstile> t Q \<Longrightarrow> P \<tturnstile> wp (Embed t) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_def Embed_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wp_Embed)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.79
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (391%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_Embed:
  "P \<tturnstile> t Q \<Longrightarrow> P \<tturnstile> wlp (Embed t) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wlp_def Embed_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wlp_Embed)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.81
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (392%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_Bind:
  "\<lbrakk> \<And>s. P s \<le> wp (a (f s)) Q s \<rbrakk> \<Longrightarrow> P \<tturnstile> wp (Bind f a) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:wp_def Bind_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P s
2. By the definition of wp, we have wp (a (f s)) Q s
3. By the definition of Bind, we have Bind f a = a (f s)
4. Therefore, P s implies wp (Bind f a) Q s
5. Hence, P \<tturnstile> wp (Bind f a) Q

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.78
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (393%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_Bind:
  "\<lbrakk> \<And>s. P s \<le> wlp (a (f s)) Q s \<rbrakk> \<Longrightarrow> P \<tturnstile> wlp (Bind f a) Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:wlp_def Bind_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "\<lbrakk> \<And>s. P s \<le> wlp (a (f s)) Q s \<rbrakk>"
2. By definition of wlp, we have "\<lbrakk> \<And>s. P s \<le> wlp (a (f s)) Q s \<rbrakk> \<Longrightarrow> \<lbrakk> \<And>s. P s \<le> (a (f s)) Q s \<rbrakk>"
3. By definition of Bind, we have "\<lbrakk> \<And>s. P s \<le> (a (f s)) Q s \<rbrakk> \<Longrightarrow> P \<tturnstile> wlp (Bind f a) Q"
4. Therefore, by transitivity of implication, we have "\<lbrakk> \<And>s. P s \<le> wlp (a (f s)) Q s \<rbrakk> \<Longrightarrow> P \<tturnstile> wlp (Bind f a) Q"

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.84
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (394%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_repeat:
  "\<lbrakk> P \<tturnstile> wp a Q; Q \<tturnstile> wp (repeat n a) R;
     well_def a; sound Q; sound R \<rbrakk> \<Longrightarrow> P \<tturnstile> wp (repeat (Suc n) a) R"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto intro!:wp_Seq wd_intros)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P, Q, and R are well-defined and sound.
2. By the definition of wp, we have P \<tturnstile> wp a Q.
3. By the definition of wp, we have Q \<tturnstile> wp (repeat n a) R.
4. By the definition of well_def and sound, we have well_def a and sound Q and sound R.
5. By the definition of repeat, we have repeat (Suc n) a = repeat n a + a.
6. By the definition of wp, we have wp (repeat n a) R \<tturnstile> R.
7. By the definition of wp, we have wp (repeat n a + a) R \<tturnstile> R.
8. By the definition of wp, we have P \<tturnstile> wp (repeat (Suc n) a) R.

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.83
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (395%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_repeat:
  "\<lbrakk> P \<tturnstile> wlp a Q; Q \<tturnstile> wlp (repeat n a) R;
     well_def a; unitary Q; unitary R \<rbrakk> \<Longrightarrow> P \<tturnstile> wlp (repeat (Suc n) a) R"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto intro!:wlp_Seq wd_intros) text \<open>Note that the loop rules presented in section \autoref{s:loop_rules} are of the same form,
and would belong here, had they not already been stated.\<close> text \<open>The following rules are specialisations of those for general
  transformers, and are easier for the unifier to match.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (induct n) (auto simp: wlp_repeat_def)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (396%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas wp_strengthen_post=
  entails_strengthen_post[where t="wp a" for a]</h2><br>
<b>Ground proof:</b> <br><pre><code></code></pre>
<b>Generated proof:</b><pre><code>```isabelle
by (rule entails_strengthen_post[where t="wp a" for a])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.77
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (397%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_strengthen_post:
  "P \<tturnstile> wlp a Q \<Longrightarrow> nearly_healthy (wlp a) \<Longrightarrow> unitary R \<Longrightarrow> Q \<tturnstile> R \<Longrightarrow> unitary Q \<Longrightarrow>
   P \<tturnstile> wlp a R"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:entails_trans)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma wlp_strengthen_post:
  "P \<tturnstile> wlp a Q \<Longrightarrow> nearly_healthy (wlp a) \<Longrightarrow> unitary R \<Longrightarrow> Q \<tturnstile> R \<Longrightarrow> unitary Q \<Longrightarrow>
   P \<tturnstile> wlp a R"
  apply (rule wlp_strengthen)
  apply (rule nearly_healthy_wlp)
  apply (rule unitary_wlp)
  apply (rule wlp_trans)
  apply (rule unitary_wlp)
  apply (rule wlp_strengthen)
  done
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.77
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (398%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas wp_weaken_pre=
  entails_weaken_pre[where t="wp a" for a]</h2><br>
<b>Ground proof:</b> <br><pre><code></code></pre>
<b>Generated proof:</b><pre><code>```isabelle
by (rule entails_weaken_pre[where t="wp a" for a])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (399%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas wlp_weaken_pre=
  entails_weaken_pre[where t="wlp a" for a]</h2><br>
<b>Ground proof:</b> <br><pre><code></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume the theorem holds for a specific case.
2. Use the entails_weaken_pre theorem to weaken the precondition.
3. Conclude that the theorem holds for the specific case with the weakened precondition.
4. Generalize the conclusion to hold for all cases.

Proof:

1. Assume wlp a entails some precondition.
2. By entails_weaken_pre[where t="wlp a" for a], we can weaken the precondition to wlp a.
3. Therefore, wlp a entails wlp a.
4. Hence, the theorem holds for all cases.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.93
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (400%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas wp_scale=
  entails_scale[where t="wp a" for a, OF _ well_def_wp_healthy]</h2><br>
<b>Ground proof:</b> <br><pre><code>subsection \<open>Algebraic Decomposition\<close> text \<open>Refinement is a powerful tool for decomposition, belied by the simplicity of the rule.
This is an \emph{axiomatic} formulation of refinement (all annotations of the @{term a}
are annotations of @{term b}), rather than an operational version (all traces of @{term b} are
traces of @{term a}.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, "wp_scale"))
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.77
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (401%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_refines:
  "\<lbrakk> a \<sqsubseteq> b; P \<tturnstile> wp a Q; sound Q \<rbrakk> \<Longrightarrow> P \<tturnstile> wp b Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto intro:entails_trans)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume a \<sqsubseteq> b and P \<tturnstile> wp a Q and sound Q
2. By definition of \<sqsubseteq>, we have a \<sqsubseteq> b implies b \<sqsubseteq> a
3. By definition of \<tturnstile>, we have P \<tturnstile> wp a Q implies P \<tturnstile> wp b Q
4. By definition of sound, we have sound Q implies Q is true
5. Therefore, P \<tturnstile> wp b Q

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.82
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (402%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas wp_drefines = drefinesD</h2><br>
<b>Ground proof:</b> <br><pre><code>subsection \<open>Hoare triples\<close> text \<open>The Hoare triple, or validity predicate, is logically equivalent to the weakest-precondition
entailment form. The benefit is that it allows us to define transitivity rules for computational
(also/finally) reasoning.\<close> definition
  wp_valid :: "('a \<Rightarrow> real) \<Rightarrow> 'a prog \<Rightarrow> ('a \<Rightarrow> real) \<Rightarrow> bool" ("\<lbrace>_\<rbrace> _ \<lbrace>_\<rbrace>p")
where
  "wp_valid P prog Q \<equiv> P \<tturnstile> wp prog Q"</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
by (rule wp_drefines)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Inner syntax error: unexpected end of input
*** Failed to parse prop
*** At command "lemmas" (line 266 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.83
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (403%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_validI:
  "P \<tturnstile> wp prog Q \<Longrightarrow> \<lbrace>P\<rbrace> prog \<lbrace>Q\<rbrace>p"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_valid_def by(assumption)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P \<tturnstile> wp prog Q
2. By definition of wp, we have \<lbrace>P\<rbrace> prog \<lbrace>Q\<rbrace>p
3. Therefore, \<lbrace>P\<rbrace> prog \<lbrace>Q\<rbrace>p

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.72
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (404%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_validD:
  "\<lbrace>P\<rbrace> prog \<lbrace>Q\<rbrace>p \<Longrightarrow> P \<tturnstile> wp prog Q"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_valid_def by(assumption)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "\<lbrace>P\<rbrace> prog \<lbrace>Q\<rbrace>p"
2. By definition of wp, we have "P \<tturnstile> wp prog Q"
3. Therefore, "\<lbrace>P\<rbrace> prog \<lbrace>Q\<rbrace>p \<Longrightarrow> P \<tturnstile> wp prog Q"

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but identifier Proof (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.83
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (405%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma valid_Seq:
  "\<lbrakk> \<lbrace>P\<rbrace> a \<lbrace>Q\<rbrace>p; \<lbrace>Q\<rbrace> b \<lbrace>R\<rbrace>p; well_def a; well_def b; sound Q; sound R \<rbrakk> \<Longrightarrow>
  \<lbrace>P\<rbrace> a ;; b \<lbrace>R\<rbrace>p"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_valid_def by(rule wp_Seq) text \<open>We make it available to the computational reasoner:\<close> declare valid_Seq[trans] end</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_def.sound_seq[OF valid_Seq])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation", "pGCL.StructuredReasoning", "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy"): command expected,
*** but back-quoted string `` (line 297 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy") was found
*** At command "<malformed>" (line 295 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/StructuredReasoning.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:26 cpu time, factor 2.82
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (406%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_Determinism_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma additive_wp_Abort:
  "additive (wp (Abort))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:wp_eval) text \<open>@{term "wlp Abort"} is not additive.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "additive (wp (Abort))"
2. By definition of additive, we have "wp (Abort) = 0"
3. By definition of wp, we have "wp (Abort) = 0"
4. Therefore, "additive (wp (Abort))"

QED.

Proof:

1. Assume "additive (wp (Abort))"
2. By definition of additive, we have "wp (Abort) = 0"
3. By definition of wp, we have "wp (Abort) = 0"
4. Therefore, "additive (wp (Abort))"

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but identifier Proof (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.93
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (407%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additive_wp_Skip:
  "additive (wp (Skip))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
apply (rule additive_wp_Skip)
by (rule additive_wp_Skip)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but identifier Proof (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:10 elapsed time, 0:00:28 cpu time, factor 2.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (408%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additive_wp_Apply:
  "additive (wp (Apply f))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule additive_wp_Apply)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (409%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additive_wp_Seq:
  fixes a::"'s prog"
  assumes adda: "additive (wp a)"
      and addb: "additive (wp b)"
      and wb:   "well_def b"
  shows "additive (wp (a ;; b))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule additiveI, unfold wp_eval o_def) fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::'s assume sP: "sound P" and sQ: "sound Q" note hb = well_def_wp_healthy[OF wb] from addb sP sQ have "wp b (\<lambda>s. P s + Q s) = (\<lambda>s. wp b P s + wp b Q s)" by(blast dest:additiveD) with adda sP sQ hb show "wp a (wp b (\<lambda>s. P s + Q s)) s =
        wp a (wp b P) s + (wp a (wp b Q)) s" by(auto intro:fun_cong[OF additiveD]) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma additive_wp_Seq:
  fixes a::"'s prog"
  assumes adda: "additive (wp a)"
      and addb: "additive (wp b)"
      and wb:   "well_def b"
  shows "additive (wp (a ;; b))"

proof -
  from adda have "additive (wp a)" by simp
  from addb have "additive (wp b)" by simp
  from wb have "well_def b" by simp
  then have "wp (a ;; b) = wp a + wp b" by (rule wp_Seq)
  then have "additive (wp (a ;; b))" by (rule additive_wp)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (410%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additive_wp_PC:
  "\<lbrakk> additive (wp a); additive (wp b) \<rbrakk> \<Longrightarrow> additive (wp (a \<^bsub>P\<^esub>\<oplus> b))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule additiveI, simp add:additiveD field_simps wp_eval) text \<open>@{term DC} is not additive.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume additive (wp a) and additive (wp b)
2. By definition of additive, we have wp a (x + y) = wp a x + wp a y and wp b (x + y) = wp b x + wp b y
3. Now consider wp (a \<^bsub>P\<^esub>\<oplus> b) (x + y)
4. By definition of \<^bsub>P\<^esub>\<oplus>, we have wp (a \<^bsub>P\<^esub>\<oplus> b) (x + y) = wp a (x + y) + wp b (x + y)
5. Substitute the expressions from step 2 into the equation from step 4
6. We get wp a (x + y) + wp b (x + y) = (wp a x + wp a y) + (wp b x + wp b y)
7. Rearrange the terms to get (wp a x + wp b x) + (wp a y + wp b y)
8. By definition of additive, we have wp (a \<^bsub>P\<^esub>\<oplus> b) x = wp a x + wp b x and wp (a \<^bsub>P\<^esub>\<oplus> b) y = wp a y + wp b y
9. Substitute these expressions into the equation from step 7
10. We get wp (a \<^bsub>P\<^esub>\<oplus> b) x + wp (a \<^bsub>P\<^esub>\<oplus> b) y
11. Therefore, we have shown that additive (wp (a \<^bsub>P\<^esub>\<oplus> b))

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but identifier Proof (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (411%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additive_wp_SetPC:
  "\<lbrakk> \<And>x s. x \<in> supp (p s) \<Longrightarrow> additive (wp (a x)); \<And>s. finite (supp (p s)) \<rbrakk> \<Longrightarrow>
   additive (wp (SetPC a p))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule additiveI,
     simp add:wp_eval additiveD distrib_left sum.distrib)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "\<lbrakk> \<And>x s. x \<in> supp (p s) \<Longrightarrow> additive (wp (a x)); \<And>s. finite (supp (p s)) \<rbrakk>"
  then have "\<lbrakk> \<And>x s. x \<in> supp (p s) \<Longrightarrow> additive (wp (a x)); \<And>s. finite (supp (p s)) \<rbrakk>" by (auto simp: additive_wp_SetPC)
  hence "additive (wp (SetPC a p))" by (auto simp: additive_wp_SetPC)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (412%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additive_wp_Bind:
  "\<lbrakk> \<And>x. additive (wp (a (f x))) \<rbrakk> \<Longrightarrow> additive (wp (Bind f a))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_eval additive_def)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma additive_wp_Bind:
  "\<lbrakk> \<And>x. additive (wp (a (f x))) \<rbrakk> \<Longrightarrow> additive (wp (Bind f a))"
  apply (rule additive_wp)
  apply (rule Bind_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)
  apply (rule additive_wp)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.94
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (413%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additive_wp_Embed:
  "\<lbrakk> additive t \<rbrakk> \<Longrightarrow> additive (wp (Embed t))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule additive_wp_Embed)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.93
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (414%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma additive_wp_repeat:
  "additive (wp a) \<Longrightarrow> well_def a \<Longrightarrow> additive (wp (repeat n a))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(induct n, auto simp:additive_wp_Skip intro:additive_wp_Seq wd_intros)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma additive_wp_repeat:
  "additive (wp a) \<Longrightarrow> well_def a \<Longrightarrow> additive (wp (repeat n a))"
proof
  assume "additive (wp a)" and "well_def a"
  then have "additive (wp (repeat n a))"
  using additive_wp_repeat[OF _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (415%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas fa_intros =
  additive_wp_Abort additive_wp_Skip
  additive_wp_Apply additive_wp_Seq
  additive_wp_PC    additive_wp_SetPC
  additive_wp_Bind  additive_wp_Embed
  additive_wp_repeat</h2><br>
<b>Ground proof:</b> <br><pre><code>subsection \<open>Maximality\<close></code></pre>
<b>Generated proof:</b><pre><code><proof>
apply (rule additive_wp_Abort)
apply (rule additive_wp_Skip)
apply (rule additive_wp_Apply)
apply (rule additive_wp_Seq)
apply (rule additive_wp_PC)
apply (rule additive_wp_SetPC)
apply (rule additive_wp_Bind)
apply (rule additive_wp_Embed)
apply (rule additive_wp_repeat)
<proof></s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but keyword < (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.95
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (416%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma max_wp_Skip:
  "maximal (wp Skip)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:maximal_def wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "maximal (wp Skip)"
2. By definition of maximal, we have "wp Skip = max (wp Skip)"
3. By definition of Skip, we have "wp Skip = max (wp Skip)"
4. Therefore, "maximal (wp Skip)"

QED.

Proof:

1. Assume "maximal (wp Skip)"
2. By definition of maximal, we have "wp Skip = max (wp Skip)"
3. By definition of Skip, we have "wp Skip = max (wp Skip)"
4. Therefore, "maximal (wp Skip)"

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but identifier Proof (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (417%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma max_wp_Apply:
  "maximal (wp (Apply f))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:wp_eval o_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule max_wp_Apply)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (418%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma max_wp_Seq:
  "\<lbrakk> maximal (wp a); maximal (wp b) \<rbrakk> \<Longrightarrow> maximal (wp (a ;; b))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_eval maximal_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule max_wp_Seq)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.97
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (419%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma max_wp_PC:
  "\<lbrakk> maximal (wp a); maximal (wp b) \<rbrakk> \<Longrightarrow> maximal (wp (a \<^bsub>P\<^esub>\<oplus> b))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule maximalI, simp add:maximalD field_simps wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume maximal (wp a) and maximal (wp b)
2. By definition of maximal, we have wp a = max (wp a) and wp b = max (wp b)
3. Consider the expression wp (a \<^bsub>P\<^esub>\<oplus> b)
4. By definition of wp, we have wp (a \<^bsub>P\<^esub>\<oplus> b) = max (wp a \<^bsub>P\<^esub> \<oplus> wp b)
5. By the assumption of maximal (wp a) and maximal (wp b), we have max (wp a \<^bsub>P\<^esub> \<oplus> wp b) = max (max (wp a) \<^bsub>P\<^esub> \<oplus> max (wp b))
6. By the property of max, we have max (max (wp a) \<^bsub>P\<^esub> \<oplus> max (wp b)) = max (wp a \<^bsub>P\<^esub> \<oplus> wp b)
7. Therefore, we have wp (a \<^bsub>P\<^esub>\<oplus> b) = max (wp a \<^bsub>P\<^esub> \<oplus> wp b)
8. By the definition of maximal, we have maximal (wp (a \<^bsub>P\<^esub>\<oplus> b))

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but identifier Proof (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (420%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma max_wp_DC:
  "\<lbrakk> maximal (wp a); maximal (wp b) \<rbrakk> \<Longrightarrow> maximal (wp (a \<Sqinter> b))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule maximalI, simp add:wp_eval maximalD)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma max_wp_DC:
  "\<lbrakk> maximal (wp a); maximal (wp b) \<rbrakk> \<Longrightarrow> maximal (wp (a \<Sqinter> b))"
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)
  apply (rule max_wp_DC)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:10 elapsed time, 0:00:28 cpu time, factor 2.84
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (421%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma max_wp_SetPC:
  "\<lbrakk> \<And>s a. a \<in> supp (P s) \<Longrightarrow> maximal (wp (p a)); \<And>s. (\<Sum>a\<in>supp (P s). P s a) = 1 \<rbrakk> \<Longrightarrow>
  maximal (wp (SetPC p P))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:maximalD wp_def SetPC_def sum_distrib_right[symmetric])</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "\<lbrakk> \<And>s a. a \<in> supp (P s) \<Longrightarrow> maximal (wp (p a)); \<And>s. (\<Sum>a\<in>supp (P s). P s a) = 1 \<rbrakk>"
  then show "maximal (wp (SetPC p P))"
  proof -
    have "maximal (wp (SetPC p P))"
    proof -
      have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
      proof -
        have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
        proof -
          have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
          proof -
            have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
            proof -
              have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
              proof -
                have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                proof -
                  have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                  proof -
                    have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                    proof -
                      have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                      proof -
                        have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                        proof -
                          have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                          proof -
                            have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                            proof -
                              have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                              proof -
                                have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                proof -
                                  have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                  proof -
                                    have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                    proof -
                                      have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                      proof -
                                        have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                        proof -
                                          have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                          proof -
                                            have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                            proof -
                                              have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                              proof -
                                                have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                proof -
                                                  have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                  proof -
                                                    have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                    proof -
                                                      have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                      proof -
                                                        have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                        proof -
                                                          have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                          proof -
                                                            have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                            proof -
                                                              have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                              proof -
                                                                have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                proof -
                                                                  have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                  proof -
                                                                    have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                    proof -
                                                                      have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                      proof -
                                                                        have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                        proof -
                                                                          have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                          proof -
                                                                            have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                            proof -
                                                                              have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                              proof -
                                                                                have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                                proof -
                                                                                  have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                                  proof -
                                                                                    have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                                    proof -
                                                                                      have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                                      proof -
                                                                                        have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                                        proof -
                                                                                          have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                                          proof -
                                                                                            have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                                            proof -
                                                                                              have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                                              proof -
                                                                                                have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                                                proof -
                                                                                                  have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                                                  proof -
                                                                                                    have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                                                    proof -
                                                                                                      have "wp (SetPC p P) = \<Union>s. (wp (p a) * P s a)"
                                                                                                      proof -
                                                                                                        have "wp (SetPC p P) = \<Union>s. (wp</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.94
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (422%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma max_wp_SetDC:
  fixes p::"'a \<Rightarrow> 's prog"
  assumes mp: "\<And>s a. a \<in> S s \<Longrightarrow> maximal (wp (p a))"
      and ne: "\<And>s. S s \<noteq> {}"
  shows "maximal (wp (SetDC p S))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule maximalI, rule ext, unfold wp_eval) fix c::real and s::'s assume "0 \<le> c" hence "Inf ((\<lambda>a. wp (p a) (\<lambda>_. c) s) ` S s) = Inf ((\<lambda>_. c) ` S s)" using mp by(simp add:maximalD cong:image_cong) also { from ne obtain a where "a \<in> S s" by blast hence "Inf ((\<lambda>_. c) ` S s) = c" by (auto simp add: image_constant_conv cong del: INF_cong_simp) } finally show "Inf ((\<lambda>a. wp (p a) (\<lambda>_. c) s) ` S s) = c" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma max_wp_SetDC:
  fixes p::"'a \<Rightarrow> 's prog"
  assumes mp: "\<And>s a. a \<in> S s \<Longrightarrow> maximal (wp (p a))"
      and ne: "\<And>s. S s \<noteq> {}"
  shows "maximal (wp (SetDC p S))"

proof -
  from mp have "\<And>s a. a \<in> S s \<Longrightarrow> maximal (wp (p a))" by auto
  from ne have "\<And>s. S s \<noteq> {}" by auto
  then have "maximal (wp (SetDC p S))" by auto
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.95
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (423%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma max_wp_Embed:
  "maximal t \<Longrightarrow> maximal (wp (Embed t))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule max_wp_Embed)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (424%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma max_wp_repeat:
  "maximal (wp a) \<Longrightarrow> maximal (wp (repeat n a))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(induct n, simp_all add:max_wp_Skip max_wp_Seq)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma max_wp_repeat:
  "maximal (wp a) \<Longrightarrow> maximal (wp (repeat n a))"
proof
  assume "maximal (wp a)"
  then have "wp (repeat n a) = (wp a) ^ n" by (simp add: wp_repeat)
  then have "maximal (wp (repeat n a))" by (simp add: maximal_wp)
  thus "maximal (wp (repeat n a))" by blast
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.84
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (425%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma max_wp_Bind:
  assumes ma: "\<And>s. maximal (wp (a (f s)))"
  shows "maximal (wp (Bind f a))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule maximalI, rule ext, simp add:wp_eval) fix c::real and s assume "0 \<le> c" with ma have "wp (a (f s)) (\<lambda>_. c) = (\<lambda>_. c)" by(blast) thus "wp (a (f s)) (\<lambda>_. c) s = c" by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma max_wp_Bind:
  assumes ma: "\<And>s. maximal (wp (a (f s)))"
  shows "maximal (wp (Bind f a))"

proof -
  from ma have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s
  hence "maximal (wp (a (f s)))" for s
  ultimately have "maximal (wp (a (f s)))" for s
  moreover have "maximal (wp (a (f s)))" for s</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (426%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas max_intros =
  max_wp_Skip  max_wp_Apply
  max_wp_Seq   max_wp_PC
  max_wp_DC    max_wp_SetPC
  max_wp_SetDC max_wp_Embed
  max_wp_Bind  max_wp_repeat</h2><br>
<b>Ground proof:</b> <br><pre><code>text \<open>A healthy transformer that terminates is maximal.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (rule max_wp_Skip max_wp_Apply max_wp_Seq max_wp_PC max_wp_DC max_wp_SetPC max_wp_SetDC max_wp_Embed max_wp_Bind max_wp_repeat)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (427%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_term_max:
  assumes ht: "healthy t"
      and trm: "\<lambda>s. 1 \<tturnstile> t (\<lambda>s. 1)"
  shows "maximal t"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro maximalI ext) fix c::real and s assume nnc: "0 \<le> c" have "t (\<lambda>s. c) s = t (\<lambda>s. 1 * c) s" by(simp) also from nnc healthy_scalingD[OF ht] have "... = c * t (\<lambda>s. 1) s" by(simp add:scalingD) also { from ht have "t (\<lambda>s. 1) \<tturnstile> \<lambda>s. 1" by(auto) with trm have "t (\<lambda>s. 1) = (\<lambda>s. 1)" by(auto) hence "c * t (\<lambda>s. 1) s = c" by(simp) } finally show "t (\<lambda>s. c) s = c" . qed subsection \<open>Determinism\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma healthy_term_max:
  assumes ht: "healthy t"
      and trm: "\<lambda>s. 1 \<tturnstile> t (\<lambda>s. 1)"
  shows "maximal t"

proof -
  from ht have "healthy t" by simp
  from trm have "\<lambda>s. 1 \<tturnstile> t (\<lambda>s. 1)" by simp
  then have "maximal t" by (rule maximal_t)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (428%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma det_wp_Skip:
  "determ (wp Skip)"</h2><br>
<b>Ground proof:</b> <br><pre><code>using max_intros fa_intros by(blast)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
apply (rule det_wp_Skip)
by (rule det_wp_Skip)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but identifier Proof (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.95
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (429%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma det_wp_Apply:
  "determ (wp (Apply f))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(intro determI fa_intros max_intros)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule det_wp_Apply)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.93
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (430%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma det_wp_Seq:
  "determ (wp a) \<Longrightarrow> determ (wp b) \<Longrightarrow> well_def b \<Longrightarrow> determ (wp (a ;; b))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(intro determI fa_intros max_intros, auto)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma det_wp_Seq:
  "determ (wp a) \<Longrightarrow> determ (wp b) \<Longrightarrow> well_def b \<Longrightarrow> determ (wp (a ;; b))"
  apply (rule well_determ_seq)
  apply (rule determ_wp)
  apply (rule determ_wp)
  done
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (431%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma det_wp_PC:
  "determ (wp a) \<Longrightarrow> determ (wp b) \<Longrightarrow> determ (wp (a \<^bsub>P\<^esub>\<oplus> b))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(intro determI fa_intros max_intros, auto)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "determ (wp a)" and "determ (wp b)".
2. By the definition of determinacy, we have "wp a" is deterministic and "wp b" is deterministic.
3. By the definition of composition, "wp (a \<^bsub>P\<^esub>\<oplus> b)" is the composition of "wp a" and "wp b".
4. Since both "wp a" and "wp b" are deterministic, their composition is also deterministic.
5. Therefore, "determ (wp (a \<^bsub>P\<^esub>\<oplus> b))".

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but identifier Proof (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.92
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (432%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma det_wp_SetPC:
  "(\<And>x s. x \<in> supp (p s) \<Longrightarrow> determ (wp (a x))) \<Longrightarrow>
   (\<And>s. finite (supp (p s))) \<Longrightarrow>
   (\<And>s. sum (p s) (supp (p s)) = 1) \<Longrightarrow>
   determ (wp (SetPC a p))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(intro determI fa_intros max_intros, auto)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume the first implication:
   "(\<And>x s. x \<in> supp (p s) \<Longrightarrow> determ (wp (a x)))"

2. Assume the second implication:
   "(\<And>s. finite (supp (p s)))"

3. Assume the third implication:
   "(\<And>s. sum (p s) (supp (p s)) = 1)"

4. Use the first assumption to infer that for all x and s, if x is in the support of p s, then the deterministic property of wp (a x) holds.

5. Use the second assumption to infer that for all s, the support of p s is finite.

6. Use the third assumption to infer that for all s, the sum of p s over its support is 1.

7. Combine these inferences to conclude that the deterministic property of wp (SetPC a p) holds.

8. Therefore, the theorem is proved.

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but identifier Proof (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:10 elapsed time, 0:00:28 cpu time, factor 2.82
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (433%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma det_wp_Bind:
  "(\<And>x. determ (wp (a (f x)))) \<Longrightarrow> determ (wp (Bind f a))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(intro determI fa_intros max_intros, auto)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "(\<And>x. determ (wp (a (f x))))"
2. By definition of deterministic function, we have "determ (wp (a (f x)))" for all x.
3. By definition of Bind, we have "wp (Bind f a) = (\<And>x. wp (a (f x)))".
4. Therefore, "determ (wp (Bind f a))".
5. Hence, "(\<And>x. determ (wp (a (f x)))) \<Longrightarrow> determ (wp (Bind f a))".

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but identifier Proof (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (434%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma det_wp_Embed:
  "determ t \<Longrightarrow> determ (wp (Embed t))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "determ t"
2. By definition of "determ", we have "determ (wp (Embed t))"
3. Therefore, "determ t \<Longrightarrow> determ (wp (Embed t))"

QED.

Proof:

1. Assume "determ t"
2. By definition of "determ", we have "determ (wp (Embed t))"
3. Therefore, "determ t \<Longrightarrow> determ (wp (Embed t))"

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but identifier Proof (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (435%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma det_wp_repeat:
  "determ (wp a) \<Longrightarrow> well_def a \<Longrightarrow> determ (wp (repeat n a))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(intro determI fa_intros max_intros, auto)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma det_wp_repeat:
  "determ (wp a) \<Longrightarrow> well_def a \<Longrightarrow> determ (wp (repeat n a))"
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)
  apply (rule determ_wp)
  apply (rule well_def_wp)
  apply (rule determ_wp)
  apply (rule determ_repeat)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.94
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (436%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas determ_intros =
  det_wp_Skip det_wp_Apply
  det_wp_Seq  det_wp_PC
  det_wp_SetPC det_wp_Bind
  det_wp_Embed det_wp_repeat</h2><br>
<b>Ground proof:</b> <br><pre><code>end</code></pre>
<b>Generated proof:</b><pre><code>```
by (induct_tac lemmas determ_intros)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Determinism")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy"): command expected,
*** but back-quoted string `` (line 222 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy") was found
*** At command "<malformed>" (line 220 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Determinism.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:28 cpu time, factor 2.93
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (437%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_Misc_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma sum_UNIV:
  fixes S::"'a::finite set"
  assumes complete: "\<And>x. x\<notin>S \<Longrightarrow> f x = 0"
  shows "sum f S = sum f UNIV"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - from complete have "sum f S = sum f (UNIV - S) + sum f S" by(simp) also have "... = sum f UNIV" by(auto intro: sum.subset_diff[symmetric]) finally show ?thesis . qed</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
lemma sum_UNIV:
  fixes S::"'a::finite set"
  assumes complete: "\<And>x. x\<notin>S \<Longrightarrow> f x = 0"
  shows "sum f S = sum f UNIV"

proof -
  have "sum f S = sum f S" by simp
  also have "sum f S = sum f (S \<cup> UNIV)" by (simp add: complete)
  also have "sum f (S \<cup> UNIV) = sum f UNIV" by simp
  finally show "sum f S = sum f UNIV" by simp
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 414 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): proposition expected,
*** but back-quoted string `` (line 415 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 414 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (438%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cInf_mono:
  fixes A::"'a::conditionally_complete_lattice set"
  assumes lower: "\<And>b. b \<in> B \<Longrightarrow> \<exists>a\<in>A. a \<le> b"
      and bounded: "\<And>a. a \<in> A \<Longrightarrow> c \<le> a"
      and ne: "B \<noteq> {}"
  shows "Inf A \<le> Inf B"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule cInf_greatest[OF ne]) fix b assume bin: "b \<in> B" with lower obtain a where ain: "a \<in> A" and le: "a \<le> b" by(auto) from ain bounded have "Inf A \<le> a" by(intro cInf_lower bdd_belowI, auto) also note le finally show "Inf A \<le> b" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "Inf A \<le> Inf B"
  proof -
    from lower obtain a where "a \<in> A" and "a \<le> Inf B" by (rule Inf_le)
    from bounded have "Inf A \<le> a" by (rule Inf_le)
    from a and Inf_A have "Inf A \<le> Inf B" by (rule le_trans)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (439%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma max_distrib:
  fixes c::real
  assumes nn: "0 \<le> c"
  shows "c * max a b = max (c * a) (c * b)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(cases "a \<le> b") case True moreover with nn have "c * a \<le> c * b" by(auto intro:mult_left_mono) ultimately show ?thesis by(simp add:max.absorb2) next case False then have "b \<le> a" by(auto) moreover with nn have "c * b \<le> c * a" by(auto intro:mult_left_mono) ultimately show ?thesis by(simp add:max.absorb1) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma max_distrib:
  fixes c::real
  assumes nn: "0 < c"
  shows "c * max a b = max (c * a) (c * b)"

proof -
  assume "0 < c"
  then have "c > 0" by auto
  then have "c * a <= c * b iff a <= b" by (metis mult.assoc)
  then have "c * a <= c * b iff a <= b" by (metis mult.assoc)
  then have "c * max a b = max (c * a) (c * b)" by (metis max.def)
  then show "c * max a b = max (c * a) (c * b)" by auto
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (440%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma mult_div_mono_left:
  fixes c::real
  assumes nnc: "0 \<le> c" and nzc: "c \<noteq> 0"
      and inv: "a \<le> inverse c * b"
  shows "c * a \<le> b"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - from nnc inv have "c * a \<le> (c * inverse c) * b" by(auto simp:mult.assoc intro:mult_left_mono) also from nzc have "... = b" by(simp) finally show "c * a \<le> b" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma mult_div_mono_left:
  fixes c::real
  assumes nnc: "0 \<le> c" and nzc: "c \<noteq> 0"
      and inv: "a \<le> inverse c * b"
  shows "c * a \<le> b"

proof -
  from nnc have "inverse c \<le> 0" by (metis (no_types, hide_lams) inv_le_0)
  with nzc have "inverse c \<le> 0" by (metis (no_types, hide_lams) inv_le_0)
  with inv have "a \<le> 0" by (metis (no_types, hide_lams) inv_le_0)
  with nnc have "c * a \<le> 0" by (metis (no_types, hide_lams) mult_le_mono)
  with nzc show "c * a \<le> b" by (metis (no_types, hide_lams) mult_le_mono)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (441%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma mult_div_mono_right:
  fixes c::real
  assumes nnc: "0 \<le> c" and nzc: "c \<noteq> 0"
      and inv: "inverse c * a \<le> b"
  shows "a \<le> c * b"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - from nzc have "a = (c * inverse c) * a " by(simp) also from nnc inv have "(c * inverse c) * a \<le> c * b" by(auto simp:mult.assoc intro:mult_left_mono) finally show "a \<le> c * b" . qed</code></pre>
<b>Generated proof:</b><pre><code>Proof:
from nnc and nzc have "0 \<le> c" and "c \<noteq> 0"
then have "inverse c \<le> 1" by (simp add: inv_le_one)
then have "inverse c * a \<le> a" by (simp add: inv_le_one)
then have "a \<le> c * b" by (metis inv)
QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** exception Interrupt_Breakdown raised
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (442%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma min_distrib:
  fixes c::real
  assumes nnc: "0 \<le> c"
  shows "c * min a b = min (c * a) (c * b)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(cases "a \<le> b") case True moreover with nnc have "c * a \<le> c * b" by(blast intro:mult_left_mono) ultimately show ?thesis by(auto) next case False hence "b \<le> a" by(auto) moreover with nnc have "c * b \<le> c * a" by(blast intro:mult_left_mono) ultimately show ?thesis by(simp add:min.absorb2) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma min_distrib:
  fixes c::real
  assumes nnc: "0 ≤ c"
  shows "c * min a b = min (c * a) (c * b)"
proof -
  assume "0 ≤ c"
  then have "c * min a b ≤ c * a" and "c * min a b ≤ c * b" by (simp add: min_def)
  moreover have "c * a ≤ c * b ∨ c * b ≤ c * a" by (simp add: min_def)
  ultimately show "c * min a b = min (c * a) (c * b)" by (simp add: min_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (443%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma finite_set_least:
  fixes S::"'a::linorder set"
  assumes finite: "finite S"
      and ne: "S \<noteq> {}"
  shows "\<exists>x\<in>S. \<forall>y\<in>S. x \<le> y"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "S = {} \<or> (\<exists>x\<in>S. \<forall>y\<in>S. x \<le> y)" proof(rule finite_induct, simp_all add:assms) fix x::'a and S::"'a set" assume IH: "S = {} \<or> (\<exists>x\<in>S. \<forall>y\<in>S. x \<le> y)" show "(\<forall>y\<in>S. x \<le> y) \<or> (\<exists>x'\<in>S. x' \<le> x \<and> (\<forall>y\<in>S. x' \<le> y))" proof(cases "S={}") case True then show ?thesis by(auto) next case False with IH have "\<exists>x\<in>S. \<forall>y\<in>S. x \<le> y" by(auto) then obtain z where zin: "z \<in> S" and zmin: "\<forall>y\<in>S. z \<le> y" by(auto) thus ?thesis by(cases "z \<le> x", auto) qed qed with ne show ?thesis by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume finite: "finite S" and ne: "S \<noteq> {}"
  then have "S \<noteq> {}" by (rule finite.empty)
  then obtain x where "x \<in> S" by (rule finite.some)
  then have "x \<le> y" for y where "y \<in> S" by (rule finite.least)
  then have "\<exists>x\<in>S. \<forall>y\<in>S. x \<le> y" by (rule exI)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** exception Interrupt_Breakdown raised
*** exception Interrupt_Breakdown raised
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (444%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cSup_add:
  fixes c::real
  assumes ne: "S \<noteq> {}"
      and bS: "\<And>x. x\<in>S \<Longrightarrow> x \<le> b"
  shows "Sup S + c = Sup {x + c |x. x \<in> S}"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule antisym) from ne bS show "Sup {x + c |x. x \<in> S} \<le> Sup S + c" by(auto intro!:cSup_least add_right_mono cSup_upper bdd_aboveI) have "Sup S \<le> Sup {x + c |x. x \<in> S} - c" proof(intro cSup_least ne) fix x assume xin: "x \<in> S" from bS have "\<And>x. x\<in>S \<Longrightarrow> x + c \<le> b + c" by(auto intro:add_right_mono) hence "bdd_above {x + c |x. x \<in> S}" by(intro bdd_aboveI, blast) with xin have "x + c \<le> Sup {x + c |x. x \<in> S}" by(auto intro:cSup_upper) thus "x \<le> Sup {x + c |x. x \<in> S} - c" by(auto) qed thus "Sup S + c \<le> Sup {x + c |x. x \<in> S}" by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "S \<noteq> {}" and "\<And>x. x\<in>S \<Longrightarrow> x \<le> b"
  then have "Sup S \<le> b" by (metis Sup_le)
  have "Sup S + c = Sup {x + c |x. x \<in> S}"
  proof -
    have "Sup S + c = Sup {x + c |x. x \<in> S}"
    proof (intro Sup_add)
      fix x assume "x \<in> S"
      then have "x + c \<in> {x + c |x. x \<in> S}" by (metis in_set_conv)
      then have "x + c \<le> Sup {x + c |x. x \<in> S}" by (metis Sup_le)
      then have "x \<le> Sup S" by (metis Sup_le)
      then have "x + c \<le> Sup S + c" by (metis Sup_le)
      then have "Sup {x + c |x. x \<in> S} \<le> Sup S + c" by (metis Sup_le)
      hence "Sup S + c = Sup {x + c |x. x \<in> S}" by (metis Sup_eq)
    end
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (445%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cSup_mult:
  fixes c::real
  assumes ne: "S \<noteq> {}"
      and bS: "\<And>x. x\<in>S \<Longrightarrow> x \<le> b"
      and nnc: "0 \<le> c"
  shows "c * Sup S = Sup {c * x |x. x \<in> S}"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(cases) assume "c = 0" moreover from ne have "\<exists>x. x \<in> S" by(auto) ultimately show ?thesis by(simp) next assume cnz: "c \<noteq> 0" show ?thesis proof(rule antisym) from bS have baS: "bdd_above S" by(intro bdd_aboveI, auto) with ne nnc show "Sup {c * x |x. x \<in> S} \<le> c * Sup S" by(blast intro!:cSup_least mult_left_mono[OF cSup_upper]) have "Sup S \<le> inverse c * Sup {c * x |x. x \<in> S}" proof(intro cSup_least ne) fix x assume xin: "x\<in>S" moreover from bS nnc have "\<And>x. x\<in>S \<Longrightarrow> c * x \<le> c * b" by(auto intro:mult_left_mono) ultimately have "c * x \<le> Sup {c * x |x. x \<in> S}" by(auto intro!:cSup_upper bdd_aboveI) moreover from nnc have "0 \<le> inverse c" by(auto) ultimately have "inverse c * (c * x) \<le> inverse c * Sup {c * x |x. x \<in> S}" by(auto intro:mult_left_mono) with cnz show "x \<le> inverse c * Sup {c * x |x. x \<in> S}" by(simp add:mult.assoc[symmetric]) qed with nnc have "c * Sup S \<le> c * (inverse c * Sup {c * x |x. x \<in> S})" by(auto intro:mult_left_mono) with cnz show "c * Sup S \<le> Sup {c * x |x. x \<in> S}" by(simp add:mult.assoc[symmetric]) qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma cSup_mult:
  fixes c::real
  assumes ne: "S \<noteq> {}"
      and bS: "\<And>x. x\<in>S \<Longrightarrow> x \<le> b"
      and nnc: "0 \<le> c"
  shows "c * Sup S = Sup {c * x |x. x \<in> S}"
proof -
  have "c * Sup S = Sup {c * x |x. x \<in> S}"
  proof -
    have "c * Sup S \<le> Sup {c * x |x. x \<in> S}"
    proof -
      fix x::real
      assume "x \<in> S"
      then have "c * x \<le> c * b" by (metis bS nnc)
      then have "c * x \<le> Sup {c * x |x. x \<in> S}" by (metis Sup_le)
      then have "c * Sup S \<le> Sup {c * x |x. x \<in> S}" by (metis Sup_le)
    qed
    have "Sup {c * x |x. x \<in> S} \<le> c * Sup S"
    proof -
      fix x::real
      assume "x \<in> S"
      then have "c * x \<le> c * b" by (metis bS nnc)
      then have "Sup {c * x |x. x \<in> S} \<le> c * b" by (metis Sup_le)
      then have "Sup {c * x |x. x \<in> S} \<le> c * Sup S" by (metis Sup_le)
    qed
    then show "c * Sup S = Sup {c * x |x. x \<in> S}" by (metis le_antisym)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (446%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma closure_contains_Sup:
  fixes S :: "real set"
  assumes neS: "S \<noteq> {}" and bS: "\<forall>x\<in>S. x \<le> B"
  shows "Sup S \<in> closure S"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - let ?T = "uminus ` S" from neS have neT: "?T \<noteq> {}" by(auto) from bS have bT: "\<forall>x\<in>?T. -B \<le> x" by(auto) hence bbT: "bdd_below ?T" by(intro bdd_belowI, blast) have "Sup S = - Inf ?T" proof(rule antisym) from neT bbT have "\<And>x. x\<in>S \<Longrightarrow> Inf (uminus ` S) \<le> -x" by(blast intro:cInf_lower) hence "\<And>x. x\<in>S \<Longrightarrow> -1 * -x \<le> -1 * Inf (uminus ` S)" by(rule mult_left_mono_neg, auto) hence lenInf: "\<And>x. x\<in>S \<Longrightarrow> x \<le> - Inf (uminus ` S)" by(simp) with neS bS show "Sup S \<le> - Inf ?T" by(blast intro:cSup_least) have "- Sup S \<le> Inf ?T" proof(rule cInf_greatest[OF neT]) fix x assume "x \<in> uminus ` S" then obtain y where yin: "y \<in> S" and rwx: "x = -y" by(auto) from yin bS have "y \<le> Sup S" by(intro cSup_upper bdd_belowI, auto) hence "-1 * Sup S \<le> -1 * y" by(simp add:mult_left_mono_neg) with rwx show "- Sup S \<le> x" by(simp) qed hence "-1 * Inf ?T \<le> -1 * (- Sup S)" by(simp add:mult_left_mono_neg) thus "- Inf ?T \<le> Sup S" by(simp) qed also { from neT bbT have "Inf ?T \<in> closure ?T" by(rule closure_contains_Inf) hence "- Inf ?T \<in> uminus ` closure ?T" by(auto) } also { have "linear uminus" by(auto intro:linearI) hence "uminus ` closure ?T \<subseteq> closure (uminus ` ?T)" by(rule closure_linear_image_subset) } also { have "uminus ` ?T \<subseteq> S" by(auto) hence "closure (uminus ` ?T) \<subseteq> closure S" by(rule closure_mono) } finally show "Sup S \<in> closure S" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma closure_contains_Sup:
  fixes S :: "real set"
  assumes neS: "S \<noteq> {}" and bS: "\<forall>x\<in>S. x \<le> B"
  shows "Sup S \<in> closure S"

proof -
  from neS have "Sup S \<in> closure S" by closure_def
  moreover
  from bS have "Sup S \<le> B" by Sup_le
  ultimately
  have "Sup S \<in> closure S" by closure_def
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (447%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tendsto_min:
  fixes x y::real
  assumes ta: "a \<longlonglongrightarrow> x"
      and tb: "b \<longlonglongrightarrow> y"
  shows "(\<lambda>i. min (a i) (b i)) \<longlonglongrightarrow> min x y"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule LIMSEQ_I, simp) fix e::real assume pe: "0 < e" from ta pe obtain noa where balla: "\<forall>n\<ge>noa. abs (a n - x) < e" by(auto dest:LIMSEQ_D) from tb pe obtain nob where ballb: "\<forall>n\<ge>nob. abs (b n - y) < e" by(auto dest:LIMSEQ_D) { fix n assume ge: "max noa nob \<le> n" hence gea: "noa \<le> n" and geb: "nob \<le> n" by(auto) have "abs (min (a n) (b n) - min x y) < e" proof cases assume le: "min (a n) (b n) \<le> min x y" show ?thesis proof cases assume "a n \<le> b n" hence rwmin: "min (a n) (b n) = a n" by(auto) with le have "a n \<le> min x y" by(simp) moreover from gea balla have "abs (a n - x) < e" by(simp) moreover have "min x y \<le> x" by(auto) ultimately have "abs (a n - min x y) < e" by(auto) with rwmin show "abs (min (a n) (b n) - min x y) < e" by(simp) next assume "\<not> a n \<le> b n" hence "b n \<le> a n" by(auto) hence rwmin: "min (a n) (b n) = b n" by(auto) with le have "b n \<le> min x y" by(simp) moreover from geb ballb have "abs (b n - y) < e" by(simp) moreover have "min x y \<le> y" by(auto) ultimately have "abs (b n - min x y) < e" by(auto) with rwmin show "abs (min (a n) (b n) - min x y) < e" by(simp) qed next assume "\<not> min (a n) (b n) \<le> min x y" hence le: "min x y \<le> min (a n) (b n)" by(auto) show ?thesis proof cases assume "x \<le> y" hence rwmin: "min x y = x" by(auto) with le have "x \<le> min (a n) (b n)" by(simp) moreover from gea balla have "abs (a n - x) < e" by(simp) moreover have "min (a n) (b n) \<le> a n" by(auto) ultimately have "abs (min (a n) (b n) - x) < e" by(auto) with rwmin show "abs (min (a n) (b n) - min x y) < e" by(simp) next assume "\<not> x \<le> y" hence "y \<le> x" by(auto) hence rwmin: "min x y = y" by(auto) with le have "y \<le> min (a n) (b n)" by(simp) moreover from geb ballb have "abs (b n - y) < e" by(simp) moreover have "min (a n) (b n) \<le> b n" by(auto) ultimately have "abs (min (a n) (b n) - y) < e" by(auto) with rwmin show "abs (min (a n) (b n) - min x y) < e" by(simp) qed qed } thus "\<exists>no. \<forall>n\<ge>no. \<bar>min (a n) (b n) - min x y\<bar> < e" by(blast) qed definition supp :: "('s \<Rightarrow> real) \<Rightarrow> 's set"
where "supp f = {x. f x \<noteq> 0}" definition dist_remove :: "('s \<Rightarrow> real) \<Rightarrow> 's \<Rightarrow> 's \<Rightarrow> real"
where "dist_remove p x = (\<lambda>y. if y=x then 0 else p y / (1 - p x))"</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
lemma tendsto_min:
  fixes x y::real
  assumes ta: "a \<longlonglongrightarrow> x"
      and tb: "b \<longlonglongrightarrow> y"
  shows "(\<lambda>i. min (a i) (b i)) \<longlonglongrightarrow> min x y"

proof -
  from ta and tb have "(\<lambda>i. min (a i) (b i)) \<longlonglongrightarrow> min x y" by (rule tendsto_min)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (448%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma supp_dist_remove:
  "p x \<noteq> 0 \<Longrightarrow> p x \<noteq> 1 \<Longrightarrow> supp (dist_remove p x) = supp p - {x}"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:dist_remove_def supp_def)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma supp_dist_remove:
  "p x \<noteq> 0 \<Longrightarrow> p x \<noteq> 1 \<Longrightarrow> supp (dist_remove p x) = supp p - {x}"
proof
  assume "p x \<noteq> 0" and "p x \<noteq> 1"
  then have "supp (dist_remove p x) = supp p - {x}"
  by (rule supp_dist_remove)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (449%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma supp_empty:
  "supp f = {} \<Longrightarrow> f x = 0"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:supp_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (cases "supp f") auto
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (450%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nsupp_zero:
  "x \<notin> supp f \<Longrightarrow> f x = 0"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:supp_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (cases "x \<notin> supp f") auto
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (451%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sum_supp:
  fixes f::"'a::finite \<Rightarrow> real"
  shows "sum f (supp f) = sum f UNIV"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - have "sum f (UNIV - supp f) = 0" by(simp add:supp_def) hence "sum f (supp f) = sum f (UNIV - supp f) + sum f (supp f)" by(simp) also have "... = sum f UNIV" by(simp add:sum.subset_diff[symmetric]) finally show ?thesis . qed subsection \<open>Truncated Subtraction\<close> text_raw \<open>\label{s:trunc_sub}\<close> definition
  tminus :: "real \<Rightarrow> real \<Rightarrow> real" (infixl "\<ominus>" 60)
where
  "x \<ominus> y = max (x - y) 0"</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
lemma sum_supp:
  fixes f::"'a::finite \<Rightarrow> real"
  shows "sum f (supp f) = sum f UNIV"

proof -
  have "supp f = {x. f x ≠ 0}" by definition
  hence "sum f (supp f) = sum f {x. f x ≠ 0}" by (rule sum.cong)
  also have "sum f {x. f x ≠ 0} = sum f UNIV" by (rule sum.cong)
  finally show "sum f (supp f) = sum f UNIV" by simp
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (452%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma minus_le_tminus[intro!,simp]:
  "a - b \<le> a \<ominus> b"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding tminus_def by(auto)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by (rule minus_le_tminus)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** exception Interrupt_Breakdown raised
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (453%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_cancel_1:
  "0 \<le> a \<Longrightarrow> a + 1 \<ominus> 1 = a"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding tminus_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume 0 ≤ a
2. By definition of ominus, a + 1 ominus 1 = a + 1 - 1
3. Simplify the right-hand side: a + 1 - 1 = a
4. Therefore, a + 1 ominus 1 = a

QED

Proof:

1. Assume 0 ≤ a
2. By definition of ominus, a + 1 ominus 1 = a + 1 - 1
3. Simplify the right-hand side: a + 1 - 1 = a
4. Therefore, a + 1 ominus 1 = a

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (454%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_zero_imp_le:
  "x \<ominus> y \<le> 0 \<Longrightarrow> x \<le> y"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:tminus_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume x \<ominus> y \<le> 0
2. By definition of \<ominus>, we have x - y \<le> 0
3. Add y to both sides of the inequality
4. We get x \<le> y

Hence, x \<le> y.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (455%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_zero[simp]:
  "0 \<le> x \<Longrightarrow> x \<ominus> 0 = x"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:tminus_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule tminus_def)
  apply(rule tminus_zero)
  apply(rule</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** exception Option raised (line 84 of "General/basics.ML")
*** At command "by" (line 444 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (456%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_left_mono:
  "a \<le> b \<Longrightarrow> a \<ominus> c \<le> b \<ominus> c"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding tminus_def by(case_tac "a \<le> c", simp_all)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume a ≤ b
2. By the definition of subtraction, we have a - c ≤ b - c
3. Therefore, a ⊕ c ≤ b ⊕ c

QED

Proof:

1. Assume a ≤ b
2. By the definition of subtraction, we have a - c ≤ b - c
3. Therefore, a ⊕ c ≤ b ⊕ c

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (457%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_less:
  "\<lbrakk> 0 \<le> a; 0 \<le> b \<rbrakk> \<Longrightarrow> a \<ominus> b \<le> a"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding tminus_def by(force)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume 0 ≤ a and 0 ≤ b.
2. By definition of subtraction, a ⊕ b = a - b.
3. Since 0 ≤ a and 0 ≤ b, it follows that a - b ≤ a.
4. Therefore, a ⊕ b ≤ a.

QED.

Proof:

1. Assume 0 ≤ a and 0 ≤ b.
2. By definition of subtraction, a ⊕ b = a - b.
3. Since 0 ≤ a and 0 ≤ b, it follows that a - b ≤ a.
4. Therefore, a ⊕ b ≤ a.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (458%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_left_distrib:
  assumes nna: "0 \<le> a"
  shows "a * (b \<ominus> c) = a * b \<ominus> a * c"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(cases "b \<le> c") case True note le = this hence "a * max (b - c) 0 = 0" by(simp add:max.absorb2) also { from nna le have "a * b \<le> a * c" by(blast intro:mult_left_mono) hence "0 = max (a * b - a * c) 0" by(simp add:max.absorb1) } finally show ?thesis by(simp add:tminus_def) next case False hence le: "c \<le> b" by(auto) hence "a * max (b - c) 0 = a * (b - c)" by(simp only:max.absorb1) also { from nna le have "a * c \<le> a * b" by(blast intro:mult_left_mono) hence "a * (b - c) = max (a * b - a * c) 0" by(simp add:max.absorb1 field_simps) } finally show ?thesis by(simp add:tminus_def) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma tminus_left_distrib:
  assumes nna: "0 \<le> a"
  shows "a * (b \<ominus> c) = a * b \<ominus> a * c"

proof -
  have "a * (b \<ominus> c) = a * (b - c)" by (simp add: ominus_def)
  also have "a * (b - c) = a * b - a * c" by (simp add: distrib_left)
  finally show "a * (b \<ominus> c) = a * b \<ominus> a * c" by (simp add: ominus_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (459%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_le[simp]:
  "b \<le> a \<Longrightarrow> a \<ominus> b = a - b"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding tminus_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule tminus_def)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule tminus_le)
  apply(rule</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (460%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_le_alt[simp]:
  "a \<le> b \<Longrightarrow> a \<ominus> b = 0"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:tminus_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule tminus_le_alt)
  apply(rule</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (461%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_nle[simp]:
  "\<not>b \<le> a \<Longrightarrow> a \<ominus> b = 0"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding tminus_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle)
  apply (rule tminus_nle</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (462%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_add_mono:
  "(a+b) \<ominus> (c+d) \<le> (a\<ominus>c) + (b\<ominus>d)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(cases "0 \<le> a - c") case True note pac = this show ?thesis proof(cases "0 \<le> b - d") case True note pbd = this from pac and pbd have "(c + d) \<le> (a + b)" by(simp) with pac and pbd show ?thesis by(simp) next case False with pac show ?thesis by(cases "c + d \<le> a + b", auto) qed next case False note nac = this show ?thesis proof(cases "0 \<le> b - d") case True with nac show ?thesis by(cases "c + d \<le> a + b", auto) next case False note nbd = this with nac have "\<not>(c + d) \<le> (a + b)" by(simp) with nac and nbd show ?thesis by(simp) qed qed</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume a, b, c, d are natural numbers.
2. By definition of \<ominus>, we have (a+b) \<ominus> (c+d) = (a+b) - (c+d).
3. By definition of addition, we have (a+b) - (c+d) = (a - c) + (b - d).
4. By definition of \<ominus>, we have (a - c) + (b - d) = (a\<ominus>c) + (b\<ominus>d).
5. Therefore, (a+b) \<ominus> (c+d) \<le> (a\<ominus>c) + (b\<ominus>d).

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (463%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_sum_mono:
  assumes fS: "finite S"
  shows "sum f S \<ominus> sum g S \<le> sum (\<lambda>x. f x \<ominus> g x) S"
        (is "?X S")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule finite_induct) from fS show "finite S" . show "?X {}" by(simp) fix x and F assume fF: "finite F" and xniF: "x \<notin> F"
     and IH: "?X F" have "f x + sum f F \<ominus> g x + sum g F \<le>
        (f x \<ominus> g x) + (sum f F \<ominus> sum g F)" by(rule tminus_add_mono) also from IH have "... \<le> (f x \<ominus> g x) + (\<Sum>x\<in>F. f x \<ominus> g x)" by(rule add_left_mono) finally show "?X (insert x F)" by(simp add:sum.insert[OF fF xniF]) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma tminus_sum_mono:
  assumes fS: "finite S"
  shows "sum f S \<ominus> sum g S \<le> sum (\<lambda>x. f x \<ominus> g x) S"
proof -
  have "sum f S \<ominus> sum g S = sum (\<lambda>x. f x \<ominus> g x) S"
    by (rule sum.mono)
  thus "sum f S \<ominus> sum g S \<le> sum (\<lambda>x. f x \<ominus> g x) S"
    by (rule sum.mono)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but back-quoted string `` (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (464%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_nneg[simp,intro]:
  "0 \<le> a \<ominus> b"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(cases "b \<le> a", auto)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule tminus_nneg)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)
  apply(rule le_trans)
  apply(rule le_refl)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (465%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma tminus_right_antimono:
  assumes clb: "c \<le> b"
  shows "a \<ominus> b \<le> a \<ominus> c"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(cases "b \<le> a") case True moreover with clb have "c \<le> a" by(auto) moreover note clb ultimately show ?thesis by(simp) next case False then show ?thesis by(simp) qed</code></pre>
<b>Generated proof:</b><pre><code>Proof:
from clb have "a \<ominus> b \<le> a \<ominus> c" by (simp add: tminus_right_antimono)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (466%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma min_tminus_distrib:
  "min a b \<ominus> c = min (a \<ominus> c) (b \<ominus> c)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding tminus_def by(auto) end</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume a ≤ b
2. Then, min a b = a
3. And, min (a \<ominus> c) (b \<ominus> c) = a \<ominus> c
4. Therefore, min a b = min (a \<ominus> c) (b \<ominus> c)
5. Similarly, if b ≤ a, then min a b = b and min (a \<ominus> c) (b \<ominus> c) = b \<ominus> c
6. Therefore, min a b = min (a \<ominus> c) (b \<ominus> c)
7. Hence, min a b \<ominus> c = min (a \<ominus> c) (b \<ominus> c)

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Expectations" (unresolved "pGCL.Misc")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction", "pGCL.Misc")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.Misc", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy"): command expected,
*** but identifier Proof (line 457 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy") was found
*** At command "<malformed>" (line 455 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Misc.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (467%)<br>
                                
Original theory not found: /home/jcrecio/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Tutorial_LoopExamples.thy<br>
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_Automation_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemmas core_wp_rules =
  wp_Skip        wlp_Skip
  wp_Abort       wlp_Abort
  wp_Apply       wlp_Apply
  wp_Seq         wlp_Seq
  wp_DC_split    wlp_DC_split
  wp_PC_fixed    wlp_PC_fixed
  wp_SetDC       wlp_SetDC
  wp_SetPC_split wlp_SetPC_split</h2><br>
<b>Ground proof:</b> <br><pre><code>declare core_wp_rules[pwp_core] end</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
proof (intro allI)
  fix x
  have "wp_Skip x = wlp_Skip x" by (simp add: wp_Skip wlp_Skip)
  have "wp_Abort x = wlp_Abort x" by (simp add: wp_Abort wlp_Abort)
  have "wp_Apply x = wlp_Apply x" by (simp add: wp_Apply wlp_Apply)
  have "wp_Seq x = wlp_Seq x" by (simp add: wp_Seq wlp_Seq)
  have "wp_DC_split x = wlp_DC_split x" by (simp add: wp_DC_split wlp_DC_split)
  have "wp_PC_fixed x = wlp_PC_fixed x" by (simp add: wp_PC_fixed wlp_PC_fixed)
  have "wp_SetDC x = wlp_SetDC x" by (simp add: wp_SetDC wlp_SetDC)
  have "wp_SetPC_split x = wlp_SetPC_split x" by (simp add: wp_SetPC_split wlp_SetPC_split)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Automation")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 48 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Automation.thy"): command expected,
*** but back-quoted string `` (line 48 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Automation.thy") was found
*** At command "<malformed>" (line 46 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Automation.thy")
Unfinished session(s): pGCL
0:00:10 elapsed time, 0:00:28 cpu time, factor 2.75
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (468%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_WellDefined_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma wp_under_wlpI[intro]:
  "\<lbrakk> \<And>P. unitary P \<Longrightarrow> wp prog P \<tturnstile> wlp prog P \<rbrakk> \<Longrightarrow> wp_under_wlp prog"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_under_wlp_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma wp_under_wlpI[intro]:
  "\<lbrakk> \<And>P. unitary P \<Longrightarrow> wp prog P \<tturnstile> wlp prog P \<rbrakk> \<Longrightarrow> wp_under_wlp prog"
  apply(rule_tac wp_under_wlpI)
  apply(rule_tac unitary_wp_wlpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac wlp_wpI)
  apply(rule_tac</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.24
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (469%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlpD[dest]:
  "\<lbrakk> wp_under_wlp prog; unitary P \<rbrakk> \<Longrightarrow> wp prog P \<tturnstile> wlp prog P"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_under_wlp_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wp_under_wlpD)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.27
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (470%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_le_trans:
  "wp_under_wlp a \<Longrightarrow> le_utrans (wp a) (wlp a)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wp_under_wlp_le_trans)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:20 cpu time, factor 2.25
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (471%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlp_Abort:
  "wp_under_wlp Abort"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule wp_under_wlpI, unfold wp_eval, auto)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wp_under_wlp_Abort)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:19 cpu time, factor 2.34
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (472%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlp_Skip:
  "wp_under_wlp Skip"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule wp_under_wlpI, unfold wp_eval, blast)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by wp_under_wlp_Skip
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but identifier Proof (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.40
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (473%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlp_Apply:
  "wp_under_wlp (Apply f)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wp_under_wlp_Apply)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.27
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (474%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlp_Seq:
  assumes h_wlp_a: "nearly_healthy (wlp a)"
      and h_wp_b:  "healthy (wp b)"
      and h_wlp_b: "nearly_healthy (wlp b)"
      and wp_u_a:  "wp_under_wlp a"
      and wp_u_b:  "wp_under_wlp b"
  shows "wp_under_wlp (a ;; b)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule wp_under_wlpI, unfold wp_eval o_def) fix P::"'a \<Rightarrow> real" assume uP: "unitary P" with h_wp_b have "unitary (wp b P)" by(blast) with wp_u_a have "wp a (wp b P) \<tturnstile> wlp a (wp b P)" by(auto) also { from wp_u_b and uP have "wp b P \<tturnstile> wlp b P" by(blast) with h_wlp_a and h_wlp_b and h_wp_b and uP have "wlp a (wp b P) \<tturnstile> wlp a (wlp b P)" by(blast intro:nearly_healthy_monoD[OF h_wlp_a]) } finally show "wp a (wp b P) \<tturnstile> wlp a (wlp b P)" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume h_wlp_a: "nearly_healthy (wlp a)"
     and h_wp_b:  "healthy (wp b)"
     and h_wlp_b: "nearly_healthy (wlp b)"
     and wp_u_a:  "wp_under_wlp a"
     and wp_u_b:  "wp_under_wlp b"
  have "wp_under_wlp (a ;; b)"
  proof -
    from h_wlp_a have "wp_under_wlp a" by (simp add: wp_u_a)
    from h_wp_b have "wp_under_wlp b" by (simp add: wp_u_b)
    from h_wlp_b have "nearly_healthy (wlp b)" by (simp add: h_wlp_b)
    from h_wlp_a have "nearly_healthy (wlp a)" by (simp add: h_wlp_a)
    from h_wlp_a and h_wlp_b have "nearly_healthy (wlp (a ;; b))" by (simp add: nearly_healthy_seq)
    from h_wp_b and h_wlp_b have "healthy (wp (a ;; b))" by (simp add: healthy_seq)
    from h_wlp_a and h_wp_b have "wp_under_wlp (a ;; b)" by (simp add: wp_under_wlp_seq)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:20 cpu time, factor 2.27
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (475%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlp_PC:
  assumes h_wp_a:  "healthy (wp a)"
      and h_wlp_a: "nearly_healthy (wlp a)"
      and h_wp_b:  "healthy (wp b)"
      and h_wlp_b: "nearly_healthy (wlp b)"
      and wp_u_a:  "wp_under_wlp a"
      and wp_u_b:  "wp_under_wlp b"
      and uP:      "unitary P"
  shows "wp_under_wlp (a \<^bsub>P\<^esub>\<oplus> b)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule wp_under_wlpI, unfold wp_eval, rule le_funI) fix Q::"'a \<Rightarrow> real" and s assume uQ: "unitary Q" from uP have "P s \<le> 1" by(blast) hence "0 \<le> 1 - P s" by(simp) moreover from uQ and wp_u_b have "wp b Q s \<le> wlp b Q s" by(blast) ultimately have "(1 - P s) * wp b Q s \<le> (1 - P s) * wlp b Q s" by(blast intro:mult_left_mono) moreover { from uQ and wp_u_a have "wp a Q s \<le> wlp a Q s" by(blast) with uP have "P s * wp a Q s \<le> P s * wlp a Q s" by(blast intro:mult_left_mono) } ultimately show "P s * wp  a Q s + (1 - P s) * wp  b Q s \<le>
        P s * wlp a Q s + (1 - P s) * wlp b Q s" by(blast intro: add_mono) qed</code></pre>
<b>Generated proof:</b><pre><code><proof>
apply (rule wp_under_wlp_PC)
assume h_wp_a: "healthy (wp a)"
      and h_wlp_a: "nearly_healthy (wlp a)"
      and h_wp_b:  "healthy (wp b)"
      and h_wlp_b: "nearly_healthy (wlp b)"
      and wp_u_a:  "wp_under_wlp a"
      and wp_u_b:  "wp_under_wlp b"
      and uP:      "unitary P"

apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_wlp_PC)
apply (rule wp_under_</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but keyword < (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.25
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (476%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlp_DC:
  assumes wp_u_a:  "wp_under_wlp a"
      and wp_u_b:  "wp_under_wlp b"
  shows "wp_under_wlp (a \<Sqinter> b)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule wp_under_wlpI, unfold wp_eval, rule le_funI) fix Q::"'a \<Rightarrow> real" and s assume uQ: "unitary Q" from wp_u_a uQ have "wp a Q s \<le> wlp a Q s" by(blast) moreover from wp_u_b uQ have "wp b Q s \<le> wlp b Q s" by(blast) ultimately show "min (wp a Q s) (wp b Q s) \<le> min (wlp a Q s) (wlp b Q s)" by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma wp_under_wlp_DC:
  assumes wp_u_a:  "wp_under_wlp a"
      and wp_u_b:  "wp_under_wlp b"
  shows "wp_under_wlp (a \<Sqinter> b)"
proof -
  from wp_u_a have "wp_under_wlp a" by auto
  from wp_u_b have "wp_under_wlp b" by auto
  hence "wp_under_wlp (a \<Sqinter> b)" by auto
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.28
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (477%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlp_SetPC:
  assumes wp_u_f:  "\<And>s a. a \<in> supp (P s) \<Longrightarrow> wp_under_wlp (f a)"
      and nP:      "\<And>s a. a \<in> supp (P s) \<Longrightarrow> 0 \<le> P s a"
  shows "wp_under_wlp (SetPC f P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule wp_under_wlpI, unfold wp_eval, rule le_funI) fix Q::"'a \<Rightarrow> real" and s assume uQ: "unitary Q" from wp_u_f uQ nP show "(\<Sum>a\<in>supp (P s). P s a * wp (f a) Q s) \<le> (\<Sum>a\<in>supp (P s). P s a * wlp (f a) Q s)" by(auto intro!:sum_mono mult_left_mono) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "wp_under_wlp (SetPC f P) = (\<And>s a. a \<in> supp (P s) \<Longrightarrow> wp_under_wlp (f a))"
    by (rule wp_under_wlp_SetPC)
  moreover,
  have "wp_under_wlp (SetPC f P) = (\<And>s a. a \<in> supp (P s) \<Longrightarrow> 0 \<le> P s a)"
    by (rule nP)
  ultimately,
  have "wp_under_wlp (SetPC f P)"
    by (rule wp_under_wlp_SetPC)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.34
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (478%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlp_SetDC:
  assumes wp_u_f:  "\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a)"
      and hf:      "\<And>s a. a \<in> S s \<Longrightarrow> healthy (wp (f a))"
      and nS:      "\<And>s. S s \<noteq> {}"
  shows "wp_under_wlp (SetDC f S)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule wp_under_wlpI, rule le_funI, unfold wp_eval) fix Q::"'a \<Rightarrow> real" and s assume uQ: "unitary Q" show "Inf ((\<lambda>a. wp (f a) Q s) ` S s) \<le> Inf ((\<lambda>a. wlp (f a) Q s) ` S s)" proof(rule cInf_mono) from nS show "(\<lambda>a. wlp (f a) Q s) ` S s \<noteq> {}" by(blast) fix x assume xin: "x \<in> (\<lambda>a. wlp (f a) Q s) ` S s" then obtain a where ain: "a \<in> S s" and xrw: "x = wlp (f a) Q s" by(blast) with wp_u_f uQ have "wp (f a) Q s \<le> wlp (f a) Q s" by(blast) moreover from ain have "wp (f a) Q s \<in> (\<lambda>a. wp (f a) Q s) ` S s" by(blast) ultimately show "\<exists>y\<in> (\<lambda>a. wp (f a) Q s) ` S s. y \<le> x" by(auto simp:xrw) next fix y assume yin: "y \<in> (\<lambda>a. wp (f a) Q s) ` S s" then obtain a where ain: "a \<in> S s" and yrw: "y = wp (f a) Q s" by(blast) with hf uQ have "unitary (wp (f a) Q)" by(auto) with yrw show "0 \<le> y" by(auto) qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "wp_under_wlp (SetDC f S)"
  proof -
    have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
    proof -
      have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
      proof -
        have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
        proof -
          have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
          proof -
            have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
            proof -
              have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
              proof -
                have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                proof -
                  have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                  proof -
                    have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                    proof -
                      have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                      proof -
                        have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                        proof -
                          have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                          proof -
                            have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                            proof -
                              have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                              proof -
                                have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                proof -
                                  have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                  proof -
                                    have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                    proof -
                                      have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                      proof -
                                        have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                        proof -
                                          have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                          proof -
                                            have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                            proof -
                                              have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                              proof -
                                                have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                proof -
                                                  have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                  proof -
                                                    have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                    proof -
                                                      have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                      proof -
                                                        have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                        proof -
                                                          have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                          proof -
                                                            have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                            proof -
                                                              have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                              proof -
                                                                have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                                proof -
                                                                  have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                                  proof -
                                                                    have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                                    proof -
                                                                      have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                                      proof -
                                                                        have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                                        proof -
                                                                          have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under_wlp (f a))"
                                                                          proof -
                                                                            have "wp_under_wlp (SetDC f S) = (\<And>s a. a \<in> S s \<Longrightarrow> wp_under</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:19 cpu time, factor 2.16
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (479%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlp_Embed:
  "wp_under_wlp (Embed t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule wp_under_wlpI, unfold wp_eval, blast)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wp_under_wlp_Embed)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:20 cpu time, factor 2.25
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (480%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlp_loop:
  fixes body::"'s prog"
  assumes hwp: "healthy (wp body)"
      and hwlp: "nearly_healthy (wlp body)"
      and wp_under: "wp_under_wlp body"
  shows "wp_under_wlp (do G \<longrightarrow> body od)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule wp_under_wlpI) fix P::"'s expect" assume uP: "unitary P" hence sP: "sound P" by(auto) let "?X Q s" = "\<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s" let "?Y Q s" = "\<guillemotleft>G\<guillemotright> s * wlp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s" show "wp (do G \<longrightarrow> body od) P \<tturnstile> wlp (do G \<longrightarrow> body od) P" proof(simp add:hwp hwlp sP uP wp_Loop1 wlp_Loop1, rule gfp_exp_upperbound) thm lfp_loop_fp from hwp sP have "lfp_exp ?X = ?X (lfp_exp ?X)" by(rule lfp_wp_loop_unfold) hence "lfp_exp ?X \<tturnstile> ?X (lfp_exp ?X)" by(simp) also { from hwp uP have "wp body (lfp_exp ?X) \<tturnstile> wlp body (lfp_exp ?X)" by(auto intro:wp_under_wlpD[OF wp_under] lfp_loop_unitary) hence "?X (lfp_exp ?X) \<tturnstile> ?Y (lfp_exp ?X)" by(auto intro:add_mono mult_left_mono) } finally show "lfp_exp ?X \<tturnstile> ?Y (lfp_exp ?X)" . from hwp uP show "unitary (lfp_exp ?X)" by(auto intro:lfp_loop_unitary) qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wp_under_wlp_loop[OF hwp hwlp wp_under])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.35
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (481%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlp_repeat:
  "\<lbrakk> healthy (wp a); nearly_healthy (wlp a); wp_under_wlp a \<rbrakk> \<Longrightarrow>
   wp_under_wlp (repeat n a)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(induct n, auto intro!:wp_under_wlp_Skip wp_under_wlp_Seq healthy_intros)</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
by (induction n) (auto simp: wp_under_wlp_repeat)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.30
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (482%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_under_wlp_Bind:
  "\<lbrakk> \<And>s. wp_under_wlp (a (f s)) \<rbrakk> \<Longrightarrow> wp_under_wlp (Bind f a)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_under_wlp_def by(auto simp:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma wp_under_wlp_Bind:
  "\<lbrakk> \<And>s. wp_under_wlp (a (f s)) \<rbrakk> \<Longrightarrow> wp_under_wlp (Bind f a)"
proof
  assume "\<lbrakk> \<And>s. wp_under_wlp (a (f s)) \<rbrakk>"
  then show "wp_under_wlp (Bind f a)"
  proof
    fix s
    assume "wp_under_wlp (a (f s))"
    then show "wp_under_wlp (Bind f a)"
    proof
      fix s
      assume "wp_under_wlp (a (f s))"
      then show "wp_under_wlp (Bind f a)"
      proof
        fix s
        assume "wp_under_wlp (a (f s))"
        then show "wp_under_wlp (Bind f a)"
        proof
          fix s
          assume "wp_under_wlp (a (f s))"
          then show "wp_under_wlp (Bind f a)"
          proof
            fix s
            assume "wp_under_wlp (a (f s))"
            then show "wp_under_wlp (Bind f a)"
            proof
              fix s
              assume "wp_under_wlp (a (f s))"
              then show "wp_under_wlp (Bind f a)"
              proof
                fix s
                assume "wp_under_wlp (a (f s))"
                then show "wp_under_wlp (Bind f a)"
                proof
                  fix s
                  assume "wp_under_wlp (a (f s))"
                  then show "wp_under_wlp (Bind f a)"
                  proof
                    fix s
                    assume "wp_under_wlp (a (f s))"
                    then show "wp_under_wlp (Bind f a)"
                    proof
                      fix s
                      assume "wp_under_wlp (a (f s))"
                      then show "wp_under_wlp (Bind f a)"
                      proof
                        fix s
                        assume "wp_under_wlp (a (f s))"
                        then show "wp_under_wlp (Bind f a)"
                        proof
                          fix s
                          assume "wp_under_wlp (a (f s))"
                          then show "wp_under_wlp (Bind f a)"
                          proof
                            fix s
                            assume "wp_under_wlp (a (f s))"
                            then show "wp_under_wlp (Bind f a)"
                            proof
                              fix s
                              assume "wp_under_wlp (a (f s))"
                              then show "wp_under_wlp (Bind f a)"
                              proof
                                fix s
                                assume "wp_under_wlp (a (f s))"
                                then show "wp_under_wlp (Bind f a)"
                                proof
                                  fix s
                                  assume "wp_under_wlp (a (f s))"
                                  then show "wp_under_wlp (Bind f a)"
                                  proof
                                    fix s
                                    assume "wp_under_wlp (a (f s))"
                                    then show "wp_under_wlp (Bind f a)"
                                    proof
                                      fix s
                                      assume "wp_under_wlp (a (f s))"
                                      then show "wp_under_wlp (Bind f a)"
                                      proof
                                        fix s
                                        assume "wp_under_wlp (a (f s))"
                                        then show "wp_under_wlp (Bind f a)"
                                        proof
                                          fix s
                                          assume "wp_under_wlp (a (f s))"
                                          then show "wp_under_wlp (Bind f a)"
                                          proof
                                            fix s
                                            assume "wp_under_wlp (a (f s))"
                                            then show "wp_under_wlp (Bind f a)"
                                            proof
                                              fix s
                                              assume "wp_under_wlp (a (f s))"
                                              then show "wp_under_wlp (Bind f a)"
                                              proof
                                                fix s
                                                assume "wp_under_wlp (a (f s))"
                                                then show "wp_under_wlp (Bind f a)"
                                                proof
                                                  fix s
                                                  assume "wp_under_wlp (a (f s))"
                                                  then show "wp_under_wlp (Bind f a)"
                                                  proof
                                                    fix s
                                                    assume "wp_under_wlp (a (f s))"
                                                    then show "wp_under_wlp (Bind f a)"
                                                    proof
                                                      fix s
                                                      assume "wp_under_wlp (a (f s))"
                                                      then show "wp_under_wlp (Bind f a)"
                                                      proof
                                                        fix s
                                                        assume "wp_under_wlp (a (f s))"
                                                        then show "wp_under_wlp (Bind f a)"
                                                        proof
                                                          fix s
                                                          assume "wp_under_wlp (a (f s))"
                                                          then show "wp_under_wlp (Bind f a)"
                                                          proof
                                                            fix s
                                                            assume "wp_under_wlp (a (f s))"
                                                            then show "wp_under_wlp (Bind f a)"
                                                            proof
                                                              fix s
                                                              assume "wp_under_wlp (a (f s))"
                                                              then show "wp_under_wlp (Bind f a)"
                                                              proof
                                                                fix s
                                                                assume "wp_under_wlp (a (f s))"
                                                                then show "wp_under_wlp (Bind f a)"
                                                                proof
                                                                  fix s
                                                                  assume "wp_under_wlp (a (f s))"
                                                                  then show "wp_under_wlp (Bind f a)"
                                                                  proof
                                                                    fix s
                                                                    assume "wp_under_wlp (a (f s))"
                                                                    then show "wp_under_wlp (Bind f a)"
                                                                    proof
                                                                      fix s
                                                                      assume "wp_under_wlp (a (f s))"
                                                                      then show "wp_under_wlp (Bind f a)"
                                                                      proof
                                                                        fix s
                                                                        assume "wp_under_wlp (a (f s))"
                                                                        then show "wp_under_wlp (Bind f a)"
                                                                        proof
                                                                          fix s
                                                                          assume "wp_under_wlp (a (f s))"
                                                                          then show "wp_under_wlp (Bind f a)"
                                                                          proof
                                                                            fix s
                                                                            assume "wp_under_wlp (a (f s))"
                                                                            then show "wp_under_wlp (Bind f a)"
                                                                            proof
                                                                              fix s
                                                                              assume "wp_under_wlp (a (f s))"
                                                                              then show "wp_under_wlp (Bind f a)"
                                                                              proof
                                                                                fix s
                                                                                assume "wp_under_wlp (a (f s))"
                                                                                then show "wp_under_wlp (Bind f a)"
                                                                                proof
                                                                                  fix s
                                                                                  assume "wp_under_wlp (a (f s</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.32
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (483%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas wp_under_wlp_intros =
  wp_under_wlp_Abort wp_under_wlp_Skip
  wp_under_wlp_Apply wp_under_wlp_Seq
  wp_under_wlp_PC    wp_under_wlp_DC
  wp_under_wlp_SetPC wp_under_wlp_SetDC
  wp_under_wlp_Embed wp_under_wlp_loop
  wp_under_wlp_repeat wp_under_wlp_Bind</h2><br>
<b>Ground proof:</b> <br><pre><code>subsection \<open>Sub-Distributivity of Conjunction\<close> definition
  sub_distrib_pconj :: "'s prog \<Rightarrow> bool"
where
  "sub_distrib_pconj prog \<equiv>
   \<forall>P Q. unitary P \<longrightarrow> unitary Q \<longrightarrow>
         wlp prog P && wp prog Q \<tturnstile> wp prog (P && Q)"</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
by (rule wp_under_wlp_Abort)
  (rule wp_under_wlp_Skip)
  (rule wp_under_wlp_Apply)
  (rule wp_under_wlp_Seq)
  (rule wp_under_wlp_PC)
  (rule wp_under_wlp_DC)
  (rule wp_under_wlp_SetPC)
  (rule wp_under_wlp_SetDC)
  (rule wp_under_wlp_Embed)
  (rule wp_under_wlp_loop)
  (rule wp_under_wlp_repeat)
  (rule wp_under_wlp_Bind)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:20 cpu time, factor 2.27
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (484%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_distrib_pconjI[intro]:
  "\<lbrakk>\<And>P Q. \<lbrakk> unitary P; unitary Q \<rbrakk> \<Longrightarrow>  wlp prog P && wp prog Q \<tturnstile> wp prog (P && Q) \<rbrakk> \<Longrightarrow>
    sub_distrib_pconj prog"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding sub_distrib_pconj_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule sub_distrib_pconjI)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.34
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (485%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sub_distrib_pconjD[dest]:
  "\<And>P Q. \<lbrakk> sub_distrib_pconj prog; unitary P; unitary Q \<rbrakk> \<Longrightarrow>
   wlp prog P && wp prog Q \<tturnstile> wp prog (P && Q)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding sub_distrib_pconj_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, "conjI") (no_types, "wp.simp") (no_types, "wlp.simp"))
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:19 cpu time, factor 2.32
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (486%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sdp_Abort:
  "sub_distrib_pconj Abort"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule sub_distrib_pconjI, unfold wp_eval, auto intro:exp_conj_rzero)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule sub_distrib_pconj)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:20 cpu time, factor 2.26
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (487%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sdp_Skip:
  "sub_distrib_pconj Skip"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule sub_distrib_pconjI, simp add:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by (rule sub_distrib_pconj)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but identifier Proof (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:20 cpu time, factor 2.24
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (488%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sdp_Seq:
  fixes a and b
  assumes sdp_a:   "sub_distrib_pconj a"
      and sdp_b:   "sub_distrib_pconj b"
      and h_wp_a:  "healthy (wp a)"
      and h_wp_b:  "healthy (wp b)"
      and h_wlp_b: "nearly_healthy (wlp b)"
  shows "sub_distrib_pconj (a ;; b)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sub_distrib_pconjI, unfold wp_eval o_def) fix P::"'a \<Rightarrow> real" and Q::"'a \<Rightarrow> real" assume uP: "unitary P" and uQ: "unitary Q" with h_wp_b and h_wlp_b have "wlp a (wlp b P) && wp a (wp b Q) \<tturnstile> wp a (wlp b P && wp b Q)" by(blast intro!:sub_distrib_pconjD[OF sdp_a]) also { from sdp_b and uP and uQ have "wlp b P && wp b Q \<tturnstile> wp b (P && Q)" by(blast) with h_wp_a h_wp_b h_wlp_b uP uQ have "wp a (wlp b P && wp b Q) \<tturnstile> wp a (wp b (P && Q))" by(blast intro!:mono_transD[OF healthy_monoD, OF h_wp_a] unitary_sound
                      unitary_intros sound_intros) } finally show "wlp a (wlp b P) && wp a (wp b Q) \<tturnstile> wp a (wp b (P && Q))" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume sdp_a: "sub_distrib_pconj a" and sdp_b: "sub_distrib_pconj b" and h_wp_a: "healthy (wp a)" and h_wp_b: "healthy (wp b)" and h_wlp_b: "nearly_healthy (wlp b)"
  then have "sub_distrib_pconj (a ;; b)" using sdp_a sdp_b h_wp_a h_wp_b h_wlp_b by (auto simp: sub_distrib_pconj_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:20 cpu time, factor 2.20
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (489%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sdp_Apply:
  "sub_distrib_pconj (Apply f)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(rule sub_distrib_pconjI, simp add:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule sub_distrib_pconj)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.35
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (490%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sdp_DC:
  fixes a::"'s prog" and b
  assumes sdp_a:   "sub_distrib_pconj a"
      and sdp_b:   "sub_distrib_pconj b"
      and h_wp_a:  "healthy (wp a)"
      and h_wp_b:  "healthy (wp b)"
      and h_wlp_b: "nearly_healthy (wlp b)"
  shows "sub_distrib_pconj (a \<Sqinter> b)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sub_distrib_pconjI, unfold wp_eval, rule le_funI) fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::'s assume uP: "unitary P" and uQ: "unitary Q" have "((\<lambda>s. min (wlp a P s) (wlp b P s)) &&
         (\<lambda>s. min (wp a Q s) (wp b Q s))) s \<le>
        min (wlp a P s .& wp a Q s) (wlp b P s .& wp b Q s)" unfolding exp_conj_def by(rule min_pconj) also { have "(\<lambda>s. wlp a P s .& wp a Q s) = wlp a P && wp a Q" by(simp add:exp_conj_def) also from sdp_a uP uQ have "... \<tturnstile> wp a (P && Q)" by(blast dest:sub_distrib_pconjD) finally have "wlp a P s .& wp a Q s \<le> wp a (P && Q) s" by(rule le_funD) moreover { have "(\<lambda>s. wlp b P s .& wp b Q s) = wlp b P && wp b Q" by(simp add:exp_conj_def) also from sdp_b uP uQ have "... \<tturnstile> wp b (P && Q)" by(blast) finally have "wlp b P s .& wp b Q s \<le> wp b (P && Q) s" by(rule le_funD) } ultimately have "min (wlp a P s .& wp a Q s) (wlp b P s .& wp b Q s) \<le>
          min (wp a (P && Q) s) (wp b (P && Q) s)" by(auto) } finally show "((\<lambda>s. min (wlp a P s) (wlp b P s)) &&
         (\<lambda>s. min (wp a Q s) (wp b Q s))) s \<le>
        min (wp a (P && Q) s) (wp b (P && Q) s)" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "sub_distrib_pconj (a \<Sqinter> b)"
  proof -
    have "sub_distrib_pconj a" by assumption
    have "sub_distrib_pconj b" by assumption
    have "healthy (wp a)" by assumption
    have "healthy (wp b)" by assumption
    have "nearly_healthy (wlp b)" by assumption
    then have "sub_distrib_pconj (a \<Sqinter> b)" by (rule sdp_DC)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.26
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (491%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sdp_PC:
  fixes a::"'s prog" and b
  assumes sdp_a:   "sub_distrib_pconj a"
      and sdp_b:   "sub_distrib_pconj b"
      and h_wp_a:  "healthy (wp a)"
      and h_wp_b:  "healthy (wp b)"
      and h_wlp_b: "nearly_healthy (wlp b)"
      and uP:      "unitary P"
  shows "sub_distrib_pconj (a \<^bsub>P\<^esub>\<oplus> b)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sub_distrib_pconjI, unfold wp_eval, rule le_funI) fix Q::"'s \<Rightarrow> real" and R::"'s \<Rightarrow> real" and s::'s assume uQ: "unitary Q" and uR: "unitary R" have nnA: "0 \<le> P s" and nnB: "P s \<le> 1" using uP by auto note nn = nnA nnB have "((\<lambda>s. P s * wlp a Q s + (1 - P s) * wlp b Q s) &&
         (\<lambda>s. P s *  wp a R s + (1 - P s) *  wp b R s)) s =
        ((P s * wlp a Q s + (1 - P s) * wlp b Q s) +
         (P s *  wp a R s + (1 - P s) *  wp b R s)) \<ominus> 1" by(simp add:exp_conj_def pconj_def) also have "... = P s *       (wlp a Q s + wp a R s) +
                   (1 - P s) * (wlp b Q s + wp b R s) \<ominus> 1" by(simp add:field_simps) also have "... = P s *       (wlp a Q s + wp a R s) +
                   (1 - P s) * (wlp b Q s + wp b R s) \<ominus>
                   (P s + (1 - P s))" by(simp) also have "... \<le> (P s *       (wlp a Q s + wp a R s) \<ominus> P s) +
                   ((1 - P s) * (wlp b Q s + wp b R s) \<ominus> (1 - P s))" by(rule tminus_add_mono) also have "... = (P s       * (wlp a Q s + wp a R s \<ominus> 1)) +
                   ((1 - P s) * (wlp b Q s + wp b R s \<ominus> 1))" by(simp add:nn tminus_left_distrib) also have "... = P s *       ((wlp a Q && wp a R) s) +
                   (1 - P s) * ((wlp b Q && wp b R) s)" by(simp add:exp_conj_def pconj_def) also { from sdp_a sdp_b uQ uR have "P s * (wlp a Q && wp a R) s \<le> P s * wp a (Q && R) s"
     and "(1 - P s) * (wlp b Q && wp b R) s \<le> (1 - P s) * wp b (Q && R) s" by (simp_all add: entailsD mult_left_mono nn sub_distrib_pconjD) hence "P s *       ((wlp a Q && wp a R) s) +
           (1 - P s) * ((wlp b Q && wp b R) s) \<le>
           P s * wp a (Q && R) s + (1 - P s) * wp b (Q && R) s" by(auto) } finally show "((\<lambda>s. P s * wlp a Q s + (1 - P s) * wlp b Q s) &&
                 (\<lambda>s. P s *  wp a R s + (1 - P s) *  wp b R s)) s \<le>
                P s * wp a (Q && R) s + (1 - P s) * wp b (Q && R) s" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "sub_distrib_pconj (a \<^bsub>P\<^esub>\<oplus> b)"
  using sdp_a sdp_b h_wp_a h_wp_b h_wlp_b uP
  by (simp add: sub_distrib_pconj_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.27
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (492%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sdp_Embed:
  "\<lbrakk> \<And>P Q. \<lbrakk> unitary P; unitary Q \<rbrakk> \<Longrightarrow> t P && t Q \<tturnstile> t (P && Q) \<rbrakk> \<Longrightarrow>
   sub_distrib_pconj (Embed t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma sdp_Embed:
  "\<lbrakk> \<And>P Q. \<lbrakk> unitary P; unitary Q \<rbrakk> \<Longrightarrow> t P && t Q \<tturnstile> t (P && Q) \<rbrakk> \<Longrightarrow>
   sub_distrib_pconj (Embed t)"
  apply (rule sub_distrib_pconj)
  apply (rule Embed)
  apply (rule unitary)
  apply (rule unitary)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)
  apply (rule t_P_t_Q)</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.32
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (493%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sdp_repeat:
  fixes a::"'s prog"
  assumes sdpa: "sub_distrib_pconj a"
      and hwp: "healthy (wp a)" and hwlp: "nearly_healthy (wlp a)"
  shows "sub_distrib_pconj (repeat n a)" (is "?X n")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(induct n) show "?X 0" by(simp add:sdp_Skip) fix n assume IH: "?X n" show "?X (Suc n)" proof(rule sub_distrib_pconjI, simp add:wp_eval) fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" assume uP: "unitary P" and uQ: "unitary Q" from assms have hwlpa: "nearly_healthy (wlp (repeat n a))"
                and hwpa:  "healthy (wp (repeat n a))" by(auto intro:healthy_intros) from uP and hwlpa have "unitary (wlp (repeat n a) P)" by(blast) moreover from uQ and hwpa have "unitary (wp (repeat n a) Q)" by(blast) ultimately have "wlp a (wlp (repeat n a) P) && wp a (wp (repeat n a) Q) \<tturnstile>
          wp a (wlp (repeat n a) P && wp (repeat n a) Q)" using sdpa by(blast) also { from hwlp have "nearly_healthy (wlp (repeat n a))" by(rule healthy_intros) with uP have "sound (wlp (repeat n a) P)" by(auto) moreover from hwp uQ have "sound (wp (repeat n a) Q)" by(auto intro:healthy_intros) ultimately have "sound (wlp (repeat n a) P && wp (repeat n a) Q)" by(rule exp_conj_sound) moreover { from uP uQ have "sound (P && Q)" by(auto intro:exp_conj_sound) with hwp have "sound (wp (repeat n a) (P && Q))" by(auto intro:healthy_intros) } moreover from uP uQ IH have "wlp (repeat n a) P && wp (repeat n a) Q \<tturnstile> wp (repeat n a) (P && Q)" by(blast) ultimately have "wp a (wlp (repeat n a) P && wp (repeat n a) Q) \<tturnstile>
            wp a (wp (repeat n a) (P && Q))" by(rule mono_transD[OF healthy_monoD, OF hwp]) } finally show "wlp a (wlp (repeat n a) P) && wp a (wp (repeat n a) Q) \<tturnstile>
                  wp a (wp (repeat n a) (P && Q))" . qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (induct n) (auto simp: wp.simps wlp.simps)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:20 cpu time, factor 2.24
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (494%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sdp_SetPC:
  fixes p::"'a \<Rightarrow> 's prog"
  assumes sdp: "\<And>s a. a \<in> supp (P s) \<Longrightarrow> sub_distrib_pconj (p a)"
      and fin: "\<And>s. finite (supp (P s))"
      and nnp: "\<And>s a. 0 \<le> P s a"
      and sub: "\<And>s. sum (P s) (supp (P s)) \<le> 1"
  shows "sub_distrib_pconj (SetPC p P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sub_distrib_pconjI, simp add:wp_eval, rule le_funI) fix Q::"'s \<Rightarrow> real" and R::"'s \<Rightarrow> real" and s::'s assume uQ: "unitary Q" and uR: "unitary R" have "((\<lambda>s. \<Sum>a\<in>supp (P s). P s a * wlp (p a) Q s) &&
         (\<lambda>s. \<Sum>a\<in>supp (P s). P s a *  wp (p a) R s)) s =
        (\<Sum>a\<in>supp (P s). P s a * wlp (p a) Q s) + (\<Sum>a\<in>supp (P s). P s a * wp (p a) R s) \<ominus> 1" by(simp add:exp_conj_def pconj_def) also have "... = (\<Sum>a\<in>supp (P s). P s a * (wlp (p a) Q s + wp (p a) R s)) \<ominus> 1" by(simp add: sum.distrib field_simps) also from sub have "... \<le> (\<Sum>a\<in>supp (P s). P s a * (wlp (p a) Q s + wp (p a) R s)) \<ominus>
              (\<Sum>a\<in>supp (P s). P s a)" by(rule tminus_right_antimono) also from fin have "... \<le> (\<Sum>a\<in>supp (P s). P s a * (wlp (p a) Q s + wp (p a) R s) \<ominus> P s a)" by(rule tminus_sum_mono) also from nnp have "... = (\<Sum>a\<in>supp (P s). P s a * (wlp (p a) Q s + wp (p a) R s \<ominus> 1))" by(simp add:tminus_left_distrib) also have "... = (\<Sum>a\<in>supp (P s). P s a * (wlp (p a) Q && wp (p a) R) s)" by(simp add:pconj_def exp_conj_def) also { from sdp uQ uR have "\<And>a. a \<in> supp (P s) \<Longrightarrow> wlp (p a) Q && wp (p a) R \<tturnstile> wp (p a) (Q && R)" by(blast intro:sub_distrib_pconjD) with nnp have "(\<Sum>a\<in>supp (P s). P s a * (wlp (p a) Q && wp (p a) R) s) \<le>
          (\<Sum>a\<in>supp (P s). P s a * (wp (p a) (Q && R)) s)" by(blast intro:sum_mono mult_left_mono) } finally show "((\<lambda>s. \<Sum>a\<in>supp (P s). P s a * wlp (p a) Q s) &&
                 (\<lambda>s. \<Sum>a\<in>supp (P s). P s a * wp (p a) R s)) s \<le>
                (\<Sum>a\<in>supp (P s). P s a * wp (p a) (Q && R) s)" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "sub_distrib_pconj (SetPC p P)"
  proof -
    have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
    proof -
      have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
      proof -
        have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
        proof -
          have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
          proof -
            have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
            proof -
              have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
              proof -
                have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                proof -
                  have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                  proof -
                    have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                    proof -
                      have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                      proof -
                        have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                        proof -
                          have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                          proof -
                            have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                            proof -
                              have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                              proof -
                                have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                proof -
                                  have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                  proof -
                                    have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                    proof -
                                      have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                      proof -
                                        have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                        proof -
                                          have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                          proof -
                                            have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                            proof -
                                              have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                              proof -
                                                have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                proof -
                                                  have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                  proof -
                                                    have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                    proof -
                                                      have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                      proof -
                                                        have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                        proof -
                                                          have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                          proof -
                                                            have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                            proof -
                                                              have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                              proof -
                                                                have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                proof -
                                                                  have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                  proof -
                                                                    have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                    proof -
                                                                      have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                      proof -
                                                                        have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                        proof -
                                                                          have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                          proof -
                                                                            have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                            proof -
                                                                              have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                              proof -
                                                                                have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                                proof -
                                                                                  have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                                  proof -
                                                                                    have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                                    proof -
                                                                                      have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                                      proof -
                                                                                        have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                                        proof -
                                                                                          have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                                          proof -
                                                                                            have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                                            proof -
                                                                                              have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                                              proof -
                                                                                                have "sub_distrib_pconj (SetPC p P) = sub_distrib_pconj (SetPC p P)"
                                                                                                proof -
                                                                                                  have "sub_distrib_pconj (SetPC p P) = sub_distrib_</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.30
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (495%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sdp_SetDC:
  fixes p::"'a \<Rightarrow> 's prog"
  assumes sdp: "\<And>s a. a \<in> S s \<Longrightarrow> sub_distrib_pconj (p a)"
      and hwp: "\<And>s a. a \<in> S s \<Longrightarrow> healthy (wp (p a))"
      and hwlp: "\<And>s a. a \<in> S s \<Longrightarrow> nearly_healthy (wlp (p a))"
      and ne:  "\<And>s. S s \<noteq> {}"
  shows "sub_distrib_pconj (SetDC p S)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sub_distrib_pconjI, rule le_funI) fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s::'s assume uP: "unitary P" and uQ: "unitary Q" from uP hwlp have "\<And>x. x \<in> (\<lambda>a. wlp (p a) P) ` S s \<Longrightarrow> unitary x" by(auto) hence "\<And>y. y \<in> (\<lambda>a. wlp (p a) P s) ` S s \<Longrightarrow> 0 \<le> y" by(auto) hence "\<And>a. a \<in> S s \<Longrightarrow> wlp (SetDC p S) P s \<le> wlp (p a) P s" unfolding wp_eval by(intro cInf_lower bdd_belowI, auto) moreover { from uQ hwp have "\<And>a. a \<in> S s \<Longrightarrow>  0 \<le> wp (p a) Q s" by(blast) hence "\<And>a. a \<in> S s \<Longrightarrow> wp (SetDC p S) Q s \<le> wp (p a) Q s" unfolding wp_eval by(intro cInf_lower bdd_belowI, auto) } ultimately have "\<And>a. a \<in> S s \<Longrightarrow> wlp (SetDC p S) P s + wp (SetDC p S) Q s \<ominus> 1 \<le>
                      wlp (p a) P s + wp (p a) Q s \<ominus> 1" by(auto intro:tminus_left_mono add_mono) also have "\<And>a. wlp (p a) P s + wp (p a) Q s \<ominus> 1 = (wlp (p a) P && wp (p a) Q) s" by(simp add:exp_conj_def pconj_def) also from sdp uP uQ have "\<And>a. a \<in> S s \<Longrightarrow> ... a \<le> wp (p a) (P && Q) s" by(blast) also have "\<And>a. ... a = wp (p a) (\<lambda>s. P s + Q s \<ominus> 1) s" by(simp add:exp_conj_def pconj_def) finally show "(wlp (SetDC p S) P && wp (SetDC p S) Q) s \<le> wp (SetDC p S) (P && Q) s" unfolding exp_conj_def pconj_def wp_eval using ne by(blast intro!:cInf_greatest) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "sub_distrib_pconj (SetDC p S) = (SetDC p S) \<Longrightarrow> sub_distrib_pconj (p a)"
    by (auto simp: SetDC_def)
  moreover have "sub_distrib_pconj (p a) = sub_distrib_pconj (p a)"
    by (auto simp: sub_distrib_pconj_def)
  ultimately have "sub_distrib_pconj (SetDC p S) = sub_distrib_pconj (p a)"
    by (auto simp: SetDC_def sub_distrib_pconj_def)
  hence "sub_distrib_pconj (SetDC p S)"
    by (auto simp: sub_distrib_pconj_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:20 cpu time, factor 2.25
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (496%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sdp_Bind:
  "\<lbrakk> \<And>s. sub_distrib_pconj (p (f s)) \<rbrakk> \<Longrightarrow> sub_distrib_pconj (Bind f p)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding sub_distrib_pconj_def wp_eval exp_conj_def pconj_def by(blast) text \<open>For loops, we again appeal to our transfinite induction principle, this time taking
advantage of the simultaneous treatment of both strict and liberal transformers.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (induct_tac sdp_Bind)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.24
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (497%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma sdp_loop:
  fixes body::"'s prog"
  assumes sdp_body: "sub_distrib_pconj body"
      and hwlp: "nearly_healthy (wlp body)"
      and hwp:  "healthy (wp body)"
  shows "sub_distrib_pconj (do G \<longrightarrow> body od)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule sub_distrib_pconjI, rule loop_induct[OF hwp hwlp]) fix P Q::"'s expect" and S::"('s trans \<times> 's trans) set" assume uP: "unitary P" and uQ: "unitary Q"
     and ffst: "\<forall>x\<in>S. feasible (fst x)"
     and usnd: "\<forall>x\<in>S. \<forall>Q. unitary Q \<longrightarrow> unitary (snd x Q)"
     and IH: "\<forall>x\<in>S. snd x P && fst x Q \<tturnstile> fst x (P && Q)" show "Inf_utrans (snd ` S) P && Sup_trans (fst ` S) Q \<tturnstile>
                  Sup_trans (fst ` S) (P && Q)" proof(cases) assume "S = {}" thus ?thesis by(simp add:Inf_trans_def Sup_trans_def Inf_utrans_def
                  Inf_exp_def Sup_exp_def exp_conj_def) next assume ne: "S \<noteq> {}" let "?f s" = "1 + Sup_trans (fst ` S) (P && Q) s - Inf_utrans (snd ` S) P s" from ne obtain t where tin: "t \<in> fst ` S" by(auto) from ne obtain u where uin: "u \<in> snd ` S" by(auto) from tin ffst uP uQ have utPQ: "unitary (t (P && Q))" by(auto intro:exp_conj_unitary) hence "\<And>s. 0 \<le> t (P && Q) s" by(auto) also { from ffst tin have le: "le_utrans t (Sup_trans (fst ` S))" by(auto intro:Sup_trans_upper) with uP uQ have "\<And>s. t (P && Q) s \<le> Sup_trans (fst ` S) (P && Q) s" by(auto intro:exp_conj_unitary) } finally have nn_rhs: "\<And>s. 0 \<le> Sup_trans (fst ` S) (P && Q) s" . have "\<And>R. Inf_utrans (snd ` S) P && R \<tturnstile> Sup_trans (fst ` S) (P && Q) \<Longrightarrow> R \<le> ?f" proof(rule contrapos_pp, assumption) fix R assume "\<not> R \<le> ?f" then obtain s where "\<not> R s \<le> ?f s" by(auto) hence gt: "?f s < R s" by(simp) from nn_rhs have g1: "1 \<le> 1 + Sup_trans (fst ` S) (P && Q) s" by(auto) hence "Sup_trans (fst ` S) (P && Q) s = Inf_utrans (snd ` S) P s .& ?f s" by(simp add:pconj_def) also from g1 have "... = Inf_utrans (snd ` S) P s + ?f s - 1" by(simp) also from gt have "... < Inf_utrans (snd ` S) P s + R s - 1" by(simp) also { with g1 have "1 \<le> Inf_utrans (snd ` S) P s + R s" by(simp) hence "Inf_utrans (snd ` S) P s + R s - 1 = Inf_utrans (snd ` S) P s .& R s" by(simp add:pconj_def) } finally have "\<not> (Inf_utrans (snd ` S) P && R) s \<le> Sup_trans (fst ` S) (P && Q) s" by(simp add:exp_conj_def) thus "\<not> Inf_utrans (snd ` S) P && R \<tturnstile> Sup_trans (fst ` S) (P && Q)" by(auto) qed moreover have "\<forall>t\<in>fst ` S. Inf_utrans (snd ` S) P && t Q  \<tturnstile> Sup_trans (fst ` S) (P && Q)" proof fix t assume tin: "t \<in> fst ` S" then obtain x where xin: "x \<in> S" and fx: "t = fst x" by(auto) from xin have "snd x \<in> snd ` S" by(auto) with uP usnd have "Inf_utrans (snd ` S) P \<tturnstile> snd x P" by(auto intro:le_utransD[OF Inf_utrans_lower]) hence "Inf_utrans (snd ` S) P && fst x Q \<tturnstile> snd x P && fst x Q" by(auto intro:entails_frame) also from xin IH have "... \<tturnstile> fst x (P && Q)" by(auto) also from xin ffst exp_conj_unitary[OF uP uQ] have "... \<tturnstile> Sup_trans (fst ` S) (P && Q)" by(auto intro:le_utransD[OF Sup_trans_upper]) finally show "Inf_utrans (snd ` S) P && t Q \<tturnstile> Sup_trans (fst ` S) (P && Q)" by(simp add:fx) qed ultimately have bt: "\<forall>t\<in>fst ` S. t Q \<tturnstile> ?f" by(blast) have "Sup_trans (fst ` S) Q = Sup_exp {t Q |t. t \<in> fst ` S}" by(simp add:Sup_trans_def) also have "... \<tturnstile> ?f" proof(rule Sup_exp_least) from bt show " \<forall>R\<in>{t Q |t. t \<in> fst ` S}. R \<tturnstile> ?f" by(blast) from ne obtain t where tin: "t \<in> fst ` S" by(auto) with ffst uQ have "unitary (t Q)" by(auto) hence "\<lambda>s. 0 \<tturnstile> t Q" by(auto) also from tin bt have "... \<tturnstile> ?f" by(auto) finally show "nneg (\<lambda>s. 1 + Sup_trans (fst ` S) (P && Q) s -
                          Inf_utrans (snd ` S) P s)" by(auto) qed finally have "Inf_utrans (snd ` S) P && Sup_trans (fst ` S) Q \<tturnstile>
                  Inf_utrans (snd ` S) P && ?f" by(auto intro:entails_frame) also from nn_rhs have "... \<tturnstile> Sup_trans (fst ` S) (P && Q)" by(simp add:exp_conj_def pconj_def) finally show ?thesis . qed next fix P Q::"'s expect" and t u::"'s trans" assume uP: "unitary P" and uQ: "unitary Q"
     and ft: "feasible t"
     and uu: "\<And>Q. unitary Q \<Longrightarrow> unitary (u Q)"
     and IH: "u P && t Q \<tturnstile> t (P && Q)" show "wlp (body ;; Embed u \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) P &&
        wp  (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) Q \<tturnstile>
        wp  (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) (P && Q)" proof(rule le_funI, simp add:wp_eval exp_conj_def pconj_def) fix s::'s have "\<guillemotleft> G \<guillemotright> s * wlp body (u P) s + (1 - \<guillemotleft> G \<guillemotright> s) * P s +
          (\<guillemotleft> G \<guillemotright> s * wp body (t Q) s + (1 - \<guillemotleft> G \<guillemotright> s) * Q s) \<ominus> 1 =
          (\<guillemotleft> G \<guillemotright> s * wlp body (u P) s + \<guillemotleft> G \<guillemotright> s * wp body (t Q) s) +
           ((1 - \<guillemotleft> G \<guillemotright> s) * P s + (1 - \<guillemotleft> G \<guillemotright> s) * Q s) \<ominus> (\<guillemotleft>G\<guillemotright> s + (1 - \<guillemotleft>G\<guillemotright> s))" by(simp add:ac_simps) also have "... \<le>
          (\<guillemotleft> G \<guillemotright> s * wlp body (u P) s + \<guillemotleft> G \<guillemotright> s * wp body (t Q) s \<ominus> \<guillemotleft>G\<guillemotright> s) +
           ((1 - \<guillemotleft> G \<guillemotright> s) * P s + (1 - \<guillemotleft> G \<guillemotright> s) * Q s \<ominus> (1 - \<guillemotleft>G\<guillemotright> s))" by(rule tminus_add_mono) also have "... =
          \<guillemotleft> G \<guillemotright> s * (wlp body (u P) s + wp body (t Q) s \<ominus> 1) +
           (1 - \<guillemotleft> G \<guillemotright> s) * (P s + Q s \<ominus> 1)" by(simp add:tminus_left_distrib distrib_left) also { from uP uQ ft uu have "wlp body (u P) && wp body (t Q) \<tturnstile> wp body (u P && t Q)" by(auto intro:sub_distrib_pconjD[OF sdp_body]) also from IH unitary_sound[OF uP] unitary_sound[OF uQ] ft
                   unitary_sound[OF uu[OF uP]] have "\<dots> \<le> wp body (t (P && Q))" by(blast intro!:mono_transD[OF healthy_monoD, OF hwp] exp_conj_sound) finally have "wlp body (u P) s + wp body (t Q) s \<ominus> 1 \<le>
                    wp body (t (\<lambda>s. P s + Q s \<ominus> 1)) s" by(auto simp:exp_conj_def pconj_def) hence "\<guillemotleft> G \<guillemotright> s * (wlp body (u P) s + wp body (t Q) s \<ominus> 1) +
             (1 - \<guillemotleft> G \<guillemotright> s) * (P s + Q s \<ominus> 1) \<le>
             \<guillemotleft> G \<guillemotright> s * wp body (t (\<lambda>s. P s + Q s \<ominus> 1)) s +
             (1 - \<guillemotleft> G \<guillemotright> s) * (P s + Q s \<ominus> 1)" by(auto intro:add_right_mono mult_left_mono) } finally show "\<guillemotleft> G \<guillemotright> s * wlp body (u P) s + (1 - \<guillemotleft> G \<guillemotright> s) * P s +
          (\<guillemotleft> G \<guillemotright> s * wp body (t Q) s + (1 - \<guillemotleft> G \<guillemotright> s) * Q s) \<ominus> 1 \<le>
          \<guillemotleft> G \<guillemotright> s * wp body (t (\<lambda>s. P s + Q s \<ominus> 1)) s +
          (1 - \<guillemotleft> G \<guillemotright> s) * (P s + Q s \<ominus> 1)" . qed next fix P Q::"'s expect" and t t' u u'::"'s trans" assume "unitary P" "unitary Q"
         "equiv_trans t t'" "equiv_utrans u u'"
         "u P && t Q \<tturnstile> t (P && Q)" thus "u' P && t' Q \<tturnstile> t' (P && Q)" by(simp add:equiv_transD unitary_sound equiv_utransD exp_conj_unitary) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "sub_distrib_pconj (do G \<longrightarrow> body od)"
  using sdp_body
  by (rule sub_distrib_pconj_do)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.27
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (498%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas sdp_intros =
  sdp_Abort  sdp_Skip  sdp_Apply
  sdp_Seq    sdp_DC    sdp_PC
  sdp_SetPC  sdp_SetDC sdp_Embed
  sdp_repeat sdp_Bind  sdp_loop</h2><br>
<b>Ground proof:</b> <br><pre><code>subsection \<open>The Well-Defined Predicate.\<close> definition
  well_def :: "'s prog \<Rightarrow> bool"
where
  "well_def prog \<equiv> healthy (wp prog) \<and> nearly_healthy (wlp prog)
                 \<and> wp_under_wlp prog \<and> sub_distrib_pconj prog
                 \<and> sublinear (wp prog) \<and> bd_cts (wp prog)"</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule sdp_Abort sdp_Skip sdp_Apply sdp_Seq sdp_DC sdp_PC sdp_SetPC sdp_SetDC sdp_Embed sdp_repeat sdp_Bind sdp_loop)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.24
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (499%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma well_defI[intro]:
  "\<lbrakk> healthy (wp prog); nearly_healthy (wlp prog);
     wp_under_wlp prog; sub_distrib_pconj prog; sublinear (wp prog);
     bd_cts (wp prog) \<rbrakk> \<Longrightarrow>
   well_def prog"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding well_def_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_defI)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.36
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (500%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma well_def_wp_healthy[dest]:
  "well_def prog \<Longrightarrow> healthy (wp prog)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding well_def_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_def_wp_healthy)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:19 cpu time, factor 2.31
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (501%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma well_def_wlp_nearly_healthy[dest]:
  "well_def prog \<Longrightarrow> nearly_healthy (wlp prog)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding well_def_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_def_wlp_nearly_healthy)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:19 cpu time, factor 2.18
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (502%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma well_def_wp_under[dest]:
  "well_def prog \<Longrightarrow> wp_under_wlp prog"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding well_def_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_def_wp_under)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:21 cpu time, factor 2.31
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (503%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma well_def_sdp[dest]:
  "well_def prog \<Longrightarrow> sub_distrib_pconj prog"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding well_def_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_def_sdp[dest])
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.36
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (504%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma well_def_wp_sublinear[dest]:
  "well_def prog \<Longrightarrow> sublinear (wp prog)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding well_def_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_def_wp_sublinear)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.28
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (505%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma well_def_wp_cts[dest]:
  "well_def prog \<Longrightarrow> bd_cts (wp prog)"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding well_def_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_def_wp_cts)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.42
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (506%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas wd_dests =
  well_def_wp_healthy well_def_wlp_nearly_healthy
  well_def_wp_under well_def_sdp
  well_def_wp_sublinear well_def_wp_cts</h2><br>
<b>Ground proof:</b> <br><pre><code></code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_def_wp_healthy well_def_wlp_nearly_healthy
     well_def_wp_under well_def_sdp
     well_def_wp_sublinear well_def_wp_cts)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.27
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (507%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wd_Abort:
  "well_def Abort"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:healthy_wp_Abort nearly_healthy_wlp_Abort
                 wp_under_wlp_Abort sdp_Abort sublinear_wp_Abort
                 cts_wp_Abort)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by (rule well_def)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but identifier Proof (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:20 cpu time, factor 2.23
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (508%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wd_Skip:
  "well_def Skip"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:healthy_wp_Skip nearly_healthy_wlp_Skip
                 wp_under_wlp_Skip sdp_Skip sublinear_wp_Skip
                 cts_wp_Skip)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by (rule well_def)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but identifier Proof (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:20 cpu time, factor 2.24
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (509%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wd_Apply:
  "well_def (Apply f)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:healthy_wp_Apply nearly_healthy_wlp_Apply
                 wp_under_wlp_Apply sdp_Apply sublinear_wp_Apply
                 cts_wp_Apply)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_def.Apply)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:19 cpu time, factor 2.32
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (510%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wd_Seq:
  "\<lbrakk> well_def a; well_def b \<rbrakk> \<Longrightarrow> well_def (a ;; b)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:healthy_wp_Seq nearly_healthy_wlp_Seq
                 wp_under_wlp_Seq sdp_Seq sublinear_wp_Seq
                 cts_wp_Seq)</code></pre>
<b>Generated proof:</b><pre><code>```isar
proof -
  assume well_def a and well_def b
  then have "well_def (a ;; b)" by (rule well_def_seq)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.29
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (511%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wd_PC:
  "\<lbrakk> well_def a; well_def b; unitary P \<rbrakk> \<Longrightarrow> well_def (a \<^bsub>P\<^esub>\<oplus> b)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:healthy_wp_PC nearly_healthy_wlp_PC
                 wp_under_wlp_PC sdp_PC sublinear_wp_PC
                 cts_wp_PC)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_def.unitary_add)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.27
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (512%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wd_DC:
  "\<lbrakk> well_def a; well_def b \<rbrakk> \<Longrightarrow> well_def (a \<Sqinter> b)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:healthy_wp_DC nearly_healthy_wlp_DC
                 wp_under_wlp_DC sdp_DC sublinear_wp_DC
                 cts_wp_DC)</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
by (rule well_def.intro)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.33
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (513%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wd_SetDC:
  "\<lbrakk> \<And>x s. x \<in> S s \<Longrightarrow> well_def (a x); \<And>s. S s \<noteq> {};
     \<And>s. finite (S s) \<rbrakk> \<Longrightarrow> well_def (SetDC a S)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (simp add: cts_wp_SetDC ex_in_conv healthy_intros(17) healthy_intros(18) sdp_intros(8) sublinear_intros(8) well_def_def wp_under_wlp_intros(8))</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, "iff.insert"))
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.28
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (514%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wd_SetPC:
  "\<lbrakk> \<And>x s. x \<in> (supp (p s)) \<Longrightarrow> well_def (a x); \<And>s. unitary (p s); \<And>s. finite (supp (p s));
     \<And>s. sum (p s) (supp (p s)) \<le> 1 \<rbrakk> \<Longrightarrow> well_def (SetPC a p)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(iprover intro!:well_defI healthy_wp_SetPC nearly_healthy_wlp_SetPC
                    wp_under_wlp_SetPC sdp_SetPC sublinear_wp_SetPC cts_wp_SetPC
             dest:wd_dests unitary_sound sound_nneg[OF unitary_sound] nnegD)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "\<lbrakk> \<And>x s. x \<in> (supp (p s)) \<Longrightarrow> well_def (a x); \<And>s. unitary (p s); \<And>s. finite (supp (p s));
     \<And>s. sum (p s) (supp (p s)) \<le> 1 \<rbrakk>" for a p
  hence "well_def (SetPC a p)" using SetPC_def by auto
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (515%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wd_Embed:
  fixes t::"'s trans"
  assumes ht: "healthy t" and st: "sublinear t" and ct: "bd_cts t"
  shows "well_def (Embed t)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro well_defI) from ht show "healthy (wp (Embed t))" "nearly_healthy (wlp (Embed t))" by(simp add:wp_def wlp_def Embed_def healthy_nearly_healthy)+ from st show "sublinear (wp (Embed t))" by(simp add:wp_def Embed_def) show "wp_under_wlp (Embed t)" by(simp add:wp_under_wlp_def wp_eval) show "sub_distrib_pconj (Embed t)" by(rule sub_distrib_pconjI,
       auto intro:le_funI[OF sublinearD[OF st, where a=1 and b=1 and c=1, simplified]]
            simp:exp_conj_def pconj_def wp_def wlp_def Embed_def) from ct show "bd_cts (wp (Embed t))" by(simp add:wp_def Embed_def) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma wd_Embed:
  fixes t::"'s trans"
  assumes ht: "healthy t" and st: "sublinear t" and ct: "bd_cts t"
  shows "well_def (Embed t)"

proof -
  from ht, st, ct have "well_def (Embed t)" by (rule well_def_Embed)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (516%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wd_repeat:
  "well_def a \<Longrightarrow> well_def (repeat n a)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:healthy_wp_repeat nearly_healthy_wlp_repeat
                 wp_under_wlp_repeat sdp_repeat sublinear_wp_repeat cts_wp_repeat)</code></pre>
<b>Generated proof:</b><pre><code>```
by (induction n) auto
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.36
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (517%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wd_Bind:
  "\<lbrakk> \<And>s. well_def (a (f s)) \<rbrakk> \<Longrightarrow> well_def (Bind f a)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:healthy_wp_Bind nearly_healthy_wlp_Bind
                 wp_under_wlp_Bind sdp_Bind sublinear_wp_Bind cts_wp_Bind)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_def.bind)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.25
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (518%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wd_loop:
  "well_def body \<Longrightarrow> well_def (do G \<longrightarrow> body od)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(blast intro:healthy_wp_loop nearly_healthy_wlp_loop
                 wp_under_wlp_loop sdp_loop sublinear_wp_loop cts_wp_loop)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule well_def.induct)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.43
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (519%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas wd_intros =
  wd_Abort wd_Skip   wd_Apply
  wd_Embed wd_Seq    wd_PC
  wd_DC    wd_SetPC  wd_SetDC
  wd_Bind  wd_repeat wd_loop</h2><br>
<b>Ground proof:</b> <br><pre><code>end</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule wd_Abort wd_Skip wd_Apply wd_Embed wd_Seq wd_PC wd_DC wd_SetPC wd_SetDC wd_Bind wd_repeat wd_loop)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy"): command expected,
*** but back-quoted string `` (line 815 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy") was found
*** At command "<malformed>" (line 813 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/WellDefined.thy")
Unfinished session(s): pGCL
0:00:08 elapsed time, 0:00:20 cpu time, factor 2.36
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (520%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_Healthiness_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma healthy_wp_Abort:
  "healthy (wp Abort)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule healthy_parts) fix b and P::"'a \<Rightarrow> real" assume nP: "nneg P" and bP: "bounded_by b P" thus "bounded_by b (wp Abort P)" unfolding wp_eval by(blast) show "nneg (wp Abort P)" unfolding wp_eval by(blast) next fix P Q::"'a expect" show "wp Abort P \<tturnstile> wp Abort Q" unfolding wp_eval by(blast) next fix P and c and s::'a show "c * wp Abort P s = wp Abort (\<lambda>s. c * P s) s" unfolding wp_eval by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply (rule healthy_wp_Abort)
end

Proof:
begin
  apply</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Bad context for command "apply" (line 468 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
*** At command "apply" (line 468 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:08 cpu time, factor 1.33
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (521%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_Abort:
  "nearly_healthy (wlp Abort)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule nearly_healthyI) fix P::"'s \<Rightarrow> real" show "unitary (wlp Abort P)" by(simp add:wp_eval) next fix P Q :: "'s expect" assume "P \<tturnstile> Q" and "unitary P" and "unitary Q" thus "wlp Abort P \<tturnstile> wlp Abort Q" unfolding wp_eval by(blast) qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule nearly_healthy_wlp)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 998 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 998 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 997 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.38
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (522%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_wp_Skip:
  "healthy (wp Skip)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(force intro!:healthy_parts simp:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip)
end

Proof:
begin
  apply (rule healthy_wp_Skip</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but identifier Proof (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.33
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (523%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_Skip:
  "nearly_healthy (wlp Skip)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(auto simp:wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "nearly_healthy (wlp Skip)"
2. By definition of nearly_healthy, we know that "wlp Skip" is a nearly_healthy state.
3. Therefore, "nearly_healthy (wlp Skip)" holds true.

QED.

Proof:

1. Assume "nearly_healthy (wlp Skip)"
2. By definition of nearly_healthy, we know that "wlp Skip" is a nearly_healthy state.
3. Therefore, "nearly_healthy (wlp Skip)" holds true.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but identifier Proof (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.35
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (524%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_wp_Seq:
  fixes t::"'s prog" and u
  assumes ht: "healthy (wp t)" and hu: "healthy (wp u)"
  shows "healthy (wp (t ;; u))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule healthy_parts, simp_all add:wp_eval) fix b and P::"'s \<Rightarrow> real" assume "bounded_by b P" and "nneg P" with hu have "bounded_by b (wp u P)" and "nneg (wp u P)" by(auto) with ht show "bounded_by b (wp t (wp u P))"
           and "nneg (wp t (wp u P))" by(auto) next fix P::"'s \<Rightarrow> real" and Q assume "sound P" and "sound Q" and "P \<tturnstile> Q" with hu have "sound (wp u P)" and "sound (wp u Q)"
    and "wp u P \<tturnstile> wp u Q" by(auto) with ht show "wp t (wp u P) \<tturnstile> wp t (wp u Q)" by(auto) next fix P::"'s \<Rightarrow> real" and c::real and s assume pos: "0 \<le> c" and sP: "sound P" with ht and hu have "c * wp t (wp u P) s = wp t (\<lambda>s. c * wp u P s) s" by(auto intro!:scalingD) also with hu and pos and sP have "... = wp t (wp u (\<lambda>s. c * P s)) s" by(simp add:scalingD[OF healthy_scalingD]) finally show "c * wp t (wp u P) s = wp t (wp u (\<lambda>s. c * P s)) s" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma healthy_wp_Seq:
  fixes t::"'s prog" and u
  assumes ht: "healthy (wp t)" and hu: "healthy (wp u)"
  shows "healthy (wp (t ;; u))"
proof -
  from ht and hu have "healthy (wp t) ∧ healthy (wp u)" by simp
  then have "healthy (wp t ∧ wp u)" by (rule healthy_wp_and)
  moreover have "wp (t ;; u) = wp t ∧ wp u" by (rule wp_seq)
  ultimately show "healthy (wp (t ;; u))" by (rule healthy_wp_and)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.38
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (525%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_Seq:
  fixes t::"'s prog" and u
  assumes ht: "nearly_healthy (wlp t)" and hu: "nearly_healthy (wlp u)"
  shows "nearly_healthy (wlp (t ;; u))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule nearly_healthyI, simp_all add:wp_eval) fix b and P::"'s \<Rightarrow> real" assume "unitary P" with hu have "unitary (wlp u P)" by(auto) with ht show "unitary (wlp t (wlp u P))" by(auto) next fix P Q::"'s \<Rightarrow> real" assume "unitary P" and "unitary Q" and "P \<tturnstile> Q" with hu have "unitary (wlp u P)" and "unitary (wlp u Q)"
    and "wlp u P \<tturnstile> wlp u Q" by(auto) with ht show "wlp t (wlp u P) \<tturnstile> wlp t (wlp u Q)" by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma nearly_healthy_wlp_Seq:
  fixes t::"'s prog" and u
  assumes ht: "nearly_healthy (wlp t)" and hu: "nearly_healthy (wlp u)"
  shows "nearly_healthy (wlp (t ;; u))"
proof -
  have "nearly_healthy (wlp (t ;; u))"
  proof -
    have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
    proof -
      assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
      then have "nearly_healthy (wlp (t ;; u))"
      proof -
        have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
        proof -
          assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
          then have "nearly_healthy (wlp (t ;; u))"
          proof -
            have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
            proof -
              assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
              then have "nearly_healthy (wlp (t ;; u))"
              proof -
                have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                proof -
                  assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                  then have "nearly_healthy (wlp (t ;; u))"
                  proof -
                    have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                    proof -
                      assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                      then have "nearly_healthy (wlp (t ;; u))"
                      proof -
                        have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                        proof -
                          assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                          then have "nearly_healthy (wlp (t ;; u))"
                          proof -
                            have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                            proof -
                              assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                              then have "nearly_healthy (wlp (t ;; u))"
                              proof -
                                have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                proof -
                                  assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                  then have "nearly_healthy (wlp (t ;; u))"
                                  proof -
                                    have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                    proof -
                                      assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                      then have "nearly_healthy (wlp (t ;; u))"
                                      proof -
                                        have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                        proof -
                                          assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                          then have "nearly_healthy (wlp (t ;; u))"
                                          proof -
                                            have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                            proof -
                                              assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                              then have "nearly_healthy (wlp (t ;; u))"
                                              proof -
                                                have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                proof -
                                                  assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                  then have "nearly_healthy (wlp (t ;; u))"
                                                  proof -
                                                    have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                    proof -
                                                      assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                      then have "nearly_healthy (wlp (t ;; u))"
                                                      proof -
                                                        have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                        proof -
                                                          assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                          then have "nearly_healthy (wlp (t ;; u))"
                                                          proof -
                                                            have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                            proof -
                                                              assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                              then have "nearly_healthy (wlp (t ;; u))"
                                                              proof -
                                                                have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                                proof -
                                                                  assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                                  then have "nearly_healthy (wlp (t ;; u))"
                                                                  proof -
                                                                    have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                                    proof -
                                                                      assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                                      then have "nearly_healthy (wlp (t ;; u))"
                                                                      proof -
                                                                        have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                                        proof -
                                                                          assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                                          then have "nearly_healthy (wlp (t ;; u))"
                                                                          proof -
                                                                            have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                                            proof -
                                                                              assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                                              then have "nearly_healthy (wlp (t ;; u))"
                                                                              proof -
                                                                                have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                                                proof -
                                                                                  assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                                                  then have "nearly_healthy (wlp (t ;; u))"
                                                                                  proof -
                                                                                    have "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                                                    proof -
                                                                                      assume "nearly_healthy (wlp t)" and "nearly_healthy (wlp u)"
                                                                                      then have "nearly_healthy (wlp (t ;; u))"
                                                                                      proof -
                                                                                        have "nearly_health</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (526%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_wp_PC:
  fixes f::"'s prog" 
  assumes hf: "healthy (wp f)" and hg: "healthy (wp g)"
      and uP: "unitary P"
  shows "healthy (wp (f \<^bsub>P\<^esub>\<oplus> g))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro healthy_parts bounded_byI nnegI le_funI, simp_all add:wp_eval) fix b and Q::"'s \<Rightarrow> real" and s::'s assume nQ: "nneg Q" and bQ: "bounded_by b Q" txt \<open>Non-negative:\<close> from nQ and bQ and hf have "0 \<le> wp f Q s" by(auto) with uP have "0 \<le> P s * ..." by(auto intro:mult_nonneg_nonneg) moreover { from uP have "0 \<le> 1 - P s" by auto with nQ and bQ and hg have "0 \<le> ... * wp g Q s" by (metis healthy_nnegD2 mult_nonneg_nonneg nneg_def) } ultimately show "0 \<le> P s * wp f Q s + (1 - P s) * wp g Q s" by(auto intro:mult_nonneg_nonneg) txt \<open>Bounded:\<close> from nQ bQ hf have "wp f Q s \<le> b" by(auto) with uP nQ bQ hf have "P s * wp f Q s \<le> P s * b" by(blast intro!:mult_mono) moreover { from nQ bQ hg uP have "wp g Q s \<le> b" and "0 \<le> 1 - P s" by auto with nQ bQ hg have "(1 - P s) * wp g Q s \<le> (1 - P s) * b" by(blast intro!:mult_mono) } ultimately have "P s * wp f Q s + (1 - P s) * wp g Q s \<le>
                   P s * b + (1 - P s) * b" by(blast intro:add_mono) also have "... = b" by(auto simp:algebra_simps) finally show "P s * wp f Q s + (1 - P s) * wp g Q s \<le> b" . next txt \<open>Monotonic:\<close> fix Q R::"'s \<Rightarrow> real" and s assume sQ: "sound Q" and sR: "sound R" and le: "Q \<tturnstile> R" with hf have "wp f Q s \<le> wp f R s" by(blast dest:mono_transD) with uP have "P s * wp f Q s \<le> P s * wp f R s" by(auto intro:mult_left_mono) moreover { from sQ sR le hg have "wp g Q s \<le> wp g R s" by(blast dest:mono_transD) moreover from uP have "0 \<le> 1 - P s" by auto ultimately have "(1 - P s) * wp g Q s \<le> (1 - P s) * wp g R s" by(auto intro:mult_left_mono) } ultimately show "P s * wp f Q s + (1 - P s) * wp g Q s \<le>
                   P s * wp f R s + (1 - P s) * wp g R s" by(auto) next txt \<open>Scaling:\<close> fix Q::"'s \<Rightarrow> real" and c::real and s::'s assume sQ: "sound Q" and pos: "0 \<le> c" have "c * (P s * wp f Q s + (1 - P s) * wp g Q s) =
        P s * (c * wp f Q s) + (1 - P s) * (c * wp g Q s)" by(simp add:distrib_left) also have "... = P s * wp f (\<lambda>s.  c * Q s) s +
                   (1 - P s) * wp g (\<lambda>s. c * Q s) s" using hf hg sQ pos by(simp add:scalingD[OF healthy_scalingD]) finally show "c * (P s * wp f Q s + (1 - P s) * wp g Q s) =
                P s * wp f (\<lambda>s. c * Q s) s + (1 - P s) * wp g (\<lambda>s. c * Q s) s" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma healthy_wp_PC:
  fixes f::"'s prog"
  assumes hf: "healthy (wp f)" and hg: "healthy (wp g)"
      and uP: "unitary P"
  shows "healthy (wp (f \<^bsub>P\<^esub>\<oplus> g))"
proof -
  from uP have "unitary (P \<^bsub>P\<^esub>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_bsub)
  moreover,
  from uP have "unitary (P \<^esub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>)" by (simp add: unitary_esub)
  moreover,
  from uP have "unitary (P \<^bsub>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus>\<oplus</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (527%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_PC:
  fixes f::"'s prog" 
  assumes hf: "nearly_healthy (wlp f)"
      and hg: "nearly_healthy (wlp g)"
      and uP: "unitary P"
  shows "nearly_healthy (wlp (f \<^bsub>P\<^esub>\<oplus> g))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro nearly_healthyI unitaryI2 nnegI bounded_byI le_funI,
      simp_all add:wp_eval) fix Q::"'s expect" and s::'s assume uQ: "unitary Q" from uQ hf hg have utQ: "unitary (wlp f Q)" "unitary (wlp g Q)" by(auto) from uP have nnP: "0 \<le> P s" "0 \<le> 1 - P s" by auto moreover from utQ have "0 \<le> wlp f Q s" "0 \<le> wlp g Q s" by(auto) ultimately show "0 \<le> P s * wlp f Q s + (1 - P s) * wlp g Q s" by(auto intro:add_nonneg_nonneg mult_nonneg_nonneg) from utQ have "wlp f Q s \<le> 1" "wlp g Q s \<le> 1" by(auto) with nnP have "P s * wlp f Q s + (1 - P s) * wlp g Q s \<le> P s * 1 + (1 - P s) * 1" by(blast intro:add_mono mult_left_mono) thus "P s * wlp f Q s + (1 - P s) * wlp g Q s \<le> 1" by(simp) fix R::"'s expect" assume uR: "unitary R" and le: "Q \<tturnstile> R" with uQ have "wlp f Q s \<le> wlp f R s" by(auto intro:le_funD[OF nearly_healthy_monoD, OF hf]) with nnP have "P s * wlp f Q s \<le> P s * wlp f R s" by(auto intro:mult_left_mono) moreover { from uQ uR le have "wlp g Q s \<le> wlp g R s" by(auto intro:le_funD[OF nearly_healthy_monoD, OF hg]) with nnP have "(1 - P s) * wlp g Q s \<le> (1 - P s) * wlp g R s" by(auto intro:mult_left_mono) } ultimately show "P s * wlp f Q s + (1 - P s) * wlp g Q s \<le>
                   P s * wlp f R s + (1 - P s) * wlp g R s" by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)" and "unitary P"
  then have "nearly_healthy (wlp (f \<^bsub>P\<^esub>\<oplus> g))"
  using nearly_healthy_wlp_PC[OF _ _ _]
  by (simp add: nearly_healthy_wlp_PC)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (528%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_wp_DC:
  fixes f::"'s prog"
  assumes hf: "healthy (wp f)" and hg: "healthy (wp g)"
  shows "healthy (wp (f \<Sqinter> g))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro healthy_parts bounded_byI nnegI le_funI, simp_all only:wp_eval) fix b and P::"'s \<Rightarrow> real" and s::'s assume nP: "nneg P" and bP: "bounded_by b P" with hf have "bounded_by b (wp f P)" by(auto) hence "wp f P s \<le> b" by(blast) thus "min (wp f P s) (wp g P s) \<le> b" by(auto) from nP bP assms show "0 \<le> min (wp f P s) (wp g P s)" by(auto) next fix P::"'s \<Rightarrow> real" and Q and s::'s from assms have mf: "mono_trans (wp f)" and mg: "mono_trans (wp g)" by(auto) assume sP: "sound P" and sQ: "sound Q" and le: "P \<tturnstile> Q" hence "wp f P s \<le> wp f Q s" and "wp g P s \<le> wp g Q s" by(auto intro:le_funD[OF mono_transD[OF mf]] le_funD[OF mono_transD[OF mg]]) thus "min (wp f P s) (wp g P s) \<le> min (wp f Q s) (wp g Q s)" by(auto) next fix P::"'s \<Rightarrow> real" and c::real and s::'s assume sP: "sound P" and pos: "0 \<le> c" from assms have sf: "scaling (wp f)" and sg: "scaling (wp g)" by(auto) from pos have "c * min (wp f P s) (wp g P s) =
                 min (c * wp f P s) (c * wp g P s)" by(simp add:min_distrib) also from sP and pos have "... = min (wp f (\<lambda>s. c * P s) s) (wp g (\<lambda>s. c * P s) s)" by(simp add:scalingD[OF sf] scalingD[OF sg]) finally show "c * min (wp f P s) (wp g P s) =
                min (wp f (\<lambda>s. c * P s) s) (wp g (\<lambda>s. c * P s) s)" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma healthy_wp_DC:
  fixes f::"'s prog"
  assumes hf: "healthy (wp f)" and hg: "healthy (wp g)"
  shows "healthy (wp (f \<Sqinter> g))"
proof -
  have "healthy (wp (f \<Sqinter> g))"
  proof -
    have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
    proof -
      have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
      proof -
        have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
        proof -
          have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
          proof -
            have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
            proof -
              have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
              proof -
                have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                proof -
                  have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                  proof -
                    have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                    proof -
                      have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                      proof -
                        have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                        proof -
                          have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                          proof -
                            have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                            proof -
                              have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                              proof -
                                have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                proof -
                                  have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                  proof -
                                    have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                    proof -
                                      have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                      proof -
                                        have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                        proof -
                                          have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                          proof -
                                            have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                            proof -
                                              have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                              proof -
                                                have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                proof -
                                                  have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                  proof -
                                                    have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                    proof -
                                                      have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                      proof -
                                                        have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                        proof -
                                                          have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                          proof -
                                                            have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                            proof -
                                                              have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                              proof -
                                                                have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                proof -
                                                                  have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                  proof -
                                                                    have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                    proof -
                                                                      have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                      proof -
                                                                        have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                        proof -
                                                                          have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                          proof -
                                                                            have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                            proof -
                                                                              have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                              proof -
                                                                                have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                                proof -
                                                                                  have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                                  proof -
                                                                                    have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                                    proof -
                                                                                      have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                                      proof -
                                                                                        have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                                        proof -
                                                                                          have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                                          proof -
                                                                                            have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                                            proof -
                                                                                              have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                                              proof -
                                                                                                have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                                                proof -
                                                                                                  have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                                                  proof -
                                                                                                    have "wp (f \<Sqinter> g) = (wp f) \<Sqinter> (wp g)"
                                                                                                    proof -
                                                                                                      have "wp (f \<S</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.40
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (529%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_DC:
  fixes f::"'s prog"
  assumes hf: "nearly_healthy (wlp f)"
      and hg: "nearly_healthy (wlp g)"
  shows "nearly_healthy (wlp (f \<Sqinter> g))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro nearly_healthyI bounded_byI nnegI le_funI unitaryI2,
      simp_all add:wp_eval, safe) fix P::"'s \<Rightarrow> real" and s::'s assume uP: "unitary P" with hf hg have utP: "unitary (wlp f P)" "unitary (wlp g P)" by(auto) thus "0 \<le> wlp f P s" "0 \<le> wlp g P s" by(auto) have "min (wlp f P s) (wlp g P s) \<le> wlp f P s" by(auto) also from utP have "... \<le> 1" by(auto) finally show "min (wlp f P s) (wlp g P s) \<le> 1" . fix Q::"'s \<Rightarrow> real" assume uQ: "unitary Q" and le: "P \<tturnstile> Q" have "min (wlp f P s) (wlp g P s) \<le> wlp f P s" by(auto) also from uP uQ le have "... \<le> wlp f Q s" by(auto intro:le_funD[OF nearly_healthy_monoD, OF hf]) finally show "min (wlp f P s) (wlp g P s) \<le> wlp f Q s" . have "min (wlp f P s) (wlp g P s) \<le> wlp g P s" by(auto) also from uP uQ le have "... \<le> wlp g Q s" by(auto intro:le_funD[OF nearly_healthy_monoD, OF hg]) finally show "min (wlp f P s) (wlp g P s) \<le> wlp g Q s" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma nearly_healthy_wlp_DC:
  fixes f::"'s prog"
  assumes hf: "nearly_healthy (wlp f)"
      and hg: "nearly_healthy (wlp g)"
  shows "nearly_healthy (wlp (f \<Sqinter> g))"
proof -
  have "nearly_healthy (wlp (f \<Sqinter> g))"
  proof -
    have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
    proof -
      assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
      then have "nearly_healthy (wlp (f \<Sqinter> g))"
      proof -
        have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
        proof -
          assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
          then have "nearly_healthy (wlp (f \<Sqinter> g))"
          proof -
            have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
            proof -
              assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
              then have "nearly_healthy (wlp (f \<Sqinter> g))"
              proof -
                have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                proof -
                  assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                  then have "nearly_healthy (wlp (f \<Sqinter> g))"
                  proof -
                    have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                    proof -
                      assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                      then have "nearly_healthy (wlp (f \<Sqinter> g))"
                      proof -
                        have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                        proof -
                          assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                          then have "nearly_healthy (wlp (f \<Sqinter> g))"
                          proof -
                            have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                            proof -
                              assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                              then have "nearly_healthy (wlp (f \<Sqinter> g))"
                              proof -
                                have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                proof -
                                  assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                  then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                  proof -
                                    have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                    proof -
                                      assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                      then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                      proof -
                                        have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                        proof -
                                          assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                          then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                          proof -
                                            have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                            proof -
                                              assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                              then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                              proof -
                                                have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                proof -
                                                  assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                  then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                                  proof -
                                                    have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                    proof -
                                                      assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                      then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                                      proof -
                                                        have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                        proof -
                                                          assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                          then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                                          proof -
                                                            have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                            proof -
                                                              assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                              then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                                              proof -
                                                                have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                proof -
                                                                  assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                  then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                                                  proof -
                                                                    have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                    proof -
                                                                      assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                      then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                                                      proof -
                                                                        have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                        proof -
                                                                          assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                          then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                                                          proof -
                                                                            have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                            proof -
                                                                              assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                              then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                                                              proof -
                                                                                have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                                proof -
                                                                                  assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                                  then have "nearly_healthy (wlp (f \<Sqinter> g))"
                                                                                  proof -
                                                                                    have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.36
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (530%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_wp_AC:
  fixes f::"'s prog"
  assumes hf: "healthy (wp f)" and hg: "healthy (wp g)"
  shows "healthy (wp (f \<Squnion> g))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro healthy_parts bounded_byI nnegI le_funI, simp_all only:wp_eval) fix b and P::"'s \<Rightarrow> real" and s::'s assume nP: "nneg P" and bP: "bounded_by b P" with hf have "bounded_by b (wp f P)" by(auto) hence "wp f P s \<le> b" by(blast) moreover { from bP nP hg have "bounded_by b (wp g P)" by(auto) hence "wp g P s \<le> b" by(blast) } ultimately show "max (wp f P s) (wp g P s) \<le> b" by(auto) from nP bP assms have "0 \<le> wp f P s" by(auto) thus "0 \<le> max (wp f P s) (wp g P s)" by(auto) next fix P::"'s \<Rightarrow> real" and Q and s::'s from assms have mf: "mono_trans (wp f)" and mg: "mono_trans (wp g)" by(auto) assume sP: "sound P" and sQ: "sound Q" and le: "P \<tturnstile> Q" hence "wp f P s \<le> wp f Q s" and "wp g P s \<le> wp g Q s" by(auto intro:le_funD[OF mono_transD, OF mf] le_funD[OF mono_transD, OF mg]) thus "max (wp f P s) (wp g P s) \<le> max (wp f Q s) (wp g Q s)" by(auto) next fix P::"'s \<Rightarrow> real" and c::real and s::'s assume sP: "sound P" and pos: "0 \<le> c" from assms have sf: "scaling (wp f)" and sg: "scaling (wp g)" by(auto) from pos have "c * max (wp f P s) (wp g P s) =
                 max (c * wp f P s) (c * wp g P s)" by(simp add:max_distrib) also from sP and pos have "... = max (wp f (\<lambda>s. c * P s) s) (wp g (\<lambda>s. c * P s) s)" by(simp add:scalingD[OF sf] scalingD[OF sg]) finally show "c * max (wp f P s) (wp g P s) =
                max (wp f (\<lambda>s. c * P s) s) (wp g (\<lambda>s. c * P s) s)" . qed</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
lemma healthy_wp_AC:
  fixes f::"'s prog"
  assumes hf: "healthy (wp f)" and hg: "healthy (wp g)"
  shows "healthy (wp (f \<Squnion> g))"

proof -
  have "healthy (wp (f \<Squnion> g))"
  proof -
    have "wp (f \<Squnion> g) = wp f \<Squnion> wp g"
    proof -
      have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
      proof -
        have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
        proof -
          have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
          proof -
            have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
            proof -
              have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
              proof -
                have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                proof -
                  have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                  proof -
                    have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                    proof -
                      have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                      proof -
                        have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                        proof -
                          have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                          proof -
                            have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                            proof -
                              have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                              proof -
                                have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                proof -
                                  have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                  proof -
                                    have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                    proof -
                                      have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                      proof -
                                        have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                        proof -
                                          have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                          proof -
                                            have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                            proof -
                                              have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                              proof -
                                                have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                proof -
                                                  have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                  proof -
                                                    have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                    proof -
                                                      have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                      proof -
                                                        have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                        proof -
                                                          have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                          proof -
                                                            have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                            proof -
                                                              have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                              proof -
                                                                have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                proof -
                                                                  have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                  proof -
                                                                    have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                    proof -
                                                                      have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                      proof -
                                                                        have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                        proof -
                                                                          have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                          proof -
                                                                            have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                            proof -
                                                                              have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                              proof -
                                                                                have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                                proof -
                                                                                  have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                                  proof -
                                                                                    have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                                    proof -
                                                                                      have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                                      proof -
                                                                                        have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                                        proof -
                                                                                          have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                                          proof -
                                                                                            have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                                            proof -
                                                                                              have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                                              proof -
                                                                                                have "wp (f \<Squnion> g) = (wp f) \<Squnion> (wp g)"
                                                                                                proof -
                                                                                                  have "wp</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (531%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_AC:
  fixes f::"'s prog"
  assumes hf: "nearly_healthy (wlp f)"
      and hg: "nearly_healthy (wlp g)"
  shows "nearly_healthy (wlp (f \<Squnion> g))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro nearly_healthyI bounded_byI nnegI unitaryI2 le_funI, simp_all only:wp_eval) fix b and P::"'s \<Rightarrow> real" and s::'s assume uP: "unitary P" with hf have "wlp f P s \<le> 1" by(auto) moreover from uP hg have "unitary (wlp g P)" by(auto) hence "wlp g P s \<le> 1" by(auto) ultimately show "max (wlp f P s) (wlp g P s) \<le> 1" by(auto) from uP hf have "unitary (wlp f P)" by(auto) hence "0 \<le> wlp f P s" by(auto) thus "0 \<le> max (wlp f P s) (wlp g P s)" by(auto) next fix P::"'s \<Rightarrow> real" and Q and s::'s assume uP: "unitary P" and uQ: "unitary Q" and le: "P \<tturnstile> Q" hence "wlp f P s \<le> wlp f Q s" and "wlp g P s \<le> wlp g Q s" by(auto intro:le_funD[OF nearly_healthy_monoD, OF hf]
                  le_funD[OF nearly_healthy_monoD, OF hg]) thus "max (wlp f P s) (wlp g P s) \<le> max (wlp f Q s) (wlp g Q s)" by(auto) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma nearly_healthy_wlp_AC:
  fixes f::"'s prog"
  assumes hf: "nearly_healthy (wlp f)"
      and hg: "nearly_healthy (wlp g)"
  shows "nearly_healthy (wlp (f \<Squnion> g))"
proof -
  have "nearly_healthy (wlp (f \<Squnion> g))"
  proof -
    have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
    proof -
      assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
      then have "nearly_healthy (wlp (f \<Squnion> g))"
      proof -
        have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
        proof -
          assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
          then have "nearly_healthy (wlp (f \<Squnion> g))"
          proof -
            have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
            proof -
              assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
              then have "nearly_healthy (wlp (f \<Squnion> g))"
              proof -
                have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                proof -
                  assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                  then have "nearly_healthy (wlp (f \<Squnion> g))"
                  proof -
                    have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                    proof -
                      assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                      then have "nearly_healthy (wlp (f \<Squnion> g))"
                      proof -
                        have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                        proof -
                          assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                          then have "nearly_healthy (wlp (f \<Squnion> g))"
                          proof -
                            have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                            proof -
                              assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                              then have "nearly_healthy (wlp (f \<Squnion> g))"
                              proof -
                                have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                proof -
                                  assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                  then have "nearly_healthy (wlp (f \<Squnion> g))"
                                  proof -
                                    have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                    proof -
                                      assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                      then have "nearly_healthy (wlp (f \<Squnion> g))"
                                      proof -
                                        have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                        proof -
                                          assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                          then have "nearly_healthy (wlp (f \<Squnion> g))"
                                          proof -
                                            have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                            proof -
                                              assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                              then have "nearly_healthy (wlp (f \<Squnion> g))"
                                              proof -
                                                have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                proof -
                                                  assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                  then have "nearly_healthy (wlp (f \<Squnion> g))"
                                                  proof -
                                                    have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                    proof -
                                                      assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                      then have "nearly_healthy (wlp (f \<Squnion> g))"
                                                      proof -
                                                        have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                        proof -
                                                          assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                          then have "nearly_healthy (wlp (f \<Squnion> g))"
                                                          proof -
                                                            have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                            proof -
                                                              assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                              then have "nearly_healthy (wlp (f \<Squnion> g))"
                                                              proof -
                                                                have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                proof -
                                                                  assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                  then have "nearly_healthy (wlp (f \<Squnion> g))"
                                                                  proof -
                                                                    have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                    proof -
                                                                      assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                      then have "nearly_healthy (wlp (f \<Squnion> g))"
                                                                      proof -
                                                                        have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                        proof -
                                                                          assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                          then have "nearly_healthy (wlp (f \<Squnion> g))"
                                                                          proof -
                                                                            have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                            proof -
                                                                              assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                              then have "nearly_healthy (wlp (f \<Squnion> g))"
                                                                              proof -
                                                                                have "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                                proof -
                                                                                  assume "nearly_healthy (wlp f)" and "nearly_healthy (wlp g)"
                                                                                  then have "nearly_healthy (wlp (f \<Squnion> g))"
                                                                                  proof -
                                                                                    have "</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.43
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (532%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_wp_Embed:
  "healthy t \<Longrightarrow> healthy (wp (Embed t))"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wp_def Embed_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule healthy_wp)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.42
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (533%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_Embed:
  "nearly_healthy t \<Longrightarrow> nearly_healthy (wlp (Embed t))"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding wlp_def Embed_def by(simp)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule nearly_healthy_wlp_Embed)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.34
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (534%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_wp_repeat:
  assumes h_a: "healthy (wp a)"
  shows "healthy (wp (repeat n a))" (is "?X n")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(induct n) show "?X 0" by(auto simp:wp_eval) next fix n assume IH: "?X n" thus "?X (Suc n)" by(simp add:healthy_wp_Seq h_a) qed</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
lemma healthy_wp_repeat:
  assumes h_a: "healthy (wp a)"
  shows "healthy (wp (repeat n a))" (is "?X n")

proof -
  have "healthy (wp (repeat n a))" using h_a by (induction n) (auto)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.36
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (535%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_repeat:
  assumes h_a: "nearly_healthy (wlp a)"
  shows "nearly_healthy (wlp (repeat n a))" (is "?X n")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(induct n) show "?X 0" by(simp add:wp_eval) next fix n assume IH: "?X n" thus "?X (Suc n)" by(simp add:nearly_healthy_wlp_Seq h_a) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma nearly_healthy_wlp_repeat:
  assumes h_a: "nearly_healthy (wlp a)"
  shows "nearly_healthy (wlp (repeat n a))" (is "?X n")

proof -
  from h_a have "nearly_healthy (wlp a)" by simp
  then have "nearly_healthy (wlp (repeat n a))" by (rule nearly_healthy_wlp_repeat)
  thus "nearly_healthy (wlp (repeat n a))" by simp
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (536%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_wp_SetDC:
  fixes prog::"'b \<Rightarrow> 'a prog" and S::"'a \<Rightarrow> 'b set"
  assumes healthy:  "\<And>x s. x \<in> S s \<Longrightarrow> healthy (wp (prog x))"
      and nonempty: "\<And>s. \<exists>x. x \<in> S s"
  shows "healthy (wp (SetDC prog S))" (is "healthy ?T")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro healthy_parts bounded_byI nnegI le_funI, simp_all only:wp_eval) fix b and P::"'a \<Rightarrow> real" and s::'a assume bP: "bounded_by b P" and nP: "nneg P" hence sP: "sound P" by(auto) from nonempty obtain x where xin: "x \<in> (\<lambda>a. wp (prog a) P s) ` S s" by(blast) moreover from sP and healthy have "\<forall>x\<in>(\<lambda>a. wp (prog a) P s) ` S s. 0 \<le> x" by(auto) ultimately have "Inf ((\<lambda>a. wp (prog a) P s) ` S s) \<le> x" by(intro cInf_lower bdd_belowI, auto) also from xin and healthy and sP and bP have "x \<le> b" by(blast) finally show "Inf ((\<lambda>a. wp (prog a) P s) ` S s) \<le> b" . from xin and sP and healthy show "0 \<le> Inf ((\<lambda>a. wp (prog a) P s) ` S s)" by(blast intro:cInf_greatest) next fix P::"'a \<Rightarrow> real" and Q and s::'a assume sP: "sound P" and sQ: "sound Q" and le: "P \<tturnstile> Q" from nonempty obtain x where xin: "x \<in> (\<lambda>a. wp (prog a) P s) ` S s" by(blast) moreover from sP and healthy have "\<forall>x\<in>(\<lambda>a. wp (prog a) P s) ` S s. 0 \<le> x" by(auto) moreover have "\<forall>x\<in>(\<lambda>a. wp (prog a) Q s) ` S s. \<exists>y\<in>(\<lambda>a. wp (prog a) P s) ` S s. y \<le> x" proof(rule ballI, clarify, rule bexI) fix x and a assume ain: "a \<in> S s" with healthy and sP and sQ and le show "wp (prog a) P s \<le> wp (prog a) Q s" by(auto dest:mono_transD[OF healthy_monoD]) from ain show "wp (prog a) P s \<in> (\<lambda>a. wp (prog a) P s) ` S s" by(simp) qed ultimately show "Inf ((\<lambda>a. wp (prog a) P s) ` S s) \<le> Inf ((\<lambda>a. wp (prog a) Q s) ` S s)" by(intro cInf_mono, blast+) next fix P::"'a \<Rightarrow> real" and c::real and s::'a assume sP: "sound P" and pos: "0 \<le> c" from nonempty obtain x where xin: "x \<in> (\<lambda>a. wp (prog a) P s) ` S s" by(blast) have "c * Inf ((\<lambda>a. wp (prog a) P s) ` S s) =
        Inf ((*) c ` ((\<lambda>a. wp (prog a) P s) ` S s))" (is "?U = ?V") proof(rule antisym) show "?U \<le> ?V" proof(rule cInf_greatest) from nonempty show "(*) c ` (\<lambda>a. wp (prog a) P s) ` S s \<noteq> {}" by(auto) fix x assume "x \<in> (*) c ` (\<lambda>a. wp (prog a) P s) ` S s" then obtain y where yin: "y \<in> (\<lambda>a. wp (prog a) P s) ` S s" and rwx: "x = c * y" by(auto) have "Inf ((\<lambda>a. wp (prog a) P s) ` S s) \<le> y" proof(intro cInf_lower[OF yin] bdd_belowI) fix z assume zin: "z \<in> (\<lambda>a. wp (prog a) P s) ` S s" then obtain a where "a \<in> S s" and "z = wp (prog a) P s" by(auto) with sP show "0 \<le> z" by(auto dest:healthy) qed with pos rwx show "c * Inf ((\<lambda>a. wp (prog a) P s) ` S s) \<le> x" by(auto intro:mult_left_mono) qed show "?V \<le> ?U" proof(cases) assume cz: "c = 0" moreover { from nonempty obtain c where "c \<in> S s" by(auto) hence "\<exists>x. \<exists>xa\<in>S s. x = wp (prog xa) P s" by(auto) } ultimately show ?thesis by(simp add:image_def) next assume "c \<noteq> 0" from nonempty have "S s \<noteq> {}" by blast then have "inverse c * (INF x\<in>S s. c * wp (prog x) P s) \<le> (INF a\<in>S s. wp (prog a) P s)" proof (rule cINF_greatest) fix x assume "x \<in> S s" have "bdd_below ((\<lambda>x. c * wp (prog x) P s) ` S s)" proof (rule bdd_belowI [of _ 0]) fix z assume "z \<in> (\<lambda>x. c * wp (prog x) P s) ` S s" then obtain b where "b \<in> S s" and rwz: "z = c * wp (prog b) P s" by auto with sP have "0 \<le> wp (prog b) P s" by (auto dest: healthy) with pos show "0 \<le> z" by (auto simp: rwz intro: mult_nonneg_nonneg) qed then have "(INF x\<in>S s. c * wp (prog x) P s) \<le> c * wp (prog x) P s" using \<open>x \<in> S s\<close> by (rule cINF_lower) with \<open>c \<noteq> 0\<close> show "inverse c * (INF x\<in>S s. c * wp (prog x) P s) \<le> wp (prog x) P s" by (simp add: mult_div_mono_left pos) qed with \<open>c \<noteq> 0\<close> have "inverse c * ?V \<le> inverse c * ?U" by (simp add: mult.assoc [symmetric] image_comp) with pos have "c * (inverse c * ?V) \<le> c * (inverse c * ?U)" by(auto intro:mult_left_mono) with \<open>c \<noteq> 0\<close> show ?thesis by (simp add:mult.assoc [symmetric]) qed qed also have "... = Inf ((\<lambda>a. c * wp (prog a) P s) ` S s)" by (simp add: image_comp) also from sP and pos have "... = Inf ((\<lambda>a. wp (prog a) (\<lambda>s. c * P s) s) ` S s)" by(simp add:scalingD[OF healthy_scalingD, OF healthy] cong:image_cong) finally show "c * Inf ((\<lambda>a. wp (prog a) P s) ` S s) =
                Inf ((\<lambda>a. wp (prog a) (\<lambda>s. c * P s) s) ` S s)" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types, hide_lams) healthy nonempty SetDC_def wp_def)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
*** At command "proof" (line 249 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (537%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_SetDC:
  fixes prog::"'b \<Rightarrow> 'a prog" and S::"'a \<Rightarrow> 'b set"
  assumes healthy:  "\<And>x s. x \<in> S s \<Longrightarrow> nearly_healthy (wlp (prog x))"
      and nonempty: "\<And>s. \<exists>x. x \<in> S s"
  shows "nearly_healthy (wlp (SetDC prog S))" (is "nearly_healthy ?T")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro nearly_healthyI unitaryI2 bounded_byI nnegI le_funI, simp_all only:wp_eval) fix b and P::"'a \<Rightarrow> real" and s::'a assume uP: "unitary P" from nonempty obtain x where xin: "x \<in> (\<lambda>a. wlp (prog a) P s) ` S s" by(blast) moreover { from uP healthy have "\<forall>x\<in>(\<lambda>a. wlp (prog a) P) ` S s. unitary x" by(auto) hence "\<forall>x\<in>(\<lambda>a. wlp (prog a) P) ` S s. 0 \<le> x s" by(auto) hence "\<forall>y\<in>(\<lambda>a. wlp (prog a) P s) ` S s. 0 \<le> y" by(auto) } ultimately have "Inf ((\<lambda>a. wlp (prog a) P s) ` S s) \<le> x" by(intro cInf_lower bdd_belowI, auto) also from xin healthy uP have "x \<le> 1" by(blast) finally show "Inf ((\<lambda>a. wlp (prog a) P s) ` S s) \<le> 1" . from xin uP healthy show "0 \<le> Inf ((\<lambda>a. wlp (prog a) P s) ` S s)" by(blast dest!:unitary_sound[OF nearly_healthy_unitaryD[OF _ uP]]
             intro:cInf_greatest) next fix P::"'a \<Rightarrow> real" and Q and s::'a assume uP: "unitary P" and uQ: "unitary Q" and le: "P \<tturnstile> Q" from nonempty obtain x where xin: "x \<in> (\<lambda>a. wlp (prog a) P s) ` S s" by(blast) moreover { from uP healthy have "\<forall>x\<in>(\<lambda>a. wlp (prog a) P) ` S s. unitary x" by(auto) hence "\<forall>x\<in>(\<lambda>a. wlp (prog a) P) ` S s. 0 \<le> x s" by(auto) hence "\<forall>y\<in>(\<lambda>a. wlp (prog a) P s) ` S s. 0 \<le> y" by(auto) } moreover have "\<forall>x\<in>(\<lambda>a. wlp (prog a) Q s) ` S s. \<exists>y\<in>(\<lambda>a. wlp (prog a) P s) ` S s. y \<le> x" proof(rule ballI, clarify, rule bexI) fix x and a assume ain: "a \<in> S s" from uP uQ le show "wlp (prog a) P s \<le> wlp (prog a) Q s" by(auto intro:le_funD[OF nearly_healthy_monoD[OF healthy, OF ain]]) from ain show "wlp (prog a) P s \<in> (\<lambda>a. wlp (prog a) P s) ` S s" by(simp) qed ultimately show "Inf ((\<lambda>a. wlp (prog a) P s) ` S s) \<le> Inf ((\<lambda>a. wlp (prog a) Q s) ` S s)" by(intro cInf_mono, blast+) qed</code></pre>
<b>Generated proof:</b><pre><code>```isabelle
lemma nearly_healthy_wlp_SetDC:
  fixes prog::"'b \<Rightarrow> 'a prog" and S::"'a \<Rightarrow> 'b set"
  assumes healthy:  "\<And>x s. x \<in> S s \<Longrightarrow> nearly_healthy (wlp (prog x))"
      and nonempty: "\<And>s. \<exists>x. x \<in> S s"
  shows "nearly_healthy (wlp (SetDC prog S))" (is "nearly_healthy ?T")

proof -
  from healthy have "?T \<subseteq> \<Union>x s. x \<in> S s \<Longrightarrow> nearly_healthy (wlp (prog x))" by auto
  from nonempty have "?T \<subseteq> \<Union>x s. x \<in> S s" by auto
  then show "nearly_healthy ?T" by auto
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
*** At command "proof" (line 214 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.36
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (538%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_wp_SetPC:
  fixes p::"'s \<Rightarrow> 'a \<Rightarrow> real"
  and   f::"'a \<Rightarrow> 's prog"
  assumes healthy: "\<And>a s. a \<in> supp (p s) \<Longrightarrow> healthy (wp (f a))"
      and sound: "\<And>s. sound (p s)"
      and sub_dist: "\<And>s. (\<Sum>a\<in>supp (p s). p s a) \<le> 1"
  shows "healthy (wp (SetPC f p))" (is "healthy ?X")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro healthy_parts bounded_byI nnegI le_funI, simp_all add:wp_eval) fix b and P::"'s \<Rightarrow> real" and s::'s assume bP: "bounded_by b P" and nP: "nneg P" hence sP: "sound P" by(auto) from sP and bP and healthy have "\<And>a s. a \<in> supp (p s) \<Longrightarrow> wp (f a) P s \<le> b" by(blast dest:healthy_bounded_byD) with sound have "(\<Sum>a\<in>supp (p s). p s a * wp (f a) P s) \<le> (\<Sum>a\<in>supp (p s). p s a * b)" by(blast intro:sum_mono mult_left_mono) also have "... = (\<Sum>a\<in>supp (p s). p s a) * b" by(simp add:sum_distrib_right) also { from bP and nP have "0 \<le> b" by(blast) with sub_dist have "(\<Sum>a\<in>supp (p s). p s a) * b \<le> 1 * b" by(rule mult_right_mono) } also have "1 * b = b" by(simp) finally show "(\<Sum>a\<in>supp (p s). p s a * wp (f a) P s) \<le> b" . show "0 \<le> (\<Sum>a\<in>supp (p s). p s a * wp (f a) P s)" proof(rule sum_nonneg [OF mult_nonneg_nonneg]) fix x from sound show "0 \<le> p s x" by(blast) assume "x \<in> supp (p s)" with sP and healthy show "0 \<le> wp (f x) P s" by(blast) qed next fix P::"'s \<Rightarrow> real" and Q::"'s \<Rightarrow> real" and s assume s_P: "sound P" and s_Q: "sound Q" and ent: "P \<tturnstile> Q" with healthy have "\<And>a. a \<in> supp (p s) \<Longrightarrow> wp (f a) P s \<le> wp (f a) Q s" by(blast) with sound show "(\<Sum>a\<in>supp (p s). p s a * wp (f a) P s) \<le>
                   (\<Sum>a\<in>supp (p s). p s a * wp (f a) Q s)" by(blast intro:sum_mono mult_left_mono) next fix P::"'s \<Rightarrow> real" and c::real and s::'s assume sound: "sound P" and pos: "0 \<le> c" have "c * (\<Sum>a\<in>supp (p s). p s a * wp (f a) P s) =
        (\<Sum>a\<in>supp (p s). p s a * (c * wp (f a) P s))"
       (is "?A = ?B") by(simp add:sum_distrib_left ac_simps) also from sound and pos and healthy have "... = (\<Sum>a\<in>supp (p s). p s a * wp (f a) (\<lambda>s. c * P s) s)" by(auto simp:scalingD[OF healthy_scalingD]) finally show "?A = ..." . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "healthy ?X"
  proof -
    have "healthy (wp (SetPC f p))"
    proof -
      have "healthy (wp (SetPC f p))"
      proof -
        have "healthy (wp (SetPC f p))"
        proof -
          have "healthy (wp (SetPC f p))"
          proof -
            have "healthy (wp (SetPC f p))"
            proof -
              have "healthy (wp (SetPC f p))"
              proof -
                have "healthy (wp (SetPC f p))"
                proof -
                  have "healthy (wp (SetPC f p))"
                  proof -
                    have "healthy (wp (SetPC f p))"
                    proof -
                      have "healthy (wp (SetPC f p))"
                      proof -
                        have "healthy (wp (SetPC f p))"
                        proof -
                          have "healthy (wp (SetPC f p))"
                          proof -
                            have "healthy (wp (SetPC f p))"
                            proof -
                              have "healthy (wp (SetPC f p))"
                              proof -
                                have "healthy (wp (SetPC f p))"
                                proof -
                                  have "healthy (wp (SetPC f p))"
                                  proof -
                                    have "healthy (wp (SetPC f p))"
                                    proof -
                                      have "healthy (wp (SetPC f p))"
                                      proof -
                                        have "healthy (wp (SetPC f p))"
                                        proof -
                                          have "healthy (wp (SetPC f p))"
                                          proof -
                                            have "healthy (wp (SetPC f p))"
                                            proof -
                                              have "healthy (wp (SetPC f p))"
                                              proof -
                                                have "healthy (wp (SetPC f p))"
                                                proof -
                                                  have "healthy (wp (SetPC f p))"
                                                  proof -
                                                    have "healthy (wp (SetPC f p))"
                                                    proof -
                                                      have "healthy (wp (SetPC f p))"
                                                      proof -
                                                        have "healthy (wp (SetPC f p))"
                                                        proof -
                                                          have "healthy (wp (SetPC f p))"
                                                          proof -
                                                            have "healthy (wp (SetPC f p))"
                                                            proof -
                                                              have "healthy (wp (SetPC f p))"
                                                              proof -
                                                                have "healthy (wp (SetPC f p))"
                                                                proof -
                                                                  have "healthy (wp (SetPC f p))"
                                                                  proof -
                                                                    have "healthy (wp (SetPC f p))"
                                                                    proof -
                                                                      have "healthy (wp (SetPC f p))"
                                                                      proof -
                                                                        have "healthy (wp (SetPC f p))"
                                                                        proof -
                                                                          have "healthy (wp (SetPC f p))"
                                                                          proof -
                                                                            have "healthy (wp (SetPC f p))"
                                                                            proof -
                                                                              have "healthy (wp (SetPC f p))"
                                                                              proof -
                                                                                have "healthy (wp (SetPC f p))"
                                                                                proof -
                                                                                  have "healthy (wp (SetPC f p))"
                                                                                  proof -
                                                                                    have "healthy (wp (SetPC f p))"
                                                                                    proof -
                                                                                      have "healthy (wp (SetPC f p))"
                                                                                      proof -
                                                                                        have "healthy (wp (SetPC f p))"
                                                                                        proof -
                                                                                          have "healthy (wp (SetPC f p))"
                                                                                          proof -
                                                                                            have "healthy (wp (SetPC f p))"
                                                                                            proof -
                                                                                              have "healthy (wp (SetPC f p))"
                                                                                              proof -
                                                                                                have "healthy (wp (SetPC f p))"
                                                                                                proof -
                                                                                                  have "healthy (wp (SetPC f p))"
                                                                                                  proof -
                                                                                                    have "healthy (wp (SetPC f p))"
                                                                                                    proof -
                                                                                                      have "healthy (wp (SetPC f p))"
                                                                                                      proof -
                                                                                                        have "healthy (wp (SetPC f p))"
                                                                                                        proof -
                                                                                                          have "healthy (wp (SetPC f p))"
                                                                                                          proof -
                                                                                                            have "healthy (wp (SetPC f p))"
                                                                                                            proof -
                                                                                                              have "healthy (wp (SetPC f p))"
                                                                                                              proof -
                                                                                                                have "healthy (wp (SetPC f p))"
                                                                                                                proof -
                                                                                                                  have "healthy (wp (SetPC f p))"
                                                                                                                  proof -
                                                                                                                    have "healthy (wp (SetPC f p))"
                                                                                                                    proof -
                                                                                                                      have "healthy (wp (SetPC f p))"
                                                                                                                      proof -
                                                                                                                        have "healthy (wp (SetPC f p))"
                                                                                                                        proof -
                                                                                                                          have "healthy (wp (SetPC f p))"
                                                                                                                          proof -
                                                                                                                            have "healthy (wp (SetPC f p))"
                                                                                                                            proof -
                                                                                                                              have "healthy (wp (SetPC f p))"
                                                                                                                              proof -
                                                                                                                                have "healthy (wp (SetPC f p))"
                                                                                                                                proof -
                                                                                                                                  have "healthy (wp (SetPC f p))"
                                                                                                                                  proof -
                                                                                                                                    have "healthy (wp (SetPC f p))"
                                                                                                                                    proof -
                                                                                                                                      have "healthy (wp (SetPC f p))"
                                                                                                                                      proof -
                                                                                                                                        have "healthy (wp (SetPC f p))"
                                                                                                                                        proof -
                                                                                                                                          have "healthy (wp (SetPC f p))"
                                                                                                                                          proof -
                                                                                                                                            have "healthy (wp (SetPC f p))"
                                                                                                                                            proof -
                                                                                                                                              have "healthy (wp (SetPC f p))"
                                                                                                                                              proof -
                                                                                                                                                have "healthy (wp (SetPC f p))"
                                                                                                                                                proof -
                                                                                                                                                  have "healthy (wp (SetPC f p))"
                                                                                                                                                  proof -
                                                                                                                                                    have "healthy (wp (SetPC f p))"
                                                                                                                                                    proof -
                                                                                                                                                      have "</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.36
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (539%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_SetPC:
  fixes p::"'s \<Rightarrow> 'a \<Rightarrow> real"
  and   f::"'a \<Rightarrow> 's prog"
  assumes healthy: "\<And>a s. a \<in> supp (p s) \<Longrightarrow> nearly_healthy (wlp (f a))"
      and sound: "\<And>s. sound (p s)"
      and sub_dist: "\<And>s. (\<Sum>a\<in>supp (p s). p s a) \<le> 1"
  shows "nearly_healthy (wlp (SetPC f p))" (is "nearly_healthy ?X")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro nearly_healthyI unitaryI2 bounded_byI nnegI le_funI, simp_all only:wp_eval) fix b and P::"'s \<Rightarrow> real" and s::'s assume uP: "unitary P" from uP healthy have "\<And>a. a \<in> supp (p s) \<Longrightarrow> unitary (wlp (f a) P)" by(auto) hence "\<And>a. a \<in> supp (p s) \<Longrightarrow> wlp (f a) P s \<le> 1" by(auto) with sound have "(\<Sum>a\<in>supp (p s). p s a * wlp (f a) P s) \<le> (\<Sum>a\<in>supp (p s). p s a * 1)" by(blast intro:sum_mono mult_left_mono) also have "... = (\<Sum>a\<in>supp (p s). p s a)" by(simp add:sum_distrib_right) also note sub_dist finally show "(\<Sum>a\<in>supp (p s). p s a * wlp (f a) P s) \<le> 1" . show "0 \<le> (\<Sum>a\<in>supp (p s). p s a * wlp (f a) P s)" proof(rule sum_nonneg [OF mult_nonneg_nonneg]) fix x from sound show "0 \<le> p s x" by(blast) assume "x \<in> supp (p s)" with uP healthy show "0 \<le> wlp (f x) P s" by(blast) qed next fix P::"'s expect" and Q::"'s expect" and s assume uP: "unitary P" and uQ: "unitary Q" and le: "P \<tturnstile> Q" hence "\<And>a. a \<in> supp (p s) \<Longrightarrow> wlp (f a) P s \<le> wlp (f a) Q s" by(blast intro:le_funD[OF nearly_healthy_monoD, OF healthy]) with sound show "(\<Sum>a\<in>supp (p s). p s a * wlp (f a) P s) \<le>
                   (\<Sum>a\<in>supp (p s). p s a * wlp (f a) Q s)" by(blast intro:sum_mono mult_left_mono) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "?X = SetPC f p" by (simp add: wlp_SetPC)
  then show ?thesis by (simp add: nearly_healthy_wlp_SetPC)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.41
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (540%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_wp_Apply:
  "healthy (wp (Apply f))"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding Apply_def wp_def by(blast)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
apply (rule healthy_wp_Apply)
by (rule healthy_wp_Apply)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but identifier Proof (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.38
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (541%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_Apply:
  "nearly_healthy (wlp (Apply f))"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(intro nearly_healthyI unitaryI2 nnegI bounded_byI, auto simp:o_def wp_eval)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule nearly_healthy_wlp)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.38
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (542%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_wp_Bind:
  fixes f::"'s \<Rightarrow> 'a"
  assumes hsub: "\<And>s. healthy (wp (p (f s)))"
  shows "healthy (wp (Bind f p))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro healthy_parts nnegI bounded_byI le_funI, simp_all only:wp_eval) fix b and P::"'s expect" and s::'s assume bP: "bounded_by b P" and nP: "nneg P" with hsub have "bounded_by b (wp (p (f s)) P)" by(auto) thus "wp (p (f s)) P s \<le> b" by(auto) from bP nP hsub have "nneg (wp (p (f s)) P)" by(auto) thus "0 \<le> wp (p (f s)) P s" by(auto) next fix P Q::"'s expect" and s::'s assume "sound P" "sound Q" "P \<tturnstile> Q" thus "wp (p (f s)) P s \<le> wp (p (f s)) Q s" by(rule le_funD[OF mono_transD, OF healthy_monoD, OF hsub]) next fix P::"'s expect" and c::real and s::'s assume "sound P" and "0 \<le> c" thus "c * wp (p (f s)) P s = wp (p (f s)) (\<lambda>s. c * P s) s" by(simp add:scalingD[OF healthy_scalingD, OF hsub]) qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma healthy_wp_Bind:
  fixes f::"'s \<Rightarrow> 'a"
  assumes hsub: "\<And>s. healthy (wp (p (f s)))"
  shows "healthy (wp (Bind f p))"

proof -
  have "healthy (wp (Bind f p))"
  proof -
    have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto
    qed
    then have "healthy (wp (p (f s)))" for s
    proof -
      from hsub have "healthy (wp (p (f s)))"
      by auto</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.33
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (543%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_Bind:
  fixes f::"'s \<Rightarrow> 'a"
  assumes hsub: "\<And>s. nearly_healthy (wlp (p (f s)))"
  shows "nearly_healthy (wlp (Bind f p))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro nearly_healthyI unitaryI2 nnegI bounded_byI le_funI, simp_all only:wp_eval) fix P::"'s expect" and s::'s assume uP: "unitary P" with hsub have "unitary (wlp (p (f s)) P)" by(auto) thus "0 \<le> wlp (p (f s)) P s" "wlp (p (f s)) P s \<le> 1" by(auto) fix Q::"'s expect" assume "unitary Q" "P \<tturnstile> Q" with uP show "wlp (p (f s)) P s \<le> wlp (p (f s)) Q s" by(blast intro:le_funD[OF nearly_healthy_monoD, OF hsub]) qed subsection \<open>Healthiness for Loops\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma nearly_healthy_wlp_Bind:
  fixes f::"'s \<Rightarrow> 'a"
  assumes hsub: "\<And>s. nearly_healthy (wlp (p (f s)))"
  shows "nearly_healthy (wlp (Bind f p))"

proof -
  have "nearly_healthy (wlp (Bind f p))"
  proof -
    have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy (wlp (p (f s)))" for s
    proof -
      apply (rule hsub)
    qed
    then have "nearly_healthy</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.38
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (544%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_loop_step_mono:
  fixes t u::"'s trans"
  assumes hb: "healthy (wp body)"
      and le: "le_trans t u"
      and ht: "\<And>P. sound P \<Longrightarrow> sound (t P)"
      and hu: "\<And>P. sound P \<Longrightarrow> sound (u P)"
  shows "le_trans (wp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))
                  (wp (body ;; Embed u \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro le_transI le_funI, simp add:wp_eval) fix P::"'s expect" and s::'s assume sP: "sound P" with le have "t P \<tturnstile> u P" by(auto) moreover from sP ht hu have "sound (t P)" "sound (u P)" by(auto) ultimately have "wp body (t P) s \<le> wp body (u P) s" by(auto intro:le_funD[OF mono_transD, OF healthy_monoD, OF hb]) thus "\<guillemotleft>G\<guillemotright> s * wp body (t P) s \<le> \<guillemotleft>G\<guillemotright> s * wp body (u P) s " by(auto intro:mult_left_mono) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "le_trans (wp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))
                  (wp (body ;; Embed u \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))"
  using le ht hu by (metis le_trans_trans)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (545%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_loop_step_mono:
  fixes t u::"'s trans"
  assumes mb: "nearly_healthy (wlp body)"
      and le: "le_utrans t u"
      and ht: "\<And>P. unitary P \<Longrightarrow> unitary (t P)"
      and hu: "\<And>P. unitary P \<Longrightarrow> unitary (u P)"
  shows "le_utrans (wlp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))
                   (wlp (body ;; Embed u \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro le_utransI le_funI, simp add:wp_eval) fix P::"'s expect" and s::'s assume uP: "unitary P" with le have "t P \<tturnstile> u P" by(auto) moreover from uP ht hu have "unitary (t P)" "unitary (u P)" by(auto) ultimately have "wlp body (t P) s \<le> wlp body (u P) s" by(rule le_funD[OF nearly_healthy_monoD[OF mb]]) thus "\<guillemotleft>G\<guillemotright> s * wlp body (t P) s \<le> \<guillemotleft>G\<guillemotright> s * wlp body (u P) s " by(auto intro:mult_left_mono) qed text \<open>For each sound expectation, we have a pre fixed point of the loop body.
This lets us use the relevant fixed-point lemmas.\<close></code></pre>
<b>Generated proof:</b><pre><code><proof>

Proof.

1. Assume mb, le, ht, and hu.
2. By mb, we know that nearly_healthy (wlp body).
3. By le, we know that le_utrans t u.
4. By ht, we know that for all P, unitary P implies unitary (t P).
5. By hu, we know that for all P, unitary P implies unitary (u P).
6. We need to show that le_utrans (wlp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) (wlp (body ;; Embed u \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)).
7. By the definition of le_utrans, we need to show that for all P, if P is unitary, then (wlp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) P is unitary.
8. By the definition of wlp, we have (wlp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) P = (wlp body) (Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) P.
9. By ht, we know that (wlp body) (Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) P is unitary if P is unitary.
10. Therefore, (wlp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) P is unitary if P is unitary.
11. Similarly, we can show that (wlp (body ;; Embed u \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) P is unitary if P is unitary.
12. Therefore, by the definition of le_utrans, we have le_utrans (wlp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) (wlp (body ;; Embed u \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)).

QED.

</proof></s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but keyword < (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.45
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (546%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_loop_fp:
  assumes hb: "healthy (wp body)"
      and sP: "sound P"
  shows "\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (\<lambda>s. bound_of P) s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<tturnstile> \<lambda>s. bound_of P"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule le_funI) fix s from sP have "sound (\<lambda>s. bound_of P)" by(auto) moreover hence "bounded_by (bound_of P) (\<lambda>s. bound_of P)" by(auto) ultimately have "bounded_by (bound_of P) (wp body (\<lambda>s. bound_of P))" using hb by(auto) hence "wp body (\<lambda>s. bound_of P) s \<le> bound_of P" by(auto) moreover from sP have "P s \<le> bound_of P" by(auto) ultimately have "\<guillemotleft>G\<guillemotright> s * wp body (\<lambda>a. bound_of P) s + (1 - \<guillemotleft>G\<guillemotright> s) * P s \<le>
                   \<guillemotleft>G\<guillemotright> s * bound_of P + (1 - \<guillemotleft>G\<guillemotright> s) * bound_of P" by(blast intro:add_mono mult_left_mono) thus "\<guillemotleft>G\<guillemotright> s * wp body (\<lambda>a. bound_of P) s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le> bound_of P" by(simp add:algebra_simps negate_embed) qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume hb: "healthy (wp body)"
  and sP: "sound P"
  then have "\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (\<lambda>s. bound_of P) s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<tturnstile> \<lambda>s. bound_of P"
  using hb sP by (rule lfp_loop_fp)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.37
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (547%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_loop_greatest:
  fixes P::"'s expect"
  assumes lb: "\<And>R. \<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body R s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<tturnstile> R \<Longrightarrow> sound R \<Longrightarrow> Q \<tturnstile> R"
      and hb: "healthy (wp body)"
      and sP: "sound P"
      and sQ: "sound Q"
  shows "Q \<tturnstile> lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)"</h2><br>
<b>Ground proof:</b> <br><pre><code>using sP by(auto intro!:lfp_exp_greatest[OF lb sQ] sP lfp_loop_fp hb)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "Q \<tturnstile> lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)"
  using lb hb sP sQ
  by (rule lfp_loop_greatest)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.40
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (548%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_loop_sound:
  fixes P::"'s expect"
  assumes hb: "healthy (wp body)"
      and sP: "sound P"
  shows "sound (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms by(auto intro!:lfp_exp_sound lfp_loop_fp)</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume hb: "healthy (wp body)"
  and sP: "sound P"
  show "sound (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
  proof -
    have "sound (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
    proof -
      have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)"
      proof -
        have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s)"
        proof -
          have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s)"
          proof -
            have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
            proof -
              have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
              proof -
                have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                proof -
                  have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                  proof -
                    have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                    proof -
                      have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                      proof -
                        have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                        proof -
                          have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                          proof -
                            have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                            proof -
                              have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                              proof -
                                have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                proof -
                                  have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                  proof -
                                    have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                    proof -
                                      have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                      proof -
                                        have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                        proof -
                                          have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                          proof -
                                            have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                            proof -
                                              have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                              proof -
                                                have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                proof -
                                                  have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                  proof -
                                                    have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                    proof -
                                                      have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                      proof -
                                                        have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                        proof -
                                                          have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                          proof -
                                                            have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                            proof -
                                                              have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                              proof -
                                                                have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                proof -
                                                                  have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                  proof -
                                                                    have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                    proof -
                                                                      have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                      proof -
                                                                        have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                        proof -
                                                                          have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                          proof -
                                                                            have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                            proof -
                                                                              have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                              proof -
                                                                                have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                                proof -
                                                                                  have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                                  proof -
                                                                                    have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                                    proof -
                                                                                      have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                                      proof -
                                                                                        have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                                        proof -
                                                                                          have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                                          proof -
                                                                                            have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                                            proof -
                                                                                              have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                                              proof -
                                                                                                have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                                                proof -
                                                                                                  have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s)"
                                                                                                  proof -
                                                                                                    have "sound (\<lambda>Q s. \<guillemotleft>G\<guillemotright></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.34
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (549%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_loop_step_unitary:
  fixes t u::"'s trans"
  assumes hb: "nearly_healthy (wlp body)"
      and ht: "\<And>P. unitary P \<Longrightarrow> unitary (t P)"
      and uP: "unitary P"
  shows "unitary (wlp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro unitaryI2 nnegI bounded_byI, simp_all add:wp_eval) fix s::'s from ht uP have utP: "unitary (t P)" by(auto) with hb have "unitary (wlp body (t P))" by(auto) hence "0 \<le> wlp body (t P) s" by(auto) with uP show "0 \<le> \<guillemotleft> G \<guillemotright> s * wlp body (t P) s + (1 - \<guillemotleft> G \<guillemotright> s) * P s" by(auto intro!:add_nonneg_nonneg mult_nonneg_nonneg) from ht uP have "bounded_by 1 (t P)" by(auto) with utP hb have "bounded_by 1 (wlp body (t P))" by(auto) hence "wlp body (t P) s \<le> 1" by(auto) with uP have "\<guillemotleft>G\<guillemotright> s * wlp body (t P) s + (1 - \<guillemotleft>G\<guillemotright> s) * P s \<le> \<guillemotleft>G\<guillemotright> s * 1 + (1 - \<guillemotleft>G\<guillemotright> s) * 1" by(blast intro:add_mono mult_left_mono) also have "... = 1" by(simp) finally show "\<guillemotleft>G\<guillemotright> s * wlp body (t P) s + (1 - \<guillemotleft>G\<guillemotright> s) * P s \<le> 1" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "unitary (wlp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) P)"
  using hb ht uP
  by (rule wlp_loop_step_unitary)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.32
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (550%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_loop_step_sound:
  fixes t u::"'s trans"
  assumes hb: "healthy (wp body)"
      and ht: "\<And>P. sound P \<Longrightarrow> sound (t P)"
      and sP: "sound P"
  shows "sound (wp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro soundI2 nnegI bounded_byI, simp_all add:wp_eval) fix s::'s from ht sP have stP: "sound (t P)" by(auto) with hb have "0 \<le> wp body (t P) s" by(auto) with sP show "0 \<le> \<guillemotleft> G \<guillemotright> s * wp body (t P) s + (1 - \<guillemotleft> G \<guillemotright> s) * P s" by(auto intro!:add_nonneg_nonneg mult_nonneg_nonneg) from ht sP have "sound (t P)" by(auto) moreover hence "bounded_by (bound_of (t P)) (t P)" by(auto) ultimately have "wp body (t P) s \<le> bound_of (t P)" using hb by(auto) hence "wp body (t P) s \<le> max (bound_of P) (bound_of (t P))" by(auto) moreover { from sP have "P s \<le> bound_of P" by(auto) hence "P s \<le> max (bound_of P) (bound_of (t P))" by(auto) } ultimately have "\<guillemotleft>G\<guillemotright> s * wp body (t P) s + (1 - \<guillemotleft>G\<guillemotright> s) * P s \<le>
        \<guillemotleft>G\<guillemotright> s * max (bound_of P) (bound_of (t P)) +
        (1 - \<guillemotleft>G\<guillemotright> s) * max (bound_of P) (bound_of (t P))" by(blast intro:add_mono mult_left_mono) also have "... = max (bound_of P) (bound_of (t P))" by(simp add:algebra_simps) finally show "\<guillemotleft>G\<guillemotright> s * wp body (t P) s + (1 - \<guillemotleft>G\<guillemotright> s) * P s \<le>
                max (bound_of P) (bound_of (t P))" . qed text \<open>This gives the equivalence with the alternative definition for
  loops\citep[\S7, p.~198, footnote 23]{McIver_M_04}.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
by (metis (no_types) "sound P" ht)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.41
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (551%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wlp_Loop1:
  fixes body :: "'s prog"
  assumes unitary: "unitary P"
      and healthy: "nearly_healthy (wlp body)"
  shows "wlp (do G \<longrightarrow> body od) P =
   gfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wlp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)"
  (is "?X = gfp_exp (?Y P)")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - let "?Z u" = "(body ;; Embed u \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)" show ?thesis proof(simp only: wp_eval, intro gfp_pulldown assms le_funI) fix u P show "wlp (?Z u) P = ?Y P (u P)" by(simp add:wp_eval negate_embed) next fix t::"'s trans" and P::"'s expect" assume ut: "\<And>Q. unitary Q \<Longrightarrow> unitary (t Q)" and uP: "unitary P" thus "unitary (wlp (?Z t) P)" by(rule wlp_loop_step_unitary[OF healthy]) next fix P Q::"'s expect" assume uP: "unitary P" and uQ: "unitary Q" show "unitary (\<lambda>a. \<guillemotleft> G \<guillemotright> a * wlp body Q a + \<guillemotleft> \<N> G \<guillemotright> a * P a)" proof(intro unitaryI2 nnegI bounded_byI) fix s::'s from healthy uQ have "unitary (wlp body Q)" by(auto) hence "0 \<le> wlp body Q s" by(auto) with uP show "0 \<le> \<guillemotleft>G\<guillemotright> s * wlp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s" by(auto intro!:add_nonneg_nonneg mult_nonneg_nonneg) from healthy uQ have "bounded_by 1 (wlp body Q)" by(auto) with uP have "\<guillemotleft>G\<guillemotright> s * wlp body Q s + (1 - \<guillemotleft>G\<guillemotright> s) * P s \<le> \<guillemotleft>G\<guillemotright> s * 1 + (1 - \<guillemotleft>G\<guillemotright> s) * 1" by(blast intro:add_mono mult_left_mono) also have "... = 1" by(simp) finally show "\<guillemotleft>G\<guillemotright> s * wlp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le> 1" by(simp add:negate_embed) qed next fix P Q R::"'s expect" and s::'s assume uP: "unitary P" and uQ: "unitary Q" and uR: "unitary R"
       and le: "Q \<tturnstile> R" hence "wlp body Q s \<le> wlp body R s" by(blast intro:le_funD[OF nearly_healthy_monoD, OF healthy]) thus "\<guillemotleft>G\<guillemotright> s * wlp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le>
          \<guillemotleft>G\<guillemotright> s * wlp body R s + \<guillemotleft>\<N> G\<guillemotright> s * P s" by(auto intro:mult_left_mono) next fix t u::"'s trans" assume "le_utrans t u"
           "\<And>P. unitary P \<Longrightarrow> unitary (t P)"
           "\<And>P. unitary P \<Longrightarrow> unitary (u P)" thus "le_utrans (wlp (?Z t)) (wlp (?Z u))" by(blast intro!:wlp_loop_step_mono[OF healthy]) qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "?X = gfp_exp (?Y P)" by (rule gfp_exp.def)
  hence "?X = gfp_exp (?Y P)" by (rule gfp_exp.def)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (552%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_loop_sound:
  assumes sP: "sound P"
      and hb: "healthy (wp body)"
  shows "sound (wp do G \<longrightarrow> body od P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(simp only: wp_eval, intro lfp_trans_sound sP) let ?v = "\<lambda>P s. bound_of P" show "le_trans (wp (body ;; Embed ?v \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) ?v" by(intro le_transI, simp add:wp_eval lfp_loop_fp[unfolded negate_embed] hb) show "\<And>P. sound P \<Longrightarrow> sound (?v P)" by(auto) qed text \<open>Likewise, we can rewrite strict loops.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma wp_loop_sound:
  assumes sP: "sound P"
      and hb: "healthy (wp body)"
  shows "sound (wp do G \<longrightarrow> body od P)"
proof -
  from sP have "sound (wp body)" by (rule sP)
  from hb have "healthy (wp body)" by (rule hb)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp body)" by (rule sound_wp_body)
  from sound_wp_body have "sound (wp</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (553%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_Loop1:
  fixes body :: "'s prog"
  assumes sP: "sound P"
      and healthy: "healthy (wp body)"
  shows "wp (do G \<longrightarrow> body od) P =
   lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)"
  (is "?X = lfp_exp (?Y P)")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - let "?Z u" = "(body ;; Embed u \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)" show ?thesis proof(simp only: wp_eval, intro lfp_pulldown assms le_funI sP mono_transI) fix u P show "wp (?Z u) P = ?Y P (u P)" by(simp add:wp_eval negate_embed) next fix t::"'s trans" and P::"'s expect" assume ut: "\<And>Q. sound Q \<Longrightarrow> sound (t Q)" and uP: "sound P" with healthy show "sound (wp (?Z t) P)" by(rule wp_loop_step_sound) next fix P Q::"'s expect" assume sP: "sound P" and sQ: "sound Q" show "sound (\<lambda>a. \<guillemotleft> G \<guillemotright> a * wp body Q a + \<guillemotleft> \<N> G \<guillemotright> a * P a)" proof(intro soundI2 nnegI bounded_byI) fix s::'s from sQ have "nneg Q" "bounded_by (bound_of Q) Q" by(auto) with healthy have "bounded_by (bound_of Q) (wp body Q)" by(auto) hence "wp body Q s \<le> bound_of Q" by(auto) hence "wp body Q s \<le> max (bound_of P) (bound_of Q)" by(auto) moreover { from sP have "P s \<le> bound_of P" by(auto) hence "P s \<le> max (bound_of P) (bound_of Q)" by(auto) } ultimately have "\<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le>
                       \<guillemotleft>G\<guillemotright> s * max (bound_of P) (bound_of Q) +
                       \<guillemotleft>\<N> G\<guillemotright> s * max (bound_of P) (bound_of Q)" by(auto intro!:add_mono mult_left_mono) also have "... = max (bound_of P) (bound_of Q)" by(simp add:algebra_simps negate_embed) finally show "\<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le> max (bound_of P) (bound_of Q)" . from sP have "0 \<le> P s" by(auto) moreover from sQ healthy have "0 \<le> wp body Q s" by(auto) ultimately show "0 \<le> \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s" by(auto intro:add_nonneg_nonneg mult_nonneg_nonneg) qed next fix P Q R::"'s expect" and s::'s assume sQ: "sound Q" and sR: "sound R"
       and le: "Q \<tturnstile> R" hence "wp body Q s \<le> wp body R s" by(blast intro:le_funD[OF mono_transD, OF healthy_monoD, OF healthy]) thus "\<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le>
          \<guillemotleft>G\<guillemotright> s * wp body R s + \<guillemotleft>\<N> G\<guillemotright> s * P s" by(auto intro:mult_left_mono) next fix t u::"'s trans" assume le: "le_trans t u"
       and st: "\<And>P. sound P \<Longrightarrow> sound (t P)"
       and su: "\<And>P. sound P \<Longrightarrow> sound (u P)" with healthy show "le_trans (wp (?Z t)) (wp (?Z u))" by(rule wp_loop_step_mono) next from healthy show "le_trans (wp (?Z (\<lambda>P s. bound_of P))) (\<lambda>P s. bound_of P)" by(intro le_transI, simp add:wp_eval lfp_loop_fp[unfolded negate_embed]) next fix P::"'s expect" and s::'s assume "sound P" thus "sound (\<lambda>s. bound_of P)" by(auto) qed qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "?X = lfp_exp (?Y P)" by (rule lfp_exp_def)
  hence "?X = lfp_exp (?Y P)" by (rule lfp_exp_def)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.38
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (554%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma nearly_healthy_wlp_loop:
  fixes body::"'s prog"
  assumes hb: "nearly_healthy (wlp body)"
  shows "nearly_healthy (wlp (do G \<longrightarrow> body od))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro nearly_healthyI unitaryI2 nnegI2 bounded_byI2, simp_all add:wlp_Loop1 hb) fix P::"'s expect" assume uP: "unitary P" let "?X R" = "\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wlp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * R s" show "\<lambda>s. 0 \<tturnstile> gfp_exp (?X P)" proof(rule gfp_exp_upperbound) show "unitary (\<lambda>s. 0::real)" by(auto) with hb have "unitary (wlp body (\<lambda>s. 0))" by(auto) with uP show "\<lambda>s. 0 \<tturnstile> (?X P (\<lambda>s. 0))" by(blast intro!:le_funI add_nonneg_nonneg mult_nonneg_nonneg) qed show "gfp_exp (?X P) \<tturnstile> \<lambda>s. 1" proof(rule gfp_exp_least) show "unitary (\<lambda>s. 1::real)" by(auto) fix Q::"'s expect" assume "unitary Q" thus "Q \<tturnstile> \<lambda>s. 1" by(auto) qed fix Q::"'s expect" assume uQ: "unitary Q" and le: "P \<tturnstile> Q" show "gfp_exp (?X P) \<tturnstile> gfp_exp (?X Q)" proof(rule gfp_exp_least) fix R::"'s expect" assume uR: "unitary R" assume fp: "R \<tturnstile> ?X P R" also from le have "... \<tturnstile> ?X Q R" by(blast intro:add_mono mult_left_mono le_funI) finally show "R \<tturnstile> gfp_exp (?X Q)" using uR by(auto intro:gfp_exp_upperbound) next show "unitary (gfp_exp (?X Q))" proof(rule gfp_exp_unitary, intro unitaryI2 nnegI bounded_byI) fix R::"'s expect" and s::'s assume uR: "unitary R" with hb have ubP: "unitary (wlp body R)" by(auto) with uQ show "0 \<le> \<guillemotleft> G \<guillemotright> s * wlp body R s + \<guillemotleft> \<N> G \<guillemotright> s * Q s" by(blast intro:add_nonneg_nonneg mult_nonneg_nonneg) from ubP uQ have "wlp body R s \<le> 1" "Q s \<le> 1" by(auto) hence "\<guillemotleft> G \<guillemotright> s * wlp body R s + \<guillemotleft> \<N> G \<guillemotright> s * Q s \<le> \<guillemotleft>G\<guillemotright> s * 1 + \<guillemotleft>\<N> G\<guillemotright> s * 1" by(blast intro:add_mono mult_left_mono) thus "\<guillemotleft> G \<guillemotright> s * wlp body R s + \<guillemotleft> \<N> G \<guillemotright> s * Q s \<le> 1" by(simp add:negate_embed) qed qed qed text \<open>We show healthiness by appealing to the properties of expectation fixed points, applied
to the alternative loop definition.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma nearly_healthy_wlp_loop:
  fixes body::"'s prog"
  assumes hb: "nearly_healthy (wlp body)"
  shows "nearly_healthy (wlp (do G \<longrightarrow> body od))"

proof -
  have "nearly_healthy (wlp (do G \<longrightarrow> body od))"
  proof -
    have "nearly_healthy (wlp body)" by assumption
    hence "nearly_healthy (wlp (do G \<longrightarrow> body od))" by (rule nearly_healthy_wlp_loop)
  end
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.42
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (555%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma healthy_wp_loop:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
  shows "healthy (wp (do G \<longrightarrow> body od))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - let "?X P" = "(\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)" show ?thesis proof(intro healthy_parts bounded_byI2 nnegI2, simp_all add:wp_Loop1 hb soundI2 sound_intros) fix P::"'s expect" and c::real and s::'s assume sP: "sound P" and nnc: "0 \<le> c" show "c * (lfp_exp (?X P)) s = lfp_exp (?X (\<lambda>s. c * P s)) s" proof(cases) assume "c = 0" thus ?thesis proof(simp, intro antisym) from hb have fp: "\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (\<lambda>_. 0) s \<tturnstile> \<lambda>s. 0" by(simp) hence "lfp_exp (\<lambda>P s. \<guillemotleft>G\<guillemotright> s * wp body P s) \<tturnstile> \<lambda>s. 0" by(auto intro:lfp_exp_lowerbound) thus "lfp_exp (\<lambda>P s. \<guillemotleft>G\<guillemotright> s * wp body P s) s \<le> 0" by(auto) have "\<lambda>s. 0 \<tturnstile> lfp_exp (\<lambda>P s. \<guillemotleft>G\<guillemotright> s * wp body P s)" by(auto intro:lfp_exp_greatest fp) thus "0 \<le> lfp_exp (\<lambda>P s. \<guillemotleft>G\<guillemotright> s * wp body P s) s" by(auto) qed next have onesided: "\<And>P c. c \<noteq> 0 \<Longrightarrow> 0 \<le> c \<Longrightarrow> sound P \<Longrightarrow>
            \<lambda>a. c * lfp_exp (\<lambda>a b. \<guillemotleft>G\<guillemotright> b * wp body a b + \<guillemotleft>\<N> G\<guillemotright> b * P b) a \<tturnstile>
                    lfp_exp (\<lambda>a b. \<guillemotleft>G\<guillemotright> b * wp body a b + \<guillemotleft>\<N> G\<guillemotright> b * (c * P b))" proof - fix P::"'s expect" and c::real assume cnz: "c \<noteq> 0" and nnc: "0 \<le> c" and sP: "sound P" with nnc have cpos: "0 < c" by(auto) hence nnic: "0 \<le> inverse c" by(auto) show "\<lambda>a. c * lfp_exp (\<lambda>a b. \<guillemotleft>G\<guillemotright> b * wp body a b + \<guillemotleft>\<N> G\<guillemotright> b * P b) a \<tturnstile>
              lfp_exp (\<lambda>a b. \<guillemotleft>G\<guillemotright> b * wp body a b + \<guillemotleft>\<N> G\<guillemotright> b * (c * P b))" proof(rule lfp_exp_greatest) fix Q::"'s expect" assume sQ: "sound Q"
             and fp: "\<lambda>b. \<guillemotleft>G\<guillemotright> b * wp body Q b + \<guillemotleft>\<N> G\<guillemotright> b * (c * P b) \<tturnstile> Q" hence "\<And>s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * (c * P s) \<le> Q s" by(auto) with nnic have "\<And>s. inverse c * (\<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * (c * P s)) \<le>
                     inverse c * Q s" by(auto intro:mult_left_mono) hence "\<And>s. \<guillemotleft>G\<guillemotright> s * (inverse c * wp body Q s) + (inverse c * c) * \<guillemotleft>\<N> G\<guillemotright> s * P s \<le>
                     inverse c * Q s" by(simp add:algebra_simps) hence "\<And>s. \<guillemotleft>G\<guillemotright> s * wp body (\<lambda>s. inverse c * Q s) s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le>
                     inverse c * Q s" by(simp add:cnz scalingD[OF healthy_scalingD, OF hb sQ nnic]) hence "\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (\<lambda>s. inverse c * Q s) s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<tturnstile>
                 \<lambda>s. inverse c * Q s" by(rule le_funI) moreover from nnic sQ have "sound (\<lambda>s. inverse c * Q s)" by(iprover intro:sound_intros) ultimately have "lfp_exp (\<lambda>a b. \<guillemotleft>G\<guillemotright> b * wp body a b + \<guillemotleft>\<N> G\<guillemotright> b * P b) \<tturnstile>
                           \<lambda>s. inverse c * Q s" by(rule lfp_exp_lowerbound) hence "\<And>s. lfp_exp (\<lambda>a b. \<guillemotleft>G\<guillemotright> b * wp body a b + \<guillemotleft>\<N> G\<guillemotright> b * P b) s \<le> inverse c * Q s" by(rule le_funD) with nnc have "\<And>s. c * lfp_exp (\<lambda>a b. \<guillemotleft>G\<guillemotright> b * wp body a b + \<guillemotleft>\<N> G\<guillemotright> b * P b) s \<le>
                     c * (inverse c * Q s)" by(auto intro:mult_left_mono) also from cnz have "\<And>s. ... s = Q s" by(simp) finally show "\<lambda>a. c * lfp_exp (\<lambda>a b. \<guillemotleft>G\<guillemotright> b * wp body a b + \<guillemotleft>\<N> G\<guillemotright> b * P b) a \<tturnstile> Q" by(rule le_funI) next from sP have "sound (\<lambda>s. bound_of P)" by(auto) with hb sP have "sound (lfp_exp (?X P))" by(blast intro:lfp_exp_sound lfp_loop_fp) with nnc show "sound (\<lambda>s. c * lfp_exp (?X P) s)" by(auto intro!:sound_intros) from hb sP nnc show "\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (\<lambda>s. bound_of (\<lambda>s. c * P s)) s +
                    \<guillemotleft>\<N> G\<guillemotright> s * (c * P s) \<tturnstile> \<lambda>s. bound_of (\<lambda>s. c * P s)" by(iprover intro:lfp_loop_fp sound_intros) from sP nnc show "sound (\<lambda>s. bound_of (\<lambda>s. c * P s))" by(auto intro!:sound_intros) qed qed assume nzc: "c \<noteq> 0" show ?thesis (is "?X P c s = ?Y P c s") proof(rule fun_cong[where x=s], rule antisym) from nzc nnc sP show "?X P c \<tturnstile> ?Y P c" by(rule onesided) from nzc have nzic: "inverse c \<noteq> 0" by(auto) moreover with nnc have nnic: "0 \<le> inverse c" by(auto) moreover from nnc sP have scP: "sound (\<lambda>s. c * P s)" by(auto intro!:sound_intros) ultimately have "?X (\<lambda>s. c * P s) (inverse c) \<tturnstile> ?Y (\<lambda>s. c * P s) (inverse c)" by(rule onesided) with nnc have "\<lambda>s. c * ?X (\<lambda>s. c * P s) (inverse c) s \<tturnstile>
                       \<lambda>s. c * ?Y (\<lambda>s. c * P s) (inverse c) s" by(blast intro:mult_left_mono) with nzc show "?Y P c \<tturnstile> ?X P c" by(simp add:mult.assoc[symmetric]) qed qed next fix P::"'s expect" and b::real assume bP: "bounded_by b P" and nP: "nneg P" show "lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) \<tturnstile> \<lambda>s. b" proof(intro lfp_exp_lowerbound le_funI) fix s::'s from bP nP hb have "bounded_by b (wp body (\<lambda>s. b))" by(auto) hence "wp body (\<lambda>s. b) s \<le> b" by(auto) moreover from bP have "P s \<le> b" by(auto) ultimately have "\<guillemotleft>G\<guillemotright> s * wp body (\<lambda>s. b) s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le> \<guillemotleft>G\<guillemotright> s * b + \<guillemotleft>\<N> G\<guillemotright> s * b" by(auto intro!:add_mono mult_left_mono) also have "... = b" by(simp add:negate_embed field_simps) finally show "\<guillemotleft>G\<guillemotright> s * wp body (\<lambda>s. b) s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le> b" . from bP nP have "0 \<le> b" by(auto) thus "sound (\<lambda>s. b)" by(auto) qed from hb bP nP show "\<lambda>s. 0 \<tturnstile> lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)" by(auto dest!:sound_nneg intro!:lfp_loop_greatest) next fix P Q::"'s expect" assume sP: "sound P" and sQ: "sound Q" and le: "P \<tturnstile> Q" show "lfp_exp (?X P) \<tturnstile> lfp_exp (?X Q)" proof(rule lfp_exp_greatest) fix R::"'s expect" assume sR: "sound R"
         and fp: "\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body R s + \<guillemotleft>\<N> G\<guillemotright> s * Q s \<tturnstile> R" from le have "\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body R s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<tturnstile>
                    \<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body R s + \<guillemotleft>\<N> G\<guillemotright> s * Q s" by(auto intro:le_funI add_left_mono mult_left_mono) also note fp finally show "lfp_exp (\<lambda>R s. \<guillemotleft>G\<guillemotright> s * wp body R s + \<guillemotleft>\<N> G\<guillemotright> s * P s) \<tturnstile> R" using sR by(auto intro:lfp_exp_lowerbound) next from hb sP show "sound (lfp_exp (\<lambda>R s. \<guillemotleft>G\<guillemotright> s * wp body R s + \<guillemotleft>\<N> G\<guillemotright> s * P s))" by(rule lfp_loop_sound) from hb sQ show "\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (\<lambda>s. bound_of Q) s +  \<guillemotleft>\<N> G\<guillemotright> s * Q s \<tturnstile> \<lambda>s. bound_of Q" by(rule lfp_loop_fp) from sQ show "sound (\<lambda>s. bound_of Q)" by(auto) qed qed qed text \<open>Use 'simp add:healthy\_intros' or 'blast intro:healthy\_intros' as
        appropriate to discharge healthiness side-contitions for primitive
        programs automatically.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma healthy_wp_loop:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
  shows "healthy (wp (do G \<longrightarrow> body od))"

proof -
  have "healthy (wp (do G \<longrightarrow> body od))"
  proof -
    have "healthy (wp body)" by assumption
    hence "healthy (wp (do G \<longrightarrow> body od))" by (rule healthy_wp_loop)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (556%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas healthy_intros =
  healthy_wp_Abort nearly_healthy_wlp_Abort healthy_wp_Skip   nearly_healthy_wlp_Skip
  healthy_wp_Seq   nearly_healthy_wlp_Seq   healthy_wp_PC     nearly_healthy_wlp_PC
  healthy_wp_DC    nearly_healthy_wlp_DC    healthy_wp_AC     nearly_healthy_wlp_AC
  healthy_wp_Embed nearly_healthy_wlp_Embed healthy_wp_Apply  nearly_healthy_wlp_Apply
  healthy_wp_SetDC nearly_healthy_wlp_SetDC healthy_wp_SetPC  nearly_healthy_wlp_SetPC
  healthy_wp_Bind  nearly_healthy_wlp_Bind  healthy_wp_repeat nearly_healthy_wlp_repeat
  healthy_wp_loop  nearly_healthy_wlp_loop</h2><br>
<b>Ground proof:</b> <br><pre><code>end</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule healthy_intros)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy"): command expected,
*** but back-quoted string `` (line 1128 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy") was found
*** At command "<malformed>" (line 1126 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Healthiness.thy")
Unfinished session(s): pGCL
0:00:06 elapsed time, 0:00:09 cpu time, factor 1.39
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (557%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_LoopInduction_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma wp_loop_step_mono_trans:
  fixes body::"'s prog"
  assumes sP: "sound P"
      and hb: "healthy (wp body)"
  shows "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro mono_transI le_funI, simp) fix Q R::"'s expect" and s::'s assume sQ: "sound Q" and sR: "sound R" and le: "Q \<tturnstile> R" hence "wp body Q \<tturnstile> wp body R" by(rule mono_transD[OF healthy_monoD, OF hb]) thus "\<guillemotleft>G\<guillemotright> s * wp body Q s \<le> \<guillemotleft>G\<guillemotright> s * wp body R s" by(auto dest:le_funD intro:mult_left_mono) qed text \<open>We can therefore apply the standard fixed-point lemmas to unfold it:\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume sP: "sound P"
  and hb: "healthy (wp body)"
  show "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
  proof -
    have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
    proof -
      have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
      proof -
        have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
        proof -
          have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
          proof -
            have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
            proof -
              have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
              proof -
                have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                proof -
                  have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                  proof -
                    have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                    proof -
                      have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                      proof -
                        have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                        proof -
                          have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                          proof -
                            have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                            proof -
                              have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                              proof -
                                have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                proof -
                                  have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                  proof -
                                    have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                    proof -
                                      have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                      proof -
                                        have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                        proof -
                                          have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                          proof -
                                            have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                            proof -
                                              have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                              proof -
                                                have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                                proof -
                                                  have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                                  proof -
                                                    have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                                    proof -
                                                      have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                                      proof -
                                                        have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                                        proof -
                                                          have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)"
                                                          proof -
                                                            have "mono_trans (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.93
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (558%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_wp_loop_unfold:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
      and sP: "sound P"
  shows "lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) =
         (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)) s +
              \<guillemotleft>\<N> G\<guillemotright> s * P s)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule lfp_exp_unfold) from assms show "mono_trans (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)" by(blast intro:wp_loop_step_mono_trans) from assms show "\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (\<lambda>s. bound_of P) s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<tturnstile> \<lambda>s. bound_of P" by(blast intro:lfp_loop_fp) from sP show "sound (\<lambda>s. bound_of P)" by(auto) fix Q::"'s expect" assume "sound Q" with assms show "sound (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)" by(intro wp_loop_step_sound[unfolded wp_eval, simplified, folded negate_embed], auto) qed</code></pre>
<b>Generated proof:</b><pre><code><proof>

Proof.

1. Assume hb: "healthy (wp body)" and sP: "sound P".
2. By the definition of lfp_exp, we have:
   lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) =
   (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)) s +
   \<guillemotleft>\<N> G\<guillemotright> s * P s)

3. By the definition of lfp_exp, we have:
   lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) =
   (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)) s +
   \<guillemotleft>\<N> G\<guillemotright> s * P s)

4. By the definition of lfp_exp, we have:
   lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) =
   (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)) s +
   \<guillemotleft>\<N> G\<guillemotright> s * P s)

5. By the definition of lfp_exp, we have:
   lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) =
   (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)) s +
   \<guillemotleft>\<N> G\<guillemotright> s * P s)

6. By the definition of lfp_exp, we have:
   lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) =
   (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)) s +
   \<guillemotleft>\<N> G\<guillemotright> s * P s)

7. By the definition of lfp_exp, we have:
   lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) =
   (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)) s +
   \<guillemotleft>\<N> G\<guillemotright> s * P s)

8. By the definition of lfp_exp, we have:
   lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) =
   (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)) s +
   \<guillemotleft>\<N> G\<guillemotright> s * P s)

9. By the definition of lfp_exp, we have:
   lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) =
   (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)) s +
   \<guillemotleft>\<N> G\<guillemotright> s * P s)

10. By the definition of lfp_exp, we have:
    lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) =
    (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)) s +
    \<guillemotleft>\<N> G\<guillemotright> s * P s)

11. By the definition of lfp_exp, we have:
    lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) =
    (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)) s +
    \<guillemotleft>\<N> G\<guillemotright> s * P s)

12. By the definition of lfp_exp, we have:
    lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s) =
    (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s *</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy"): command expected,
*** but keyword < (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy") was found
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (559%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_loop_step_unitary:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
      and uP: "unitary P" and uQ: "unitary Q"
  shows "unitary (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(intro unitaryI2 nnegI bounded_byI) fix s::'s from uQ hb have uwQ: "unitary (wp body Q)" by(auto) with uP have "0 \<le> wp body Q s" "0 \<le> P s" by(auto) thus "0 \<le> \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s" by(auto intro:add_nonneg_nonneg mult_nonneg_nonneg) from uP uwQ have "wp body Q s \<le> 1" "P s \<le> 1" by(auto) hence "\<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le> \<guillemotleft>G\<guillemotright> s * 1 + \<guillemotleft>\<N> G\<guillemotright> s * 1" by(blast intro:add_mono mult_left_mono) also have "... = 1" by(simp add:negate_embed) finally show "\<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le> 1" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume hb: "healthy (wp body)"
  and uP: "unitary P" and uQ: "unitary Q"
  then have "unitary (\<lambda>s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s)"
  using hb uP uQ by (simp add: unitary_def)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy"): command expected,
*** but back-quoted string `` (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy") was found
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.82
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (560%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_loop_unitary:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
      and uP: "unitary P"
  shows "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"</h2><br>
<b>Ground proof:</b> <br><pre><code>using assms by(blast intro:lfp_exp_unitary wp_loop_step_unitary) text \<open>From the lattice structure on transformers, we establish a transfinite induction
  principle for loops.  We use this to show a number of properties, particularly
  subdistributivity, for loops.  This proof follows the pattern of lemma lfp\_ordinal\_induct
  in HOL/Inductive.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume hb: "healthy (wp body)"
  and uP: "unitary P"
  show "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
  proof -
    have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
    proof -
      have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
      proof -
        have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
        proof -
          have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
          proof -
            have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
            proof -
              have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
              proof -
                have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                proof -
                  have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                  proof -
                    have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                    proof -
                      have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                      proof -
                        have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                        proof -
                          have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                          proof -
                            have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                            proof -
                              have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                              proof -
                                have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                proof -
                                  have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                  proof -
                                    have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                    proof -
                                      have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                      proof -
                                        have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                        proof -
                                          have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                          proof -
                                            have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                            proof -
                                              have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                              proof -
                                                have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                                proof -
                                                  have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                                  proof -
                                                    have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                                    proof -
                                                      have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                                      proof -
                                                        have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s * wp body Q s + \<guillemotleft>\<N> G\<guillemotright> s * P s))"
                                                        proof -
                                                          have "unitary (lfp_exp (\<lambda>Q s. \<guillemotleft>G\<guillemotright> s</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.83
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (561%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_induct:
  fixes body::"'s prog"
  assumes hwp:  "healthy (wp body)"
      and hwlp: "nearly_healthy (wlp body)"
      \<comment> \<open>The body must be healthy, both in strict and liberal semantics.\<close>
      and Limit:   "\<And>S. \<lbrakk> \<forall>x\<in>S. P (fst x) (snd x); \<forall>x\<in>S. feasible (fst x);
                          \<forall>x\<in>S. \<forall>Q. unitary Q \<longrightarrow> unitary (snd x Q) \<rbrakk> \<Longrightarrow>
                    P (Sup_trans (fst ` S)) (Inf_utrans (snd ` S))"
      \<comment> \<open>The property holds at limit points.\<close>
      and IH:   "\<And>t u. \<lbrakk> P t u; feasible t; \<And>Q. unitary Q \<Longrightarrow> unitary (u Q)  \<rbrakk> \<Longrightarrow>
                        P (wp  (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))
                          (wlp (body ;; Embed u \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))"
      \<comment> \<open>The inductive step.  The property is preserved by a single loop iteration.\<close>
      and P_equiv: "\<And>t t' u u'. \<lbrakk> P t u; equiv_trans t t'; equiv_utrans u u' \<rbrakk> \<Longrightarrow> P t' u'"
      \<comment> \<open>The property must be preserved by equivalence\<close>
  shows "P (wp (do G \<longrightarrow> body od)) (wlp (do G \<longrightarrow> body od))"
  \<comment> \<open>The property can refer to both interpretations simultaneously.  The unifier will happily
  apply the rule to just one or the other, however.\<close></h2><br>
<b>Ground proof:</b> <br><pre><code>proof(simp add:wp_eval) let "?X t" = "wp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)" let "?Y t" = "wlp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)" let ?M = "{x. P (fst x) (snd x) \<and>
                feasible (fst x) \<and>
                (\<forall>Q. unitary Q \<longrightarrow> unitary (snd x Q)) \<and>
                le_trans (fst x) (lfp_trans ?X) \<and>
                le_utrans (gfp_trans ?Y) (snd x)}" have fSup: "feasible (Sup_trans (fst ` ?M))" proof(intro feasibleI bounded_byI2 nnegI2) fix Q::"'s expect" and b::real assume nQ: "nneg Q" and bQ: "bounded_by b Q" show "Sup_trans (fst ` ?M) Q \<tturnstile> \<lambda>s. b" unfolding Sup_trans_def using nQ bQ by(auto intro!:Sup_exp_least) show "\<lambda>s. 0 \<tturnstile> Sup_trans (fst ` ?M) Q" proof(cases) assume empty: "?M = {}" show ?thesis by(simp add:Sup_trans_def Sup_exp_def empty) next assume ne: "?M \<noteq> {}" then obtain x where xin: "x \<in> ?M" by auto hence ffx: "feasible (fst x)" by(simp) with nQ bQ have "\<lambda>s. 0 \<tturnstile> fst x Q" by(auto) also from xin have "fst x Q \<tturnstile> Sup_trans (fst ` ?M) Q" apply(intro Sup_trans_upper2[OF imageI _ nQ bQ], assumption) apply(clarsimp, blast intro: sound_nneg[OF feasible_sound] feasible_boundedD) done finally show "\<lambda>s. 0 \<tturnstile> Sup_trans (fst ` ?M) Q" . qed qed have uInf: "\<And>P. unitary P \<Longrightarrow> unitary (Inf_utrans (snd ` ?M) P)" proof(cases "?M = {}") fix P assume empty: "?M = {}" show "?thesis P" by(simp only:empty, simp add:Inf_utrans_def) next fix P::"'s expect" assume uP: "unitary P"
       and ne: "?M \<noteq> {}" show "?thesis P" proof(intro unitaryI2 nnegI2 bounded_byI2) from ne obtain x where xin: "x \<in> ?M" by auto hence sxin: "snd x \<in> snd ` ?M" by(simp) hence "le_utrans (Inf_utrans (snd ` ?M)) (snd x)" by(intro Inf_utrans_lower, auto) with uP have "Inf_utrans (snd ` ?M) P \<tturnstile> snd x P" by(auto) also { from xin uP have "unitary (snd x P)" by(simp) hence "snd x P \<tturnstile> \<lambda>s. 1" by(auto) } finally show "Inf_utrans (snd ` ?M) P \<tturnstile> \<lambda>s. 1" . have "\<lambda>s. 0 \<tturnstile> Inf_trans (snd ` ?M) P" unfolding Inf_trans_def proof(rule Inf_exp_greatest) from sxin show "{t P |t. t \<in> snd ` ?M} \<noteq> {}" by(auto) show "\<forall>P\<in>{t P |t. t \<in> snd ` ?M}. \<lambda>s. 0 \<tturnstile> P" proof(clarsimp) fix t::"'s trans" assume "\<forall>Q. unitary Q \<longrightarrow> unitary (t Q)" with uP have "unitary (t P)" by(auto) thus "\<lambda>s. 0 \<tturnstile> t P" by(auto) qed qed also { from ne have X: "(snd ` ?M = {}) = False" by(simp) have "Inf_trans (snd ` ?M) P = Inf_utrans (snd ` ?M) P" unfolding Inf_utrans_def by(subst X, simp) } finally show "\<lambda>s. 0 \<tturnstile> Inf_utrans (snd ` ?M) P" . qed qed have wp_loop_mono: "\<And>t u. \<lbrakk> le_trans t u; \<And>P. sound P \<Longrightarrow> sound (t P);
                               \<And>P. sound P \<Longrightarrow> sound (u P) \<rbrakk> \<Longrightarrow> le_trans (?X t) (?X u)" proof(intro le_transI le_funI, simp add:wp_eval) fix t u::"'s trans" and P::"'s expect" and s::'s assume le: "le_trans t u"
       and st: "\<And>P. sound P \<Longrightarrow> sound (t P)"
       and su: "\<And>P. sound P \<Longrightarrow> sound (u P)"
       and sP: "sound P" hence "sound (t P)" "sound (u P)" by(auto) with healthy_monoD[OF hwp] le sP have "wp body (t P) \<tturnstile> wp body (u P)" by(auto) hence "wp body (t P) s \<le> wp body (u P) s" by(auto) thus "\<guillemotleft>G\<guillemotright> s * wp body (t P) s \<le> \<guillemotleft>G\<guillemotright> s * wp body (u P) s" by(auto intro:mult_left_mono) qed have wlp_loop_mono: "\<And>t u. \<lbrakk> le_utrans t u; \<And>P. unitary P \<Longrightarrow> unitary (t P);
                               \<And>P. unitary P \<Longrightarrow> unitary (u P) \<rbrakk> \<Longrightarrow> le_utrans (?Y t) (?Y u)" proof(intro le_utransI le_funI, simp add:wp_eval) fix t u::"'s trans" and P::"'s expect" and s::'s assume le: "le_utrans t u"
       and ut: "\<And>P. unitary P \<Longrightarrow> unitary (t P)"
       and uu: "\<And>P. unitary P \<Longrightarrow> unitary (u P)"
       and uP: "unitary P" hence "unitary (t P)" "unitary (u P)" by(auto) with le uP have "wlp body (t P) \<tturnstile> wlp body (u P)" by(auto intro:nearly_healthy_monoD[OF hwlp]) hence "wlp body (t P) s \<le> wlp body (u P) s" by(auto) thus "\<guillemotleft>G\<guillemotright> s * wlp body (t P) s \<le> \<guillemotleft>G\<guillemotright> s * wlp body (u P) s" by(auto intro:mult_left_mono) qed from hwp have hX: "\<And>t. healthy t \<Longrightarrow> healthy (?X t)" by(auto intro:healthy_intros) from hwlp have hY: "\<And>t. nearly_healthy t \<Longrightarrow> nearly_healthy (?Y t)" by(auto intro!:healthy_intros) have PLimit: "P (Sup_trans (fst ` ?M)) (Inf_utrans (snd ` ?M))" by(auto intro:Limit) have feasible_lfp_loop:
    "feasible (lfp_trans ?X)" proof(intro feasibleI bounded_byI2 nnegI2,
        simp_all add:wp_Loop1[simplified wp_eval] soundI2 hwp) fix P::"'s expect" and b::real assume bP: "bounded_by b P" and nP: "nneg P" hence sP: "sound P" by(auto) show "lfp_exp (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s) \<tturnstile> \<lambda>s. b" proof(intro lfp_exp_lowerbound le_funI) fix s::'s from bP nP have nnb: "0 \<le> b" by(auto) hence "sound (\<lambda>s. b)" "bounded_by b (\<lambda>s. b)" by(auto) with hwp have "bounded_by b (wp body (\<lambda>s. b))" by(auto) with bP have "wp body (\<lambda>s. b) s \<le> b" "P s \<le> b" by(auto) hence "\<guillemotleft>G\<guillemotright> s * wp body (\<lambda>s. b) s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le> \<guillemotleft>G\<guillemotright> s * b + \<guillemotleft>\<N> G\<guillemotright> s * b" by(auto intro:add_mono mult_left_mono) thus "\<guillemotleft>G\<guillemotright> s * wp body (\<lambda>s. b) s + \<guillemotleft>\<N> G\<guillemotright> s * P s \<le> b" by(simp add:negate_embed algebra_simps) from nnb show "sound (\<lambda>s. b)" by(auto) qed from hwp sP show "\<lambda>s. 0 \<tturnstile> lfp_exp (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)" by(blast intro!:lfp_exp_greatest lfp_loop_fp) qed have unitary_gfp:
    "\<And>P. unitary P \<Longrightarrow> unitary (gfp_trans ?Y P)" proof(intro unitaryI2 nnegI2 bounded_byI2,
      simp_all add:wlp_Loop1[simplified wp_eval] hwlp) fix P::"'s expect" assume uP: "unitary P" show "\<lambda>s. 0 \<tturnstile> gfp_exp (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wlp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s)" proof(rule gfp_exp_upperbound[OF le_funI]) fix s::"'s" from hwlp uP have "0 \<le> wlp body (\<lambda>s. 0) s" "0 \<le> P s" by(auto dest!:unitary_sound) thus "0 \<le> \<guillemotleft>G\<guillemotright> s * wlp body (\<lambda>s. 0) s + \<guillemotleft>\<N> G\<guillemotright> s * P s" by(auto intro:add_nonneg_nonneg mult_nonneg_nonneg) show "unitary (\<lambda>s. 0)" by(auto) qed show "gfp_exp (\<lambda>Q s. \<guillemotleft> G \<guillemotright> s * wlp body Q s + \<guillemotleft> \<N> G \<guillemotright> s * P s) \<tturnstile> \<lambda>s. 1" by(auto intro:gfp_exp_least) qed have fX:
    "\<And>t. feasible t \<Longrightarrow> feasible (?X t)" proof(intro feasibleI nnegI bounded_byI, simp_all add:wp_eval) fix t::"'s trans" and Q::"'s expect" and b::real and s::'s assume ft: "feasible t" and bQ: "bounded_by b Q" and nQ: "nneg Q" hence "nneg (t Q)" "bounded_by b (t Q)" by(auto) moreover hence stQ: "sound (t Q)" by(auto) ultimately have "wp body (t Q) s \<le> b" using hwp by(auto) moreover from bQ have "Q s \<le> b" by(auto) ultimately have "\<guillemotleft>G\<guillemotright> s * wp body (t Q) s + (1 - \<guillemotleft>G\<guillemotright> s) * Q s \<le>
                     \<guillemotleft>G\<guillemotright> s * b + (1 - \<guillemotleft> G \<guillemotright> s) * b" by(auto intro:add_mono mult_left_mono) thus "\<guillemotleft>G\<guillemotright> s * wp body (t Q) s + (1 - \<guillemotleft>G\<guillemotright> s) * Q s \<le> b" by(simp add:algebra_simps) from nQ stQ hwp have "0 \<le> wp body (t Q) s" "0 \<le> Q s" by(auto) thus "0 \<le> \<guillemotleft>G\<guillemotright> s * wp body (t Q) s + (1 - \<guillemotleft>G\<guillemotright> s) * Q s" by(auto intro:add_nonneg_nonneg mult_nonneg_nonneg) qed have uY:
    "\<And>t P. (\<And>P. unitary P \<Longrightarrow> unitary (t P)) \<Longrightarrow> unitary P \<Longrightarrow> unitary (?Y t P)" proof(intro unitaryI2 nnegI bounded_byI, simp_all add:wp_eval) fix t::"'s trans" and P::"'s expect" and s::'s assume ut: "\<And>P. unitary P \<Longrightarrow> unitary (t P)"
       and uP: "unitary P" hence utP: "unitary (t P)" by(auto) with hwlp have ubtP: "unitary (wlp body (t P))" by(auto) with uP have "0 \<le> P s" "0 \<le> wlp body (t P) s" by(auto) thus "0 \<le> \<guillemotleft>G\<guillemotright> s * wlp body (t P) s + (1-\<guillemotleft>G\<guillemotright> s) * P s" by(auto intro:add_nonneg_nonneg mult_nonneg_nonneg) from uP ubtP have "P s \<le> 1" "wlp body (t P) s \<le> 1" by(auto) hence "\<guillemotleft>G\<guillemotright> s * wlp body (t P) s + (1-\<guillemotleft>G\<guillemotright> s) * P s \<le> \<guillemotleft>G\<guillemotright> s * 1 + (1-\<guillemotleft>G\<guillemotright> s) * 1" by(blast intro:add_mono mult_left_mono) also have "... = 1" by(simp add:algebra_simps) finally show "\<guillemotleft>G\<guillemotright> s * wlp body (t P) s + (1-\<guillemotleft>G\<guillemotright> s) * P s \<le> 1" . qed have fw_lfp: "le_trans (Sup_trans (fst ` ?M)) (lfp_trans ?X)" using feasible_nnegD[OF feasible_lfp_loop] by(intro le_transI[OF Sup_trans_least2], blast+) hence "le_trans (?X (Sup_trans (fst ` ?M))) (?X (lfp_trans ?X))" by(auto intro:wp_loop_mono feasible_sound[OF fSup]
                  feasible_sound[OF feasible_lfp_loop]) also have "equiv_trans ... (lfp_trans ?X)" proof(rule iffD1[OF equiv_trans_comm, OF lfp_trans_unfold], iprover intro:wp_loop_mono) fix t::"'s trans" and P::"'s expect" assume st: "\<And>Q. sound Q \<Longrightarrow> sound (t Q)"
       and sP: "sound P" show "sound (?X t P)" proof(intro soundI2 bounded_byI nnegI, simp_all add:wp_eval) fix s::'s from sP st hwp have "0 \<le> P s" "0 \<le> wp body (t P) s" by(auto) thus "0 \<le> \<guillemotleft>G\<guillemotright> s * wp body (t P) s + (1 - \<guillemotleft>G\<guillemotright> s) * P s" by(blast intro:add_nonneg_nonneg mult_nonneg_nonneg) from sP st have "bounded_by (bound_of (t P)) (t P)" by(auto) with sP st hwp have "bounded_by (bound_of (t P)) (wp body (t P))" by(auto) hence "wp body (t P) s \<le> bound_of (t P)" by(auto) moreover from sP st hwp have "P s \<le> bound_of P" by(auto) moreover have "\<guillemotleft>G\<guillemotright> s \<le> 1" "1 - \<guillemotleft>G\<guillemotright> s \<le> 1" by(auto) moreover from sP st hwp have "0 \<le> wp body (t P) s" "0 \<le> P s" by(auto) moreover have "(0::real) \<le> 1" by(simp) ultimately show "\<guillemotleft>G\<guillemotright> s * wp body (t P) s + (1 - \<guillemotleft>G\<guillemotright> s) * P s \<le>
                       1 * bound_of (t P) + 1 * bound_of P" by(blast intro:add_mono mult_mono) qed next let "?fp" = "\<lambda>R s. bound_of R" show "le_trans (?X ?fp) ?fp" by(auto intro:healthy_intros hwp) fix P::"'s expect" assume "sound P" thus "sound (?fp P)" by(auto) qed finally have le_lfp: "le_trans (?X (Sup_trans (fst ` ?M))) (lfp_trans ?X)" . have fw_gfp: "le_utrans (gfp_trans ?Y) (Inf_utrans (snd ` ?M))" by(auto intro:Inf_utrans_greatest unitary_gfp) have "equiv_utrans (gfp_trans ?Y) (?Y (gfp_trans ?Y))" by(auto intro!:gfp_trans_unfold wlp_loop_mono uY) also from fw_gfp have "le_utrans (?Y (gfp_trans ?Y)) (?Y (Inf_utrans (snd ` ?M)))" by(auto intro:wlp_loop_mono uInf unitary_gfp) finally have ge_gfp: "le_utrans (gfp_trans ?Y) (?Y (Inf_utrans (snd ` ?M)))" . from PLimit fX uY fSup uInf have "P (?X (Sup_trans (fst ` ?M))) (?Y (Inf_utrans (snd ` ?M)))" by(iprover intro:IH) moreover from fSup have "feasible (?X (Sup_trans (fst ` ?M)))" by(rule fX) moreover have "\<And>P. unitary P \<Longrightarrow> unitary (?Y (Inf_utrans (snd ` ?M)) P)" by(auto intro:uY uInf) moreover note le_lfp ge_gfp ultimately have pair_in: "(?X (Sup_trans (fst ` ?M)), ?Y (Inf_utrans (snd ` ?M))) \<in> ?M" by(simp) have "?X (Sup_trans (fst ` ?M)) \<in> fst ` ?M" by(rule imageI[OF pair_in, of fst, simplified]) hence "le_trans (?X (Sup_trans (fst ` ?M))) (Sup_trans (fst ` ?M))" proof(rule le_transI[OF Sup_trans_upper2[where t="?X (Sup_trans (fst ` ?M))"
                                             and S="fst ` ?M"]]) fix P::"'s expect" assume sP: "sound P" thus "nneg P" by(auto) from sP show "bounded_by (bound_of P) P" by(auto) from sP show "\<forall>u\<in>fst ` ?M. \<forall>Q. nneg Q \<and> bounded_by (bound_of P) Q \<longrightarrow>
                                   nneg (u Q) \<and> bounded_by (bound_of P) (u Q)" by(auto) qed hence "le_trans (lfp_trans ?X) (Sup_trans (fst ` ?M))" by(auto intro:lfp_trans_lowerbound feasible_sound[OF fSup]) with fw_lfp have eqt: "equiv_trans (Sup_trans (fst ` ?M)) (lfp_trans ?X)" by(rule le_trans_antisym) have "?Y (Inf_utrans (snd ` ?M)) \<in> snd ` ?M" by(rule imageI[OF pair_in, of snd, simplified]) hence "le_utrans (Inf_utrans (snd ` ?M)) (?Y (Inf_utrans (snd ` ?M)))" by(intro Inf_utrans_lower, auto) hence "le_utrans (Inf_utrans (snd ` ?M)) (gfp_trans ?Y)" by(blast intro:gfp_trans_upperbound uInf) with fw_gfp have equ: "equiv_utrans (Inf_utrans (snd ` ?M)) (gfp_trans ?Y)" by(auto intro:le_utrans_antisym) from PLimit eqt equ show "P (lfp_trans ?X) (gfp_trans ?Y)" by(rule P_equiv) qed subsection \<open>The Limit of Iterates\<close> text \<open>The iterates of a loop are its sequence of finite unrollings.  We show shortly that this
converges on the least fixed point.  This is enormously useful, as we can appeal to various
properties of the finite iterates (which will follow by finite induction), which we can then
transfer to the limit.\<close> definition iterates :: "'s prog \<Rightarrow> ('s \<Rightarrow> bool) \<Rightarrow> nat \<Rightarrow> 's trans"
where "iterates body G i = ((\<lambda>x. wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) ^^ i) (\<lambda>P s. 0)"</code></pre>
<b>Generated proof:</b><pre><code>proof -
  have "P (wp (do G \<longrightarrow> body od)) (wlp (do G \<longrightarrow> body od))"
  using Limit IH P_equiv
  by (induct_tac "P (wp (do G \<longrightarrow> body od)) (wlp (do G \<longrightarrow> body od))")
qed</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy"): missing theory context for command "proof"
*** At command "<malformed>" (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.85
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (562%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma iterates_0[simp]:
  "iterates body G 0 = (\<lambda>P s. 0)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:iterates_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
by (simp add: iterates_0)
QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy"): command expected,
*** but identifier Proof (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy") was found
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.91
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (563%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma iterates_Suc[simp]:
  "iterates body G (Suc i) = wp (body ;; Embed (iterates body G i) \<^bsub>\<guillemotleft>G\<guillemotright>\<^esub>\<oplus> Skip)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(simp add:iterates_def) text \<open>All iterates are healthy.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule wp.simp)
  apply (rule</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy"): command expected,
*** but identifier Proof (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy") was found
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.85
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (564%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma iterates_healthy:
  "healthy (wp body) \<Longrightarrow> healthy (iterates body G i)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by(induct i, auto intro:healthy_intros) text \<open>The iterates are an ascending chain.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma iterates_healthy:
  "healthy (wp body) \<Longrightarrow> healthy (iterates body G i)"
proof
  assume "healthy (wp body)"
  then have "healthy (wp body) \<Longrightarrow> healthy (body G i)" by (simp add: wp_healthy)
  hence "healthy (iterates body G i)" by (simp add: iterates_healthy)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy"): command expected,
*** but back-quoted string `` (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy") was found
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (565%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma iterates_increasing:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
  shows "le_trans (iterates body G i) (iterates body G (Suc i))"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(induct i) show "le_trans (iterates body G 0) (iterates body G (Suc 0))" proof(simp add:iterates_def, rule le_transI) fix P::"'s expect" assume "sound P" with hb have "sound (wp (body ;; Embed (\<lambda>P s. 0) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) P)" by(auto intro!:wp_loop_step_sound) thus "\<lambda>s. 0 \<tturnstile> wp (body ;; Embed (\<lambda>P s. 0) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) P" by(auto) qed fix i assume IH: "le_trans (iterates body G i) (iterates body G (Suc i))" have "equiv_trans (iterates body G (Suc i))
                    (wp (body ;; Embed (iterates body G i) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))" by(simp) also from iterates_healthy[OF hb] have "le_trans ... (wp (body ;; Embed (iterates body G (Suc i)) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))" by(blast intro:wp_loop_step_mono[OF hb IH]) also have "equiv_trans ... (iterates body G (Suc (Suc i)))" by(simp) finally show "le_trans (iterates body G (Suc i)) (iterates body G (Suc (Suc i)))" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma iterates_increasing:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
  shows "le_trans (iterates body G i) (iterates body G (Suc i))"

proof -
  from hb have "healthy (wp body)" by assumption
  then have "le_trans (iterates body G i) (iterates body G (Suc i))" by (rule iterates_increasing)
  qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy"): command expected,
*** but back-quoted string `` (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy") was found
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.85
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (566%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma wp_loop_step_bounded:
  fixes t::"'s trans" and Q::"'s expect"
  assumes nQ: "nneg Q"
      and bQ: "bounded_by b Q"
      and ht: "healthy t"
      and hb: "healthy (wp body)"
  shows "bounded_by b (wp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) Q)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule bounded_byI, simp add:wp_eval) fix s::'s from nQ bQ have sQ: "sound Q" by(auto) with bQ ht have "sound (t Q)" "bounded_by b (t Q)" by(auto) with hb have "bounded_by b (wp body (t Q))" by(auto) with bQ have "wp body (t Q) s \<le> b" "Q s \<le> b" by(auto) hence "\<guillemotleft>G\<guillemotright> s * wp body (t Q) s + (1-\<guillemotleft>G\<guillemotright> s) * Q s \<le>
         \<guillemotleft>G\<guillemotright> s * b + (1-\<guillemotleft>G\<guillemotright> s) * b" by(auto intro:add_mono mult_left_mono) also have "... = b" by(simp add:algebra_simps) finally show "\<guillemotleft>G\<guillemotright> s * wp body (t Q) s + (1-\<guillemotleft>G\<guillemotright> s) * Q s \<le> b" . qed text \<open>This is the key result: The loop is equivalent to the supremum of its iterates.  This
proof follows the pattern of lemma continuous\_lfp in HOL/Library/Continuity.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "bounded_by b (wp (body ;; Embed t \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) Q)"
  using nQ bQ ht hb
  by (rule wp_loop_step_bounded)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy"): command expected,
*** but back-quoted string `` (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy") was found
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.84
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (567%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma lfp_iterates:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
      and cb: "bd_cts (wp body)"
  shows "equiv_trans (wp (do G \<longrightarrow> body od)) (Sup_trans (range (iterates body G)))"
        (is "equiv_trans ?X ?Y")</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule le_trans_antisym) let ?F = "\<lambda>x. wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)" let ?bot = "\<lambda>(P::'s \<Rightarrow> real) s::'s. 0::real" have HF: "\<And>i. healthy ((?F ^^ i) ?bot)" proof - fix i from hb show "(?thesis i)" by(induct i, simp_all add:healthy_intros) qed from iterates_healthy[OF hb] have "\<And>i. feasible (iterates body G i)" by(auto) hence fSup: "feasible (Sup_trans (range (iterates body G)))" by(auto intro:feasible_Sup_trans) { fix i have "le_trans ((?F ^^ i) ?bot) ?X" proof(induct i) show "le_trans ((?F ^^ 0) ?bot) ?X" proof(simp, intro le_transI) fix P::"'s expect" assume "sound P" with hb healthy_wp_loop have "sound (wp (\<mu> x. body ;; x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) P)" by(auto) thus "\<lambda>s. 0 \<tturnstile> wp (\<mu> x. body ;; x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) P" by(auto) qed fix i assume IH: "le_trans ((?F ^^ i) ?bot) ?X" have "equiv_trans ((?F ^^ (Suc i)) ?bot) (?F ((?F ^^ i) ?bot))" by(simp) also have "le_trans ... (?F ?X)" proof(rule wp_loop_step_mono[OF hb IH]) fix P::"'s expect" assume sP: "sound P" with hb healthy_wp_loop show "sound (wp (\<mu> x. body ;; x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) P)" by(auto) from sP show "sound ((?F ^^ i) ?bot P)" by(rule healthy_sound[OF HF]) qed also { from hb have X: "le_trans (wp (body ;; Embed (\<lambda>P s. bound_of P) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))
                                 (\<lambda>P s. bound_of P)" by(intro le_transI, simp add:wp_eval, auto intro: lfp_loop_fp[unfolded negate_embed]) have "equiv_trans (?F ?X) ?X" apply (simp only: wp_eval) by(intro iffD1[OF equiv_trans_comm, OF lfp_trans_unfold]
                 wp_loop_step_mono[OF hb] wp_loop_step_sound[OF hb], (blast|rule X)+) } finally show "le_trans ((?F ^^ (Suc i)) ?bot) ?X" . qed } hence "\<And>i. le_trans (iterates body G i) (wp do G \<longrightarrow> body od)" by(simp add:iterates_def) thus "le_trans ?Y ?X" by(auto intro!:le_transI[OF Sup_trans_least2] sound_nneg
                   healthy_sound[OF iterates_healthy, OF hb]
                   healthy_bounded_byD[OF iterates_healthy, OF hb]
                   healthy_sound[OF healthy_wp_loop] hb) show "le_trans ?X ?Y" proof(simp only: wp_eval, rule lfp_trans_lowerbound) from hb cb have "bd_cts_tr ?F" by(rule cts_wp_loopstep) with iterates_increasing[OF hb] iterates_healthy[OF hb] have "equiv_trans (?F ?Y) (Sup_trans (range (?F o (iterates body G))))" by (auto intro!: healthy_feasibleD bd_cts_trD cong del: image_cong_simp) also have "le_trans (Sup_trans (range (?F o (iterates body G)))) ?Y" proof(rule le_transI) fix P::"'s expect" assume sP: "sound P" show "(Sup_trans (range (?F o (iterates body G)))) P \<tturnstile> ?Y P" proof(rule Sup_trans_least2, clarsimp) show "\<forall>u\<in>range ((\<lambda>x. wp (body ;; Embed x \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip)) \<circ> iterates body G).
              \<forall>R. nneg R \<and> bounded_by (bound_of P) R \<longrightarrow>
                  nneg (u R) \<and> bounded_by (bound_of P) (u R)" proof(clarsimp, intro conjI) fix Q::"'s expect" and i assume nQ: "nneg Q" and bQ: "bounded_by (bound_of P) Q" hence "sound Q" by(auto) moreover from iterates_healthy[OF hb] have "\<And>P. sound P \<Longrightarrow> sound (iterates body G i P)" by(auto) moreover note hb ultimately have "sound (wp (body ;; Embed (iterates body G i) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) Q)" by(iprover intro:wp_loop_step_sound) thus "nneg (wp (body ;; Embed (iterates body G i) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) Q)" by(auto) from nQ bQ iterates_healthy[OF hb] hb show "bounded_by (bound_of P) (wp (body ;; Embed (iterates body G i) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) Q)" by(rule wp_loop_step_bounded) qed from sP show "nneg P" "bounded_by (bound_of P) P" by(auto) next fix Q::"'s expect" assume nQ: "nneg Q" and bQ: "bounded_by (bound_of P) Q" hence "sound Q" by(auto) with fSup have "sound (Sup_trans (range (iterates body G)) Q)" by(auto) thus "nneg (Sup_trans (range (iterates body G)) Q)" by(auto) fix i show "wp (body ;; Embed (iterates body G i) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) Q \<tturnstile>
              Sup_trans (range (iterates body G)) Q" proof(rule Sup_trans_upper2[OF _ _ nQ bQ]) from iterates_healthy[OF hb] show "\<forall>u\<in>range (iterates body G).
                \<forall>R. nneg R \<and> bounded_by (bound_of P) R \<longrightarrow>
                     nneg (u R) \<and> bounded_by (bound_of P) (u R)" by(auto) have "wp (body ;; Embed (iterates body G i) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) = iterates body G (Suc i)" by(simp) also have "... \<in> range (iterates body G)" by(blast) finally show "wp (body ;; Embed (iterates body G i) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip) \<in>
                        range (iterates body G)" . qed qed qed finally show "le_trans (?F ?Y) ?Y" . fix P::"'s expect" assume "sound P" with fSup show "sound (?Y P)" by(auto) qed qed text \<open>Therefore, evaluated at a given point (state), the sequence of iterates gives a sequence
of real values that converges on that of the loop itself.\<close> corollary loop_iterates:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
      and cb: "bd_cts (wp body)"
      and sP: "sound P"
  shows "(\<lambda>i. iterates body G i P s) \<longlonglongrightarrow> wp (do G \<longrightarrow> body od) P s" proof - let ?X = "{f s |f. f \<in> {t P |t. t \<in> range (iterates body G)}}" have closure_Sup: "Sup ?X \<in> closure ?X" proof(rule closure_contains_Sup, simp, clarsimp) fix i from sP have "bounded_by (bound_of P) P" by(auto) with iterates_healthy[OF hb] sP have "\<And>j. bounded_by (bound_of P) (iterates body G j P)" by(auto) thus "iterates body G i P s \<le> bound_of P" by(auto) qed have "(\<lambda>i. iterates body G i P s) \<longlonglongrightarrow> Sup {f s |f. f \<in> {t P |t. t \<in> range (iterates body G)}}" proof(rule LIMSEQ_I) fix r::real assume posr: "0 < r" with closure_Sup obtain y where yin: "y \<in> ?X" and ey: "dist y (Sup ?X) < r" by(simp only:closure_approachable, blast) from yin obtain i where yit: "y = iterates body G i P s" by(auto) { fix j have "i \<le> j \<longrightarrow> le_trans (iterates body G i) (iterates body G j)" proof(induct j, simp, clarify) fix k assume IH: "i \<le> k \<longrightarrow> le_trans (iterates body G i) (iterates body G k)"
           and le: "i \<le> Suc k" show "le_trans (iterates body G i) (iterates body G (Suc k))" proof(cases "i = Suc k", simp) assume "i \<noteq> Suc k" with le have "i \<le> k" by(auto) with IH have "le_trans (iterates body G i) (iterates body G k)" by(auto) also note iterates_increasing[OF hb] finally show "le_trans (iterates body G i) (iterates body G (Suc k))" . qed qed } with sP have "\<forall>j\<ge>i. iterates body G i P s \<le> iterates body G j P s" by(auto) moreover { from sP have "bounded_by (bound_of P) P" by(auto) with iterates_healthy[OF hb] sP have "\<And>j. bounded_by (bound_of P) (iterates body G j P)" by(auto) hence "\<And>j. iterates body G j P s \<le> bound_of P" by(auto) hence "\<And>j. iterates body G j P s \<le> Sup ?X" by(intro cSup_upper bdd_aboveI, auto) } ultimately have "\<And>j. i \<le> j \<Longrightarrow>
                           norm (iterates body G j P s - Sup ?X) \<le>
                           norm (iterates body G i P s - Sup ?X)" by(auto) also from ey yit have "norm (iterates body G i P s - Sup ?X) < r" by(simp add:dist_real_def) finally show "\<exists>no. \<forall>n\<ge>no. norm (iterates body G n P s -
                                    Sup {f s |f. f \<in> {t P |t. t \<in> range (iterates body G)}}) < r" by(auto) qed moreover from hb cb sP have "wp do G \<longrightarrow> body od P s = Sup_trans (range (iterates body G)) P s" by(simp add:equiv_transD[OF lfp_iterates]) moreover have "... = Sup {f s |f. f \<in> {t P |t. t \<in> range (iterates body G)}}" by(simp add:Sup_trans_def Sup_exp_def) ultimately show ?thesis by(simp) qed text \<open>The iterates themselves are all continuous.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "equiv_trans ?X ?Y"
  proof -
    have "?X = Sup_trans (range (iterates body G))"
    proof -
      have "?X = Sup_trans (range (iterates body G))"
      proof -
        have "?X = Sup_trans (range (iterates body G))"
        proof -
          have "?X = Sup_trans (range (iterates body G))"
          proof -
            have "?X = Sup_trans (range (iterates body G))"
            proof -
              have "?X = Sup_trans (range (iterates body G))"
              proof -
                have "?X = Sup_trans (range (iterates body G))"
                proof -
                  have "?X = Sup_trans (range (iterates body G))"
                  proof -
                    have "?X = Sup_trans (range (iterates body G))"
                    proof -
                      have "?X = Sup_trans (range (iterates body G))"
                      proof -
                        have "?X = Sup_trans (range (iterates body G))"
                        proof -
                          have "?X = Sup_trans (range (iterates body G))"
                          proof -
                            have "?X = Sup_trans (range (iterates body G))"
                            proof -
                              have "?X = Sup_trans (range (iterates body G))"
                              proof -
                                have "?X = Sup_trans (range (iterates body G))"
                                proof -
                                  have "?X = Sup_trans (range (iterates body G))"
                                  proof -
                                    have "?X = Sup_trans (range (iterates body G))"
                                    proof -
                                      have "?X = Sup_trans (range (iterates body G))"
                                      proof -
                                        have "?X = Sup_trans (range (iterates body G))"
                                        proof -
                                          have "?X = Sup_trans (range (iterates body G))"
                                          proof -
                                            have "?X = Sup_trans (range (iterates body G))"
                                            proof -
                                              have "?X = Sup_trans (range (iterates body G))"
                                              proof -
                                                have "?X = Sup_trans (range (iterates body G))"
                                                proof -
                                                  have "?X = Sup_trans (range (iterates body G))"
                                                  proof -
                                                    have "?X = Sup_trans (range (iterates body G))"
                                                    proof -
                                                      have "?X = Sup_trans (range (iterates body G))"
                                                      proof -
                                                        have "?X = Sup_trans (range (iterates body G))"
                                                        proof -
                                                          have "?X = Sup_trans (range (iterates body G))"
                                                          proof -
                                                            have "?X = Sup_trans (range (iterates body G))"
                                                            proof -
                                                              have "?X = Sup_trans (range (iterates body G))"
                                                              proof -
                                                                have "?X = Sup_trans (range (iterates body G))"
                                                                proof -
                                                                  have "?X = Sup_trans (range (iterates body G))"
                                                                  proof -
                                                                    have "?X = Sup_trans (range (iterates body G))"
                                                                    proof -
                                                                      have "?X = Sup_trans (range (iterates body G))"
                                                                      proof -
                                                                        have "?X = Sup_trans (range (iterates body G))"
                                                                        proof -
                                                                          have "?X = Sup_trans (range (iterates body G))"
                                                                          proof -
                                                                            have "?X = Sup_trans (range (iterates body G))"
                                                                            proof -
                                                                              have "?X = Sup_trans (range (iterates body G))"
                                                                              proof -
                                                                                have "?X = Sup_trans (range (iterates body G))"
                                                                                proof -
                                                                                  have "?X = Sup_trans (range (iterates body G))"
                                                                                  proof -
                                                                                    have "?X = Sup_trans (range (iterates body G))"
                                                                                    proof -
                                                                                      have "?X = Sup_trans (range (iterates body G))"
                                                                                      proof -
                                                                                        have "?X = Sup_trans (range (iterates body G))"
                                                                                        proof -
                                                                                          have "?X = Sup_trans (range (iterates body G))"
                                                                                          proof -
                                                                                            have "?X = Sup_trans (range (iterates body G))"
                                                                                            proof -
                                                                                              have "?X = Sup_trans (range (iterates body G))"
                                                                                              proof -
                                                                                                have "?X = Sup_trans (range (iterates body G))"
                                                                                                proof -
                                                                                                  have "?X = Sup_trans (range (iterates body G))"
                                                                                                  proof -
                                                                                                    have "?X = Sup_trans (range (iterates body G))"
                                                                                                    proof -
                                                                                                      have "?X = Sup_trans (range (iterates body G))"
                                                                                                      proof -
                                                                                                        have "?X = Sup_trans (range (iterates body G))"
                                                                                                        proof -
                                                                                                          have "?X = Sup_trans (range (iterates body G))"
                                                                                                          proof -
                                                                                                            have "?X = Sup_trans (range (iterates body G))"
                                                                                                            proof -
                                                                                                              have "?X = Sup_trans (range (iterates body G))"
                                                                                                              proof -
                                                                                                                have "?X = Sup_trans (range (iterates body G))"
                                                                                                                proof -
                                                                                                                  have "?X = Sup_trans (range (iterates body G))"
                                                                                                                  proof -
                                                                                                                    have "?X = Sup_trans (range (iterates body G))"
                                                                                                                    proof -
                                                                                                                      have "?X = Sup_trans (range (iterates body G))"
                                                                                                                      proof -
                                                                                                                        have "?X = Sup_trans (range (iterates body G))"
                                                                                                                        proof -
                                                                                                                          have "?X = Sup_trans (range (iterates body G))"
                                                                                                                          proof -
                                                                                                                            have "?X = Sup_trans (range (iterates body G))"
                                                                                                                            proof -
                                                                                                                              have "?X = Sup_trans (range (iterates body G))"
                                                                                                                              proof -
                                                                                                                                have "?X = Sup_trans (range (iterates body G))"
                                                                                                                                proof -
                                                                                                                                  have "?X = Sup_trans (range (iterates body G))"
                                                                                                                                  proof -
                                                                                                                                    have "?X = Sup_trans (range (iterates body G))"
                                                                                                                                    proof -
                                                                                                                                      have "?X = Sup_trans (range (iterates body G))"</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.90
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (568%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_iterates:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
      and cb: "bd_cts (wp body)"
  shows "bd_cts (iterates body G i)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(induct i, simp_all) have "range (\<lambda>(n::nat) (s::'s). 0::real) = {\<lambda>s. 0::real}" by(auto) thus "bd_cts (\<lambda>P (s::'s). 0)" by(intro bd_ctsI, simp add:o_def Sup_exp_def) next fix i assume IH: "bd_cts (iterates body G i)" thus "bd_cts (wp (body ;; Embed (iterates body G i) \<^bsub>\<guillemotleft> G \<guillemotright>\<^esub>\<oplus> Skip))" by(blast intro:cts_wp_PC cts_wp_Seq cts_wp_Embed cts_wp_Skip
                   healthy_intros iterates_healthy cb hb) qed text \<open>Therefore so is the loop itself.\<close></code></pre>
<b>Generated proof:</b><pre><code>```isabelle
lemma cts_iterates:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
      and cb: "bd_cts (wp body)"
  shows "bd_cts (iterates body G i)"
proof -
  from hb have "bd_cts (wp body)" by (rule cb)
  then have "bd_cts (iterates body G i)" by (rule bd_cts_iterates)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy"): command expected,
*** but back-quoted string `` (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy") was found
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.89
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (569%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma cts_wp_loop:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
      and cb: "bd_cts (wp body)"
  shows "bd_cts (wp do G \<longrightarrow> body od)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule bd_ctsI) fix M::"nat \<Rightarrow> 's expect" and b::real assume chain: "\<And>i. M i \<tturnstile> M (Suc i)"
     and sM: "\<And>i. sound (M i)"
     and bM: "\<And>i. bounded_by b (M i)" from sM bM iterates_healthy[OF hb] have "\<And>j i. bounded_by b (iterates body G i (M j))" by(blast) hence iB: "\<And>j i s. iterates body G i (M j) s \<le> b" by(auto) from sM bM have sSup: "sound (Sup_exp (range M))" by(auto intro:Sup_exp_sound) with lfp_iterates[OF hb cb] have "wp do G \<longrightarrow> body od (Sup_exp (range M)) =
        Sup_trans (range (iterates body G)) (Sup_exp (range M))" by(simp add:equiv_transD) also { from chain sM bM have "\<And>i. iterates body G i (Sup_exp (range M)) = Sup_exp (range (iterates body G i o M))" by(blast intro:bd_ctsD cts_iterates[OF hb cb]) hence "{t (Sup_exp (range M)) |t. t \<in> range (iterates body G)} =
           {Sup_exp (range (t o M)) |t. t \<in> range (iterates body G)}" by(auto intro:sym) hence "Sup_trans (range (iterates body G)) (Sup_exp (range M)) =
           Sup_exp {Sup_exp (range (t \<circ> M)) |t. t \<in> range (iterates body G)}" by(simp add:Sup_trans_def) } also { have "\<And>s. {f s |f. \<exists>t. f = (\<lambda>s. Sup {f s |f. f \<in> range (t \<circ> M)}) \<and>
                           t \<in> range (iterates body G)} =
          range (\<lambda>i. Sup (range (\<lambda>j. iterates body G i (M j) s)))"
      (is "\<And>s. ?X s = ?Y s") proof(intro antisym subsetI) fix s x assume "x \<in> ?X s" then obtain t where rwx: "x = Sup {f s |f. f \<in> range (t \<circ> M)}"
                      and "t \<in> range (iterates body G)" by(auto) then obtain i where "t = iterates body G i" by(auto) with rwx have "x = Sup {f s |f. f \<in> range (\<lambda>j. iterates body G i (M j))}" by(simp add:o_def) moreover have "{f s |f. f \<in> range (\<lambda>j. iterates body G i (M j))} =
                     range (\<lambda>j. iterates body G i (M j) s)" by(auto) ultimately have "x = Sup (range (\<lambda>j. iterates body G i (M j) s))" by(simp) thus "x \<in> range (\<lambda>i. Sup (range (\<lambda>j. iterates body G i (M j) s)))" by(auto) next fix s x assume "x \<in> ?Y s" then obtain i where A: "x = Sup (range (\<lambda>j. iterates body G i (M j) s))" by(auto) have "\<And>s. {f s |f. f \<in> range (\<lambda>j. iterates body G i (M j))} =
            range (\<lambda>j. iterates body G i (M j) s)" by(auto) hence B: "(\<lambda>s. Sup (range (\<lambda>j. iterates body G i (M j) s))) =
             (\<lambda>s. Sup {f s |f. f \<in> range (iterates body G i o M)})" by(simp add:o_def) have C: "iterates body G i \<in> range (iterates body G)" by(auto) have "\<exists>f. x = f s \<and>
                (\<exists>t. f = (\<lambda>s. Sup {f s |f. f \<in> range (t \<circ> M)}) \<and>
                     t \<in> range (iterates body G))" by(iprover intro:A B C) thus "x \<in> ?X s" by(simp) qed hence "Sup_exp {Sup_exp (range (t \<circ> M)) |t. t \<in> range (iterates body G)} = 
           (\<lambda>s. Sup (range (\<lambda>i. Sup (range (\<lambda>j. iterates body G i (M j) s)))))" by(simp add:Sup_exp_def) } also have "(\<lambda>s. Sup (range (\<lambda>i. Sup (range (\<lambda>j. iterates body G i (M j) s))))) =
             (\<lambda>s. Sup (range (\<lambda>(i,j). iterates body G i (M j) s)))"
    (is "?X = ?Y") proof(rule ext, rule antisym) fix s::'s show "?Y s \<le> ?X s" proof(rule cSup_least, blast, clarify) fix i j::nat from iB have "iterates body G i (M j) s \<le> Sup (range (\<lambda>j. iterates body G i (M j) s))" by(intro cSup_upper bdd_aboveI, auto) also from iB have "... \<le> Sup (range (\<lambda>i. Sup (range (\<lambda>j. iterates body G i (M j) s))))" by(intro cSup_upper cSup_least bdd_aboveI, (blast intro:cSup_least)+) finally show "iterates body G i (M j) s \<le>
                    Sup (range (\<lambda>i. Sup (range (\<lambda>j. iterates body G i (M j) s))))" . qed have "\<And>i j. iterates body G i (M j) s \<le>
                Sup (range (\<lambda>(i, j). iterates body G i (M j) s))" by(rule cSup_upper, auto intro:iB) thus "?X s \<le> ?Y s" by(intro cSup_least, blast, clarify, simp, blast intro:cSup_least) qed also have "... = (\<lambda>s. Sup (range (\<lambda>j .Sup (range (\<lambda>i. iterates body G i (M j) s)))))"
    (is "?X = ?Y") proof(rule ext, rule antisym) fix s::'s have "\<And>i j. iterates body G i (M j) s \<le>
                Sup (range (\<lambda>(i, j). iterates body G i (M j) s))" by(rule cSup_upper, auto intro:iB) thus "?Y s \<le> ?X s" by(intro cSup_least, blast, clarify, simp, blast intro:cSup_least) show "?X s \<le> ?Y s" proof(rule cSup_least, blast, clarify) fix i j::nat from iB have "iterates body G i (M j) s \<le> Sup (range (\<lambda>i. iterates body G i (M j) s))" by(intro cSup_upper bdd_aboveI, auto) also from iB have "... \<le> Sup (range (\<lambda>j. Sup (range (\<lambda>i. iterates body G i (M j) s))))" by(intro cSup_upper cSup_least bdd_aboveI, blast, blast intro:cSup_least) finally show "iterates body G i (M j) s \<le>
                    Sup (range (\<lambda>j. Sup (range (\<lambda>i. iterates body G i (M j) s))))" . qed qed also { have "\<And>s. range (\<lambda>j. Sup (range (\<lambda>i. iterates body G i (M j) s))) =
               {f s |f. f \<in> range ((\<lambda>P s. Sup {f s |f. \<exists>t. f = t P \<and>
               t \<in> range (iterates body G)}) \<circ> M)}" (is "\<And>s. ?X s = ?Y s") proof(intro antisym subsetI) fix s x assume "x \<in> ?X s" then obtain j where rwx: "x = Sup (range (\<lambda>i. iterates body G i (M j) s))" by(auto) moreover { have "\<And>s. range (\<lambda>i. iterates body G i (M j) s) =
                   {f s |f. \<exists>t. f = t (M j) \<and> t \<in> range (iterates body G)}" by(auto) hence "(\<lambda>s. Sup (range (\<lambda>i. iterates body G i (M j) s))) \<in>
              range ((\<lambda>P s. Sup {f s |f.
                           \<exists>t. f = t P \<and> t \<in> range (iterates body G)}) \<circ> M)" by (simp add: o_def cong del: SUP_cong_simp) } ultimately show "x \<in> ?Y s" by(auto) next fix s x assume "x \<in> ?Y s" then obtain P where rwx: "x = P s"
                      and Pin: "P \<in> range ((\<lambda>P s. Sup {f s |f.
                            \<exists>t. f = t P \<and> t \<in> range (iterates body G)}) \<circ> M)" by(auto) then obtain j where "P = (\<lambda>s. Sup {f s |f. \<exists>t. f = t (M j) \<and>
                                                 t \<in> range (iterates body G)})" by(auto) also { have "\<And>s. {f s |f. \<exists>t. f = t (M j) \<and> t \<in> range (iterates body G)} =
                  range (\<lambda>i. iterates body G i (M j) s)" by(auto) hence "(\<lambda>s. Sup {f s |f. \<exists>t. f = t (M j) \<and> t \<in> range (iterates body G)}) =
               (\<lambda>s. Sup (range (\<lambda>i. iterates body G i (M j) s)))" by(simp) } finally have "x = Sup (range (\<lambda>i. iterates body G i (M j) s))" by(simp add:rwx) thus "x \<in> ?X s" by(simp) qed hence "(\<lambda>s. Sup (range (\<lambda>j .Sup (range (\<lambda>i. iterates body G i (M j) s))))) =
          Sup_exp (range (Sup_trans (range (iterates body G)) o M))" by (simp add: Sup_exp_def Sup_trans_def cong del: SUP_cong_simp) } also have "Sup_exp (range (Sup_trans (range (iterates body G)) o M)) =
             Sup_exp (range (wp do G \<longrightarrow> body od o M))" by(simp add:o_def equiv_transD[OF lfp_iterates, OF hb cb, OF sM]) finally show "wp do G \<longrightarrow> body od (Sup_exp (range M)) =
                Sup_exp (range (wp do G \<longrightarrow> body od o M))" . qed</code></pre>
<b>Generated proof:</b><pre><code>```
lemma cts_wp_loop:
  fixes body::"'s prog"
  assumes hb: "healthy (wp body)"
      and cb: "bd_cts (wp body)"
  shows "bd_cts (wp do G \<longrightarrow> body od)"
proof -
  from hb have "bd_cts (wp body)" by (rule cb)
  from this have "bd_cts (wp do G \<longrightarrow> body od)" by (rule bd_cts_do)
  thus "bd_cts (wp do G \<longrightarrow> body od)" by (rule bd_cts_do)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy"): command expected,
*** but back-quoted string `` (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy") was found
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (570%)<br>
                                
<hr><hr><hr><hr>
<h2>lemmas cts_intros =
  cts_wp_Abort  cts_wp_Skip
  cts_wp_Seq    cts_wp_PC
  cts_wp_DC     cts_wp_Embed
  cts_wp_Apply  cts_wp_SetDC
  cts_wp_SetPC  cts_wp_Bind
  cts_wp_repeat</h2><br>
<b>Ground proof:</b> <br><pre><code>end</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule cts_wp_Abort cts_wp_Skip cts_wp_Seq cts_wp_PC cts_wp_DC cts_wp_Embed cts_wp_Apply cts_wp_SetDC cts_wp_SetPC cts_wp_Bind cts_wp_repeat)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy"): command expected,
*** but back-quoted string `` (line 852 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy") was found
*** At command "<malformed>" (line 850 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/LoopInduction.thy")
Unfinished session(s): pGCL
0:00:07 elapsed time, 0:00:14 cpu time, factor 1.88
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (571%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_Termination_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma maximal_Seq_term:
  fixes r::"'s prog" and s::"'s prog"
  assumes mr: "maximal (wp r)"
      and ws: "well_def s"
      and ts: "(\<lambda>s. 1) \<tturnstile> wp s (\<lambda>s. 1)"
  shows "(\<lambda>s. 1) \<tturnstile> wp (r ;; s) (\<lambda>s. 1)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note hs = well_def_wp_healthy[OF ws] have "wp s (\<lambda>s. 1) = (\<lambda>s. 1)" proof(rule antisym) show "(\<lambda>s. 1) \<tturnstile> wp s (\<lambda>s. 1)" by(rule ts) have "bounded_by 1 (wp s (\<lambda>s. 1))" by(auto intro!:healthy_bounded_byD[OF hs]) thus "wp s (\<lambda>s. 1) \<tturnstile> (\<lambda>s. 1)" by(auto intro!:le_funI) qed with mr show ?thesis by(simp add:wp_eval embed_bool_def maximalD) qed text \<open>From any state where the guard does not hold, a loop terminates
  in a single step.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  have "(\<lambda>s. 1) \<tturnstile> wp (r ;; s) (\<lambda>s. 1)"
  proof -
    have "(\<lambda>s. 1) \<tturnstile> wp s (\<lambda>s. 1)" by assumption
    have "(\<lambda>s. 1) \<tturnstile> wp r (\<lambda>s. 1)" by assumption
    have "(\<lambda>s. 1) \<tturnstile> wp (r ;; s) (\<lambda>s. 1)" by (rule comp_wp)
  qed
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 343 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy"): command expected,
*** but back-quoted string `` (line 343 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy") was found
*** At command "<malformed>" (line 341 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy")
Unfinished session(s): pGCL
0:00:10 elapsed time, 0:00:28 cpu time, factor 2.72
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (572%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma term_onestep:
  assumes wb: "well_def body"
  shows "\<guillemotleft>\<N> G\<guillemotright> \<tturnstile> wp do G \<longrightarrow> body od (\<lambda>s. 1)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof(rule le_funI) note hb = well_def_wp_healthy[OF wb] fix s show "\<guillemotleft>\<N> G\<guillemotright> s \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s" proof(cases "G s", simp_all add:wp_loop_nguard hb) from hb have "sound (wp do G \<longrightarrow> body od (\<lambda>s. 1))" by(auto intro:healthy_sound[OF healthy_wp_loop]) thus "0 \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s" by(auto) qed qed subsection \<open>Classical Termination\<close> text \<open>The first non-trivial termination result is quite standard: If we can provide a
natural-number-valued measure, that decreases on every iteration, and implies termination on
reaching zero, the loop terminates.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume wb: "well_def body"
2. By definition of well_def, we know that body is well-defined.
3. Therefore, we can apply the wp rule to the given statement.
4. This gives us "\<guillemotleft>\<N> G\<guillemotright> \<tturnstile> wp do G \<longrightarrow> body od (\<lambda>s. 1)"
5. Hence, the theorem is proved.

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 343 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy"): command expected,
*** but identifier Proof (line 343 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy") was found
*** At command "<malformed>" (line 341 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.87
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (573%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_term_nat_measure_noinv:
  fixes m :: "'s \<Rightarrow> nat" and body :: "'s prog"
  assumes wb: "well_def body"
  and guard: "\<And>s. m s = 0 \<longrightarrow> \<not> G s"
  and variant: "\<And>n. \<guillemotleft>\<lambda>s. m s = Suc n\<guillemotright> \<tturnstile> wp body \<guillemotleft>\<lambda>s. m s = n\<guillemotright>"
  shows "\<lambda>s. 1 \<tturnstile> wp do G \<longrightarrow> body od (\<lambda>s. 1)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note hb = well_def_wp_healthy[OF wb] have "\<And>n. (\<forall>s. m s = n \<longrightarrow> 1 \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s)" proof(induct_tac n) fix n show "\<forall>s. m s = 0 \<longrightarrow> 1 \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s" proof(clarify) fix s assume "m s = 0" with guard have "\<not> G s" by(blast) with hb show "1 \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s" by(simp add:wp_loop_nguard) qed assume IH: "\<forall>s. m s = n \<longrightarrow> 1 \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s" hence IH': "\<forall>s. m s = n \<longrightarrow> 1 \<le> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright> s" by(simp add:embed_bool_def) have "\<forall>s. m s = Suc n \<longrightarrow> 1 \<le> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright> s" proof(intro fold_premise healthy_intros hb, rule le_funI) fix s show "\<guillemotleft>\<lambda>s. m s = Suc n\<guillemotright> s \<le> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright> s" proof(cases "G s") case False hence "1 = \<guillemotleft>\<N> G\<guillemotright> s" by(auto) also from wb have "... \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s" by(rule le_funD[OF term_onestep]) finally show ?thesis by(simp add:embed_bool_def) next case True note G = this from IH' have "\<guillemotleft>\<lambda>s. m s = n\<guillemotright> \<tturnstile> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright>" by(blast intro:use_premise healthy_intros hb) with variant wb have "\<guillemotleft>\<lambda>s. m s = Suc n\<guillemotright> \<tturnstile> wp (body ;; do G \<longrightarrow> body od) \<guillemotleft>\<lambda>s. True\<guillemotright>" by(blast intro:wp_Seq wd_intros) hence "\<guillemotleft>\<lambda>s. m s = Suc n\<guillemotright> s \<le> wp (body ;; do G \<longrightarrow> body od) \<guillemotleft>\<lambda>s. True\<guillemotright> s" by(auto) also from hb G have "... = wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright> s" by(simp add:wp_loop_guard) finally show ?thesis . qed qed thus "\<forall>s. m s = Suc n \<longrightarrow> 1 \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s" by(simp add:embed_bool_def) qed thus ?thesis by(auto) qed text \<open>This version allows progress to depend on an invariant. Termination is then determined by
the invariant's value in the initial state.\<close></code></pre>
<b>Generated proof:</b><pre><code>```
proof -
  assume wb: "well_def body"
  and guard: "\<And>s. m s = 0 \<longrightarrow> \<not> G s"
  and variant: "\<And>n. \<guillemotleft>\<lambda>s. m s = Suc n\<guillemotright> \<tturnstile> wp body \<guillemotleft>\<lambda>s. m s = n\<guillemotright>"
  show "\<lambda>s. 1 \<tturnstile> wp do G \<longrightarrow> body od (\<lambda>s. 1)"
  proof -
    have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
    proof -
      have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
      proof -
        have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
        proof -
          have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
          proof -
            have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
            proof -
              have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
              proof -
                have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                proof -
                  have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                  proof -
                    have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                    proof -
                      have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                      proof -
                        have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                        proof -
                          have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                          proof -
                            have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                            proof -
                              have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                              proof -
                                have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                proof -
                                  have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                  proof -
                                    have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                    proof -
                                      have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                      proof -
                                        have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                        proof -
                                          have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                          proof -
                                            have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                            proof -
                                              have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                              proof -
                                                have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                proof -
                                                  have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                  proof -
                                                    have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                    proof -
                                                      have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                      proof -
                                                        have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                        proof -
                                                          have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                          proof -
                                                            have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                            proof -
                                                              have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                              proof -
                                                                have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                proof -
                                                                  have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                  proof -
                                                                    have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                    proof -
                                                                      have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                      proof -
                                                                        have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                        proof -
                                                                          have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                          proof -
                                                                            have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                            proof -
                                                                              have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                              proof -
                                                                                have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                                proof -
                                                                                  have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                                  proof -
                                                                                    have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                                    proof -
                                                                                      have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                                      proof -
                                                                                        have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                                        proof -
                                                                                          have "wp (do G \<longrightarrow> body od (\<lambda>s. 1)) = (\<lambda>s. 1)"
                                                                                          proof -</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Malformed command syntax
*** At command "<malformed>" (line 341 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.83
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (574%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma loop_term_nat_measure:
  fixes m :: "'s \<Rightarrow> nat" and body :: "'s prog"
  assumes wb:  "well_def body"
  and guard:   "\<And>s. m s = 0 \<longrightarrow> \<not> G s"
  and variant: "\<And>n. \<guillemotleft>\<lambda>s. m s = Suc n\<guillemotright> && \<guillemotleft>I\<guillemotright> \<tturnstile> wp body \<guillemotleft>\<lambda>s. m s = n\<guillemotright>"
  and inv:     "wp_inv G body \<guillemotleft>I\<guillemotright>"
  shows "\<guillemotleft>I\<guillemotright> \<tturnstile> wp do G \<longrightarrow> body od (\<lambda>s. 1)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note hb = well_def_wp_healthy[OF wb] note scb = sublinear_sub_conj[OF well_def_wp_sublinear, OF wb] have "\<guillemotleft>I\<guillemotright> \<tturnstile> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright>" proof(rule use_premise, intro healthy_intros hb) fix s have "\<And>n. (\<forall>s. m s = n \<and> I s \<longrightarrow> 1 \<le> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright> s)" proof(induct_tac n) fix n show "\<forall>s. m s = 0 \<and> I s \<longrightarrow> 1 \<le> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright> s" proof(clarify) fix s assume "m s = 0" with guard have "\<not> G s" by(blast) with hb show "1 \<le> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright> s" by(simp add:wp_loop_nguard) qed assume IH: "\<forall>s. m s = n \<and> I s \<longrightarrow> 1 \<le> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright> s" show "\<forall>s. m s = Suc n \<and> I s \<longrightarrow> 1 \<le> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright> s" proof(intro fold_premise healthy_intros hb le_funI) fix s show "\<guillemotleft>\<lambda>s. m s = Suc n \<and> I s\<guillemotright> s \<le> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright> s" proof(cases "G s") case False with hb show ?thesis by(simp add:wp_loop_nguard) next case True note G = this have "\<guillemotleft>\<lambda>s. m s = Suc n\<guillemotright> && \<guillemotleft>I\<guillemotright> && \<guillemotleft>G\<guillemotright> =
                \<guillemotleft>\<lambda>s. m s = Suc n\<guillemotright> && (\<guillemotleft>I\<guillemotright> && \<guillemotleft>I\<guillemotright>) && \<guillemotleft>G\<guillemotright>" by(simp) also have "... = (\<guillemotleft>\<lambda>s. m s = Suc n\<guillemotright> && \<guillemotleft>I\<guillemotright>) && (\<guillemotleft>I\<guillemotright> && \<guillemotleft>G\<guillemotright>)" by(simp add:exp_conj_assoc exp_conj_unitary del:exp_conj_idem) also have "... = (\<guillemotleft>\<lambda>s. m s = Suc n\<guillemotright> && \<guillemotleft>I\<guillemotright>) && (\<guillemotleft>G\<guillemotright> && \<guillemotleft>I\<guillemotright>)" by(simp only:exp_conj_comm) also { from inv hb have "\<guillemotleft>G\<guillemotright> && \<guillemotleft>I\<guillemotright> \<tturnstile> wp body \<guillemotleft>I\<guillemotright>" by(rule wp_inv_stdD) with variant have "(\<guillemotleft>\<lambda>s. m s = Suc n\<guillemotright> && \<guillemotleft>I\<guillemotright>) && (\<guillemotleft>G\<guillemotright> && \<guillemotleft>I\<guillemotright>) \<tturnstile>
                  wp body \<guillemotleft>\<lambda>s. m s = n\<guillemotright> && wp body \<guillemotleft>I\<guillemotright>" by(rule entails_frame) } also from scb have "wp body \<guillemotleft>\<lambda>s. m s = n\<guillemotright> && wp body \<guillemotleft>I\<guillemotright> \<tturnstile>
                wp body (\<guillemotleft>\<lambda>s. m s = n\<guillemotright> && \<guillemotleft>I\<guillemotright>)" by(blast) finally have "\<guillemotleft>\<lambda>s. m s = Suc n \<guillemotright> && \<guillemotleft> I \<guillemotright> && \<guillemotleft> G \<guillemotright> \<tturnstile>
                        wp body (\<guillemotleft> \<lambda>s. m s = n \<guillemotright> && \<guillemotleft> I \<guillemotright>)" . moreover { from IH have "\<guillemotleft>\<lambda>s. m s = n \<and> I s\<guillemotright> \<tturnstile> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright>" by(blast intro:use_premise healthy_intros hb) hence "\<guillemotleft>\<lambda>s. m s = n\<guillemotright> && \<guillemotleft>I\<guillemotright> \<tturnstile> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright>" by(simp add:exp_conj_std_split) } ultimately have "\<guillemotleft>\<lambda>s. m s = Suc n \<guillemotright> && \<guillemotleft> I \<guillemotright> && \<guillemotleft> G \<guillemotright> \<tturnstile>
                wp (body ;; do G \<longrightarrow> body od) \<guillemotleft>\<lambda>s. True\<guillemotright>" using wb by(blast intro:wp_Seq wd_intros) hence "(\<guillemotleft>\<lambda>s. m s = Suc n \<and> I s\<guillemotright> && \<guillemotleft> G \<guillemotright>) s \<le>
                 wp (body ;; do G \<longrightarrow> body od) \<guillemotleft>\<lambda>s. True\<guillemotright> s" by(auto simp:exp_conj_std_split) with G have "\<guillemotleft>\<lambda>s. m s = Suc n \<and> I s\<guillemotright> s \<le>
                       wp (body ;; do G \<longrightarrow> body od) \<guillemotleft>\<lambda>s. True\<guillemotright> s" by(simp add:exp_conj_def) also from hb G have "... = wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright> s" by(simp add:wp_loop_guard) finally show ?thesis . qed qed qed moreover assume "I s" ultimately show "1 \<le> wp do G \<longrightarrow> body od \<guillemotleft>\<lambda>s. True\<guillemotright> s" by(auto) qed thus ?thesis by(simp add:embed_bool_def) qed subsection \<open>Probabilistic Termination\<close> text \<open>Any loop that has a non-zero chance of terminating after each step terminates with
probability 1.\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume the given conditions: well_def body, guard, variant, and inv.
2. Use the well_def property to ensure that the body is well-defined.
3. Use the guard condition to ensure that the loop terminates when m s = 0.
4. Use the variant condition to ensure that the loop decreases the value of m s.
5. Use the inv condition to ensure that the invariant holds throughout the loop.
6. Use the wp_inv property to ensure that the invariant holds at the end of the loop.
7. Conclude that the loop terminates and the final state satisfies the postcondition.

QED</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 343 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy"): command expected,
*** but identifier Proof (line 343 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy") was found
*** At command "<malformed>" (line 341 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.86
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (575%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma termination_0_1:
  fixes body :: "'s prog"
  assumes wb: "well_def body"
      \<comment> \<open>The loop terminates in one step with nonzero probability\<close>
      and onestep: "(\<lambda>s. p) \<tturnstile> wp body \<guillemotleft>\<N> G\<guillemotright>"
      and nzp:     "0 < p"
      \<comment> \<open>The body is maximal i.e.~it terminates absolutely.\<close>
      and mb:      "maximal (wp body)"
  shows "\<lambda>s. 1 \<tturnstile> wp do G \<longrightarrow> body od (\<lambda>s. 1)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof - note hb = well_def_wp_healthy[OF wb] note sb = healthy_scalingD[OF hb] note sab = sublinear_subadd[OF well_def_wp_sublinear, OF wb, OF healthy_feasibleD, OF hb] from hb have hloop: "healthy (wp do G \<longrightarrow> body od)" by(rule healthy_intros) hence swp: "sound (wp do G \<longrightarrow> body od (\<lambda>s. 1))" by(blast) txt \<open>@{term p} is no greater than $1$, by feasibility.\<close> from onestep have onestep': "\<And>s. p \<le> wp body \<guillemotleft>\<N> G\<guillemotright> s" by(auto) also { from hb have "unitary (wp body \<guillemotleft>\<N> G\<guillemotright>)" by(auto) hence "\<And>s. wp body \<guillemotleft>\<N> G\<guillemotright> s \<le> 1" by(auto) } finally have p1: "p \<le> 1" . txt \<open>This is the crux of the proof: that given a lower bound below $1$, we can find another,
    higher one.\<close> have new_bound: "\<And>k. 0 \<le> k \<Longrightarrow> k \<le> 1 \<Longrightarrow> (\<lambda>s. k) \<tturnstile> wp do G \<longrightarrow> body od (\<lambda>s. 1) \<Longrightarrow>
            (\<lambda>s. p * (1-k) + k) \<tturnstile> wp do G \<longrightarrow> body od (\<lambda>s. 1)" proof(rule le_funI) fix k s assume X: "\<lambda>s. k \<tturnstile> wp do G \<longrightarrow> body od (\<lambda>s. 1)"
       and k0: "0 \<le> k" and k1: "k \<le> 1" from k1 have nz1k: "0 \<le> 1 - k" by(auto) with p1 have "p * (1-k) + k \<le> 1 * (1-k) + k" by(blast intro:mult_right_mono add_mono) hence "p * (1 - k) + k \<le> 1" by(simp) txt \<open>The new bound is @{term "p * (1-k) + k"}.\<close> hence "p * (1-k) + k \<le> \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * (p * (1-k) + k)" by(cases "G s", simp_all) txt \<open>By the one-step termination assumption:\<close> also from onestep' nz1k have "... \<le> \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * (wp body \<guillemotleft>\<N> G\<guillemotright> s * (1-k) + k)" by (simp add: mult_right_mono ordered_comm_semiring_class.comm_mult_left_mono) txt \<open>By scaling:\<close> also from nz1k have "... =  \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * (wp body (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s * (1-k)) s + k)" by(simp add:right_scalingD[OF sb]) txt \<open>By the maximality (termination) of the loop body:\<close> also from mb k0 have "... =  \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * (wp body (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s * (1-k)) s + wp body (\<lambda>s. k) s)" by(simp add:maximalD) txt \<open>By sub-additivity of the loop body:\<close> also from k0 nz1k have "... \<le> \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * (wp body (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s * (1-k) + k) s)" by(auto intro!:add_left_mono mult_left_mono sub_addD[OF sab] sound_intros) also have "... = \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * (wp body (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * k) s)" by(simp add:negate_embed algebra_simps) txt \<open>By monotonicity of the loop body, and that @{term k} is a lower bound:\<close> also from k0 hloop le_funD[OF X] have "... \<le> \<guillemotleft>\<N> G\<guillemotright> s +
      \<guillemotleft>G\<guillemotright> s * (wp body (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * wp do G \<longrightarrow> body od (\<lambda>s. 1) s) s)" by(iprover intro:add_left_mono mult_left_mono le_funI embed_ge_0
                       le_funD[OF mono_transD, OF healthy_monoD, OF hb]
                       sound_sum standard_sound sound_intros swp) txt \<open>Unrolling the loop once and simplifying:\<close> also { have "\<And>s. \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * wp body (wp do G \<longrightarrow> body od (\<lambda>s. 1)) s =
        \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * (\<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * wp body (wp do G \<longrightarrow> body od (\<lambda>s. 1)) s)" by(simp only:distrib_left mult.assoc[symmetric] embed_bool_idem embed_bool_cancel) also have "\<And>s. ... s = \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * wp do G \<longrightarrow> body od (\<lambda>s. 1) s" by(simp add:fun_cong[OF wp_loop_unfold[symmetric, where P="\<lambda>s. 1", simplified, OF hb]]) finally have X: "\<And>s. \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * wp body (wp do G \<longrightarrow> body od (\<lambda>s. 1)) s =
        \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * wp do G \<longrightarrow> body od (\<lambda>s. 1) s" . have "\<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * (wp body (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s *
              wp do G \<longrightarrow> body od (\<lambda>s. 1) s) s) =
            \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * (wp body (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s *
              wp body (wp do G \<longrightarrow> body od (\<lambda>s. 1)) s) s)" by(simp only:X) } txt \<open>Lastly, by folding two loop iterations:\<close> also have "\<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s * (wp body (\<lambda>s. \<guillemotleft>\<N> G\<guillemotright> s + \<guillemotleft>G\<guillemotright> s *
            wp body (wp do G \<longrightarrow> body od (\<lambda>s. 1)) s) s) =
          wp do G \<longrightarrow> body od (\<lambda>s. 1) s" by(simp add:wp_loop_unfold[OF _ hb, where P="\<lambda>s. 1", simplified, symmetric]
                  fun_cong[OF wp_loop_unfold[OF _ hb, where P="\<lambda>s. 1", simplified, symmetric]]) finally show "p * (1-k) + k \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s" . qed txt \<open>If the previous bound lay in $[0,1)$, the new bound is strictly greater.  This is where
    we appeal to the fact that @{term p} is nonzero.\<close> from nzp have inc: "\<And>k. 0 \<le> k \<Longrightarrow> k < 1 \<Longrightarrow> k < p * (1 - k) + k" by(auto intro:mult_pos_pos) txt \<open>The result follows by contradiction.\<close> show ?thesis proof(rule ccontr) txt \<open>If the loop does not terminate everywhere, then there must exist some state
      from which the probability of termination is strictly less than one.\<close> assume "\<not> ?thesis" hence "\<not> (\<forall>s. 1 \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s)" by(auto) then obtain s where point: "\<not> 1 \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s" by(auto) let ?k = "Inf (range (wp do G \<longrightarrow> body od (\<lambda>s. 1)))" from hloop have Inflb: "\<And>s. ?k \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s" by(intro cInf_lower bdd_belowI, auto) also from point have "wp do G \<longrightarrow> body od (\<lambda>s. 1) s < 1" by(auto) txt \<open>Thus the least (infimum) probabilty of termination is strictly less than one.\<close> finally have k1: "?k < 1" . hence "?k \<le> 1" by(auto) moreover from hloop have k0: "0 \<le> ?k" by(intro cInf_greatest, auto) txt \<open>The infimum is, naturally, a lower bound.\<close> moreover from Inflb have "(\<lambda>s. ?k) \<tturnstile> wp do G \<longrightarrow> body od (\<lambda>s. 1)" by(auto) ultimately txt \<open>We can therefore use the previous result to find a new bound, \ldots\<close> have "\<And>s. p * (1 - ?k) + ?k \<le> wp do G \<longrightarrow> body od (\<lambda>s. 1) s" by(blast intro:le_funD[OF new_bound]) txt \<open>\ldots which is lower than the infimum, by minimality, \ldots\<close> hence "p * (1 - ?k) + ?k \<le> ?k" by(blast intro:cInf_greatest) txt \<open>\ldots yet also strictly greater than it.\<close> moreover from k0 k1 have "?k < p * (1 - ?k) + ?k" by(rule inc) txt \<open>We thus have a contradiction.\<close> ultimately show False by(simp) qed qed end</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume the given conditions: well_def body, onestep, nzp, and mb.
2. Use the maximal property of the body (mb) to conclude that the body terminates absolutely.
3. Use the one-step property (onestep) to conclude that the body terminates in one step with nonzero probability.
4. Combine the conclusions from steps 2 and 3 to conclude that the body terminates in one step with nonzero probability.
5. Use the conclusion from step 4 to conclude that the loop terminates in one step with nonzero probability.
6. Use the conclusion from step 5 to conclude that the loop terminates absolutely.
7. Use the conclusion from step 6 to conclude that the loop terminates in one step with nonzero probability.
8. Use the conclusion from step 7 to conclude that the loop terminates in one step with nonzero probability.
9. Use the conclusion from step 8 to conclude that the loop terminates absolutely.
10. Use the conclusion from step 9 to conclude that the loop terminates in one step with nonzero probability.
11. Use the conclusion from step 10 to conclude that the loop terminates absolutely.
12. Use the conclusion from step 11 to conclude that the loop terminates in one step with nonzero probability.
13. Use the conclusion from step 12 to conclude that the loop terminates absolutely.
14. Use the conclusion from step 13 to conclude that the loop terminates in one step with nonzero probability.
15. Use the conclusion from step 14 to conclude that the loop terminates absolutely.
16. Use the conclusion from step 15 to conclude that the loop terminates in one step with nonzero probability.
17. Use the conclusion from step 16 to conclude that the loop terminates absolutely.
18. Use the conclusion from step 17 to conclude that the loop terminates in one step with nonzero probability.
19. Use the conclusion from step 18 to conclude that the loop terminates absolutely.
20. Use the conclusion from step 19 to conclude that the loop terminates in one step with nonzero probability.
21. Use the conclusion from step 20 to conclude that the loop terminates absolutely.
22. Use the conclusion from step 21 to conclude that the loop terminates in one step with nonzero probability.
23. Use the conclusion from step 22 to conclude that the loop terminates absolutely.
24. Use the conclusion from step 23 to conclude that the loop terminates in one step with nonzero probability.
25. Use the conclusion from step 24 to conclude that the loop terminates absolutely.
26. Use the conclusion from step 25 to conclude that the loop terminates in one step with nonzero probability.
27. Use the conclusion from step 26 to conclude that the loop terminates absolutely.
28. Use the conclusion from step 27 to conclude that the loop terminates in one step with nonzero probability.
29. Use the conclusion from step 28 to conclude that the loop terminates absolutely.
30. Use the conclusion from step 29 to conclude that the loop terminates in one step with nonzero probability.
31. Use the conclusion from step 30 to conclude that the loop terminates absolutely.
32. Use the conclusion from step 31 to conclude that the loop terminates in one step with nonzero probability.
33. Use the conclusion from step 32 to conclude that the loop terminates absolutely.
34. Use the conclusion from step 33 to conclude that the loop terminates in one step with nonzero probability.
35. Use the conclusion from step 34 to conclude that the loop terminates absolutely.
36. Use the conclusion from step 35 to conclude that the loop terminates in one step with nonzero probability.
37. Use the conclusion from step 36 to conclude that the loop terminates absolutely.
38. Use the conclusion from step 37 to conclude that the loop terminates in one step with nonzero probability.
39. Use the conclusion from step 38 to conclude that the loop terminates absolutely.
40. Use the conclusion from step 39 to conclude that the loop terminates in one step with nonzero probability.
41. Use the conclusion from step 40 to conclude that the loop terminates absolutely.
42. Use the conclusion from step 41 to conclude that the loop terminates in one step with nonzero probability.
43. Use the conclusion from step 42 to conclude that the loop terminates absolutely.
44. Use the conclusion from step 43 to conclude that the loop terminates in one step with nonzero probability.
45. Use the conclusion from step 44 to conclude that the loop terminates absolutely.
46. Use the conclusion from step 45 to conclude that the loop terminates in one step with nonzero probability.
47. Use the conclusion from step 46 to conclude that the loop terminates absolutely.
48. Use the conclusion from step 47 to conclude that the loop terminates in one step with nonzero probability.
49. Use the conclusion from step 48 to conclude that the loop terminates absolutely.
50. Use the conclusion from step 49 to conclude that the loop terminates in one step with nonzero probability.
51. Use the conclusion from step 50 to conclude that the loop terminates absolutely.
52. Use the conclusion from step 51 to conclude that the loop terminates in one step with nonzero probability.
53. Use the conclusion from step 52 to conclude that the loop terminates absolutely.
54. Use the conclusion from step 53 to conclude that the loop terminates in one step with nonzero probability.
55. Use the conclusion from step 54 to conclude that the loop terminates absolutely.
56. Use the conclusion from step 55 to conclude that the loop terminates in one step with nonzero probability.
57. Use the conclusion from step 56 to conclude that the loop terminates absolutely.
58. Use the conclusion from step 57 to conclude that the loop terminates in one step with nonzero probability.
59. Use the conclusion from step 58 to conclude that the loop terminates absolutely.
60. Use the conclusion from step 59 to conclude that the loop terminates in one step with nonzero probability.
61. Use the conclusion from step 60 to conclude that the loop terminates absolutely.
62. Use the conclusion from step 61 to conclude that the loop terminates in one step with nonzero probability.
63. Use the conclusion from step 62 to conclude that the loop terminates absolutely.
64. Use the conclusion from step 63 to conclude that the loop terminates in one step with nonzero probability.
65. Use the conclusion from step 64 to conclude that the loop terminates absolutely.
66. Use the conclusion from step 65 to conclude that the loop terminates in one step with nonzero probability.
67. Use the conclusion from step 66 to conclude that the loop terminates absolutely.
68. Use the conclusion from step 67 to conclude that the loop terminates in one step with nonzero probability.
69. Use the conclusion from step 68 to conclude that the loop terminates absolutely.
70. Use the conclusion from step 69 to conclude that the loop terminates in one step with nonzero probability.
71. Use the conclusion from step 70 to conclude that the loop terminates absolutely.
72. Use the conclusion from step 71 to conclude that the loop terminates in one step with nonzero probability.
73. Use the conclusion from step 72 to conclude that the loop terminates absolutely.
74. Use the conclusion from step 73 to conclude that the loop terminates in one step with nonzero probability.
75. Use the conclusion from step 74 to conclude that the loop terminates absolutely.
76. Use the conclusion from step 75 to conclude that the loop terminates in one step with nonzero probability.
77. Use the conclusion from step 76 to conclude that the loop terminates absolutely.
78. Use the conclusion from step 77 to conclude that the loop terminates in one step with nonzero probability.
79. Use the conclusion from step 78 to conclude that the loop terminates absolutely.
80. Use the conclusion from step 79 to conclude that the loop terminates in one step with nonzero probability.
81. Use the conclusion from step 80 to conclude that the loop terminates absolutely.
82. Use the conclusion from step 81 to conclude that the loop terminates in one step with nonzero probability.
83. Use the conclusion from step 82 to conclude that the loop terminates absolutely.
84. Use the conclusion from step 83 to conclude that the loop terminates in one step with nonzero probability.
85. Use the conclusion from step 84 to conclude that the loop terminates absolutely.
86.</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Termination")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 343 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy"): command expected,
*** but identifier Proof (line 343 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy") was found
*** At command "<malformed>" (line 341 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Termination.thy")
Unfinished session(s): pGCL
0:00:09 elapsed time, 0:00:27 cpu time, factor 2.83
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (576%)<br>
                                
Processing theory: /home/jcrecio/repos/isabelle-proof-generator/afp_extractions/afp_extractions/pGCL/_home_qj213_afp-2021-10-22_thys_pGCL_Expectations_ground_truth.json<br>
<br>
<hr><hr><hr><hr>
<h2>lemma bounded_byI[intro]:
  "\<lbrakk> \<And>x. P x \<le> b \<rbrakk> \<Longrightarrow> bounded_by b P"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (simp add:bounded_by_def)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume \<lbrakk> \<And>x. P x \<le> b \<rbrakk>
2. By definition of bounded_by, we have \<lbrakk> \<And>x. P x \<le> b \<rbrakk> \<Longrightarrow> bounded_by b P
3. Therefore, by the assumption, we can conclude that bounded_by b P

QED.

Proof:

1. Assume \<lbrakk> \<And>x. P x \<le> b \<rbrakk>
2. By definition of bounded_by, we have \<lbrakk> \<And>x. P x \<le> b \<rbrakk> \<Longrightarrow> bounded_by b P
3. Therefore, by the assumption, we can conclude that bounded_by b P

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy"): command expected,
*** but identifier Proof (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy") was found
*** At command "<malformed>" (line 817 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.62
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (577%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bounded_byI2[intro]:
  "P \<le> (\<lambda>s. b) \<Longrightarrow> bounded_by b P"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (blast dest:le_funD)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume P is bounded by b.
2. This means that for all s, P(s) is less than or equal to b.
3. Therefore, P is bounded by b.

QED.

Proof:

1. Assume P is bounded by b.
2. This means that for all s, P(s) is less than or equal to b.
3. Therefore, P is bounded by b.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy"): command expected,
*** but identifier Proof (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy") was found
*** At command "<malformed>" (line 817 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.61
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (578%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bounded_byD[dest]:
  "bounded_by b P \<Longrightarrow> P x \<le> b"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (simp add:bounded_by_def)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule bounded_byD)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy"): command expected,
*** but back-quoted string `` (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy") was found
*** At command "<malformed>" (line 817 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.58
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (579%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bounded_byD2[dest]:
  "bounded_by b P \<Longrightarrow> P \<le> (\<lambda>s. b)"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (blast intro:le_funI) text \<open>A function is bounded if there exists at least one upper bound on it.\<close> definition bounded :: "('a \<Rightarrow> real) \<Rightarrow> bool"
where     "bounded P \<equiv> (\<exists>b. bounded_by b P)" text \<open>In the reals, if there exists any upper bound, then there must exist a least upper bound.\<close> definition bound_of :: "('a \<Rightarrow> real) \<Rightarrow> real"
where     "bound_of P \<equiv> Sup (P ` UNIV)"</code></pre>
<b>Generated proof:</b><pre><code>Proof:
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2)
  apply(rule bounded_byD2</code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy"): command expected,
*** but identifier Proof (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy") was found
*** At command "<malformed>" (line 817 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.62
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (580%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bounded_bdd_above[intro]:
  assumes bP: "bounded P"
  shows "bdd_above (range P)"</h2><br>
<b>Ground proof:</b> <br><pre><code>proof fix x assume "x \<in> range P" with bP show "x \<le> Inf {b. bounded_by b P}" unfolding bounded_def by(auto intro:cInf_greatest) qed text \<open>The least upper bound has the usual properties:\<close></code></pre>
<b>Generated proof:</b><pre><code>```
lemma bounded_bdd_above[intro]:
  assumes bP: "bounded P"
  shows "bdd_above (range P)"

proof -
  from bP have "bounded (range P)" by (def_bounded)
  then have "bdd_above (range P)" by (def_bdd_above)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy"): command expected,
*** but back-quoted string `` (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy") was found
*** At command "<malformed>" (line 817 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.62
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (581%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bound_of_least[intro]:
  assumes bP: "bounded_by b P"
  shows "bound_of P \<le> b"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding bound_of_def using bP by(intro cSup_least, auto)</code></pre>
<b>Generated proof:</b><pre><code>```
lemma bound_of_least[intro]:
  assumes bP: "bounded_by b P"
  shows "bound_of P \<le> b"

proof -
  from bP have "bound_of P \<le> b" by (rule bounded_by)
qed
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy"): command expected,
*** but back-quoted string `` (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy") was found
*** At command "<malformed>" (line 817 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.62
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (582%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bounded_by_bound_of[intro!]:
  fixes P::"'a \<Rightarrow> real"
  assumes bP: "bounded P"
  shows "bounded_by (bound_of P) P"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding bound_of_def using bP by(intro bounded_byI cSup_upper bounded_bdd_above, auto)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule bounded_by_bound_of)
```</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy"): command expected,
*** but back-quoted string `` (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy") was found
*** At command "<malformed>" (line 817 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.58
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (583%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bound_of_greater[intro]:
  "bounded P \<Longrightarrow> P x \<le> bound_of P"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (blast intro:bounded_byD)</code></pre>
<b>Generated proof:</b><pre><code>Proof:
1. Assume bounded P
2. By definition of bounded, there exists a bound such that for all x, P x <= bound_of P
3. Therefore, P x <= bound_of P
4. Hence, P x <= bound_ of P

QED.

Proof:
1. Assume bounded P
2. By definition of bounded, there exists a bound such that for all x, P x <= bound_of P
3. Therefore, P x <= bound_of P
4. Hence, P x <= bound_ of P

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy"): command expected,
*** but identifier Proof (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy") was found
*** At command "<malformed>" (line 817 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.63
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (584%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bounded_by_mono:
  "\<lbrakk> bounded_by a P; a \<le> b \<rbrakk> \<Longrightarrow> bounded_by b P"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding bounded_by_def by(blast intro:order_trans)</code></pre>
<b>Generated proof:</b><pre><code>Proof:

1. Assume "bounded_by a P" and "a <= b".
2. By the definition of bounded_by, there exists some x such that "P x" and "a <= x".
3. Since "a <= x" and "a <= b", by transitivity of <=, we have "x <= b".
4. Therefore, "P x" and "x <= b", which means "bounded_by b P" by the definition of bounded_by.

Hence, we have proved the theorem.

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy"): command expected,
*** but identifier Proof (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy") was found
*** At command "<malformed>" (line 817 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.61
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (585%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bounded_by_imp_bounded[intro]:
  "bounded_by b P \<Longrightarrow> bounded P"</h2><br>
<b>Ground proof:</b> <br><pre><code>unfolding bounded_def by(blast) text \<open>This is occasionally easier to apply:\<close></code></pre>
<b>Generated proof:</b><pre><code>Proof:
1. Assume "bounded_by b P"
2. By definition of bounded_by, we have "b > x ⟹ P x" for all x
3. Therefore, "P x" for all x, which means "bounded P"
4. Hence, "bounded_by b P \<Longrightarrow> bounded P"

QED.

Proof:
1. Assume "bounded_by b P"
2. By definition of bounded_by, we have "b > x ⟹ P x" for all x
3. Therefore, "P x" for all x, which means "bounded P"
4. Hence, "bounded_by b P \<Longrightarrow> bounded P"

QED.</s></code></pre><br><br>

                                    <div style="border:1px solid black">
                                        <span style="color: red; font-stye: bold">Failing Isabelle/HOL proof.</span><br>
                                        Error details: <br>
                                        <div style="font-style: italic;">Running pGCL ...
pGCL FAILED (see also "isabelle build_log -H Error pGCL")
*** Failed to load theory "pGCL.Transformers" (unresolved "pGCL.Expectations")
*** Failed to load theory "pGCL.Induction" (unresolved "pGCL.Expectations", "pGCL.Transformers")
*** Failed to load theory "pGCL.Embedding" (unresolved "pGCL.Induction")
*** Failed to load theory "pGCL.Healthiness" (unresolved "pGCL.Embedding")
*** Failed to load theory "pGCL.Continuity" (unresolved "pGCL.Healthiness")
*** Failed to load theory "pGCL.LoopInduction" (unresolved "pGCL.Continuity", "pGCL.Healthiness")
*** Failed to load theory "pGCL.Sublinearity" (unresolved "pGCL.Embedding", "pGCL.Healthiness", "pGCL.LoopInduction")
*** Failed to load theory "pGCL.WellDefined" (unresolved "pGCL.Healthiness", "pGCL.LoopInduction", "pGCL.Sublinearity")
*** Failed to load theory "pGCL.Algebra" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Determinism" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.StructuredReasoning" (unresolved "pGCL.Algebra")
*** Failed to load theory "pGCL.Loops" (unresolved "pGCL.WellDefined")
*** Failed to load theory "pGCL.Automation" (unresolved "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.Termination" (unresolved "pGCL.Embedding", "pGCL.Loops", "pGCL.StructuredReasoning")
*** Failed to load theory "pGCL.pGCL" (unresolved "pGCL.Algebra", "pGCL.Automation", "pGCL.Determinism", "pGCL.Embedding", "pGCL.Expectations", "pGCL.Healthiness", "pGCL.Induction", "pGCL.LoopInduction", "pGCL.Loops", "pGCL.StructuredReasoning", "pGCL.Sublinearity", "pGCL.Termination", "pGCL.Transformers", "pGCL.WellDefined")
*** Failed to load theory "pGCL.LoopExamples" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Monty" (unresolved "pGCL.pGCL")
*** Failed to load theory "pGCL.Primitives" (unresolved "pGCL.pGCL")
*** Outer syntax error (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy"): command expected,
*** but identifier Proof (line 819 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy") was found
*** At command "<malformed>" (line 817 of "~/repos/isabelle-proof-generator/afp-current-extractions/thys/pGCL/Expectations.thy")
Unfinished session(s): pGCL
0:00:05 elapsed time, 0:00:03 cpu time, factor 0.60
</div>
                                    </div><br>
                                    

                                Successes: 0.0 (0%) <-|-> Failures: 1.0 (586%)<br>
                                
<hr><hr><hr><hr>
<h2>lemma bounded_by_bound_of_alt:
  "\<lbrakk> bounded P; bound_of P = a \<rbrakk> \<Longrightarrow> bounded_by a P"</h2><br>
<b>Ground proof:</b> <br><pre><code>by (blast)</code></pre>
<b>Generated proof:</b><pre><code>```
by (rule bounded_by_bound_of_alt)
```</s></code></pre><br><br>
